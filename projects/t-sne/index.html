<!doctype html><html><head><title>t-SNE</title><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link rel=stylesheet href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans|Montserrat"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://jacksoncampolattaro.github.io/css/style.min.c625e454a81350b3b43e9943b99b1cfe3e91cb1b73acb449e14021c8d3fceb10.css></head><body><header id=header><h1><a href=https://jacksoncampolattaro.github.io/>Jackson <b>Campolattaro</b></a></h1><p>Computer Engineering student at TU Delft with an enthusiasm for Open Source software</p><img id=logo src=/img/portrait-square.jpeg width=100px></header><div id=page><div id=sidebar><nav><ul><li><a href=/about><span>About</span></a></li><li><a href=/contact><span>Contact</span></a></li></ul></nav><div id=contacts><a href=https://github.com/JacksonCampolattaro><i class="fa fa-github"></i></a>
<a href=mailto:jackson.campolattaro@gmail.com><i class="fa fa-envelope"></i></a>
<a href=https://www.linkedin.com/in/jacksoncampolattaro><i class="fa fa-linkedin"></i></a></div></div><div id=content><article class=post><h1><a href=https://jacksoncampolattaro.github.io/projects/t-sne/>t-SNE</a></h1><div class=post-content><figure><img src=/img/projects/t-sne-minimization.png></figure><p>T-distributed Stochastic Neighbor Embedding (t-SNE) is a technique for visualizing high dimensional data in fewer dimensions while preserving clusters. Probabilities are computed for each pair of high dimensional data points being part of the same group, and then points are placed randomly in the lower dimensional space and their positions are iteratively improved until the difference between the probabilities in low and high dimensional space is minimized. By analogy, t-SNE minimization simulates forces between all data points, attracting similar points and repelling dissimilar points. (A more detailed explanation of the method is available in <a href="https://docs.google.com/presentation/d/1NXjr6EaY4SX028BMw_Bo7VNOVgr5ualD7N-dPlzAVLQ/edit?usp=sharing">my presentation</a>)
. This is an example of an n-body problem, something I&rsquo;m familiar with from my ongoing <a href=https://jacksoncampolattaro.github.io/projects/n-body/>n-body project</a>.</p><p>In <a href=https://www.computer.org/csdl/journal/tg/2022/01/09552856/1xic3JUxdG8>a 2021 paper</a>, Mark van de Ruit et. al.
propose a novel method for evaluating this instance of the n-body problem, and provide an implementation for GPU which
outperformed the existing state-of-the-art in this domain. To better understand the details of this new method, As part of my seminar course in the fall of 2022, I
implemented a simplified version which runs on the CPU and produces a 2-dimensional embedding.</p><h2 id=algorithms>Algorithms</h2><p>My t-SNE visualization system begins by generating probability data using Sklearn, as the focus of the project is on the
minimization step only. Currently only MNIST data has been tested, but any dataset is theoretically compatible.</p><p>I found it useful to implement several other t-SNE minimization algorithms, both as intermediate steps in development
and as reference points in order to understand the performance characteristics of the final algorithm.</p><ul><li>I began by implementing a <strong>naive</strong> solution, which performed poorly but could be used to verify the correctness of more advanced minimizers.</li><li>Next, I implemented a minimizer based on the <strong>Barnes-hut</strong> algorithm, which builds a tree over the embedding space and computes interactions between each point and the clusters summarized by the nodes of the tree.</li><li>This was extended to work with a <strong>Linear-BVH</strong> in place of the typical Quadtree. This version uses a radix-sort along a space-filling curve to produce the tree in linear time complexity.</li><li>Finally, I added a <strong>dual-traversal</strong> minimizer which obtained better performance by computing node-node interactions in place of point-node interactions.</li><li>The <strong>dual-tree</strong> minimizer is an adaption of the dual-traversal minimizer, computing interactions between the nodes of a linear-BVH and nodes of a Quadtree.</li></ul><h2 id=visualizations>Visualizations</h2><p>While implementing these algorithms, it was also helpful to develop visualizations to show what was happening. All visualizations were implemented by hand using Cairomm, because performance was critical in order to watch the algorithms work in real time.</p><p>I began by creating a scatter plot of the embedding coordinates, color coded by their labels. The below image shows such a scatter plot from MNIST data during minimization.</p><p><div style=display:flex><div style=flex:1;margin-right:10px><img src=/img/projects/t-sne-early-exaggeration.png></div><div style=flex:1><img src=/img/projects/t-sne-complete-minimization.png></div></div><em>Scatter plot of the embedding early in minimization (left) and after minimization has completed (right)</em></p><p>I created another plot type which could show the bounding volume hierarchies used for acceleration. This proved very useful for optimization.</p><p><div style=display:flex><div style=flex:1;margin-right:10px><img src=/img/projects/t-sne-tree-plot.png></div><div style=flex:1><img src=/img/projects/t-sne-tree-plot-zoomed.png></div></div><em>Tree-plot of a Linear BVH early on in minimization (left) and a zoomed in view of the same plot (right)</em></p><p>While developing the Linear-BVH, I built an ordering plot to help me understand the space-filling curve which determines where points appear in the tree.</p><figure><img src=/img/projects/t-sne-ordering-plot.png alt="Ordering plot for a Linear BVH. The line connects points in the order they appear in the underlying list, with color transitioning from red to blue based on their index." width=75%><figcaption><p><em>Ordering plot for a Linear BVH. The line connects points in the order they appear in the underlying list, with color transitioning from red to blue based on their index.</em></p></figcaption></figure><p>Finally, implementing the dual hierarchy algorithm required a &ldquo;Field Tree&rdquo; which collects forces on each of its nodes. I created a new field tree plot which displayed the force vectors on each node as colors.</p><figure><img src=/img/projects/t-sne-field-tree-plot.png alt="Field tree plot for a Field-Quadtree. Each tree node is rendered as a translucent rectangle, colored based on the force applied to that node." width=75%><figcaption><p><em>Field tree plot for a Field-Quadtree. Each tree node is rendered as a translucent rectangle, colored based on the force applied to that node.</em></p></figcaption></figure><h2 id=ui>UI</h2><p>I bundled all of these visualizations together into a UI built with Gtkmm. This was useful for my final demo to the seminar class.</p><figure><img src=/img/projects/t-sne-ui.png alt="Application showing the embedding and debug view of a Dual Hierarchy minimization."><figcaption><p><em>Application showing the embedding and debug view of a Dual Hierarchy minimization.</em></p></figcaption></figure></div></article></div></div><footer><p>Powered by <a href=https://gohugo.io/>Hugo</a>,
see the source code <a href=https://github.com/JacksonCampolattaro/jacksoncampolattaro.github.io>here</a>.</p></footer></body></html>