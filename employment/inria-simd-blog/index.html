<!doctype html><html><head><title>Inria SIMD Blog</title><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link rel=stylesheet href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans|Montserrat"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://jacksoncampolattaro.github.io/css/style.min.08b25d526f7b4edf9560eca2ffd797c7b559264e18da790daee43ce79cf67a2e.css></head><body><header id=header><h1><a href=https://jacksoncampolattaro.github.io/>Jackson <b>Campolattaro</b></a></h1><p>Computer Engineering student at TU Delft with an enthusiasm for Open Source software</p><img id=logo src=/img/portrait-square.jpeg width=100px></header><div id=page><div id=sidebar><nav><ul><li><a href=/about><span>About</span></a></li><li><a href=/contact><span>Contact</span></a></li></ul></nav><div id=contacts><a href=https://github.com/JacksonCampolattaro><i class="fa fa-github"></i></a>
<a href=mailto:jackson.campolattaro@gmail.com><i class="fa fa-envelope"></i></a>
<a href=https://www.linkedin.com/in/jacksoncampolattaro><i class="fa fa-linkedin"></i></a></div></div><div id=content><article class=post><h1><a href=https://jacksoncampolattaro.github.io/employment/inria-simd-blog/>Inria SIMD Blog</a></h1><div class=post-content><blockquote>Note: This page is mirrored from my page on CGAL's internal wiki,
apologies for any incorrect formatting.</blockquote><html dir=ltr class=client-js lang=en><head><style>th,td{border:1px solid;padding:.5em 1em}.source-cpp{line-height:normal}.source-cpp li,.source-cpp pre{line-height:normal;border:0 #fff}.cpp.source-cpp .de1,.cpp.source-cpp .de2{font:1em/1.2em monospace;margin:0;padding:0;background:0 0;vertical-align:top;font-family:monospace,monospace}.cpp.source-cpp{font-family:monospace}.cpp.source-cpp .imp{font-weight:700;color:red}.cpp.source-cpp li,.cpp.source-cpp .li1{font-weight:400;vertical-align:top}.cpp.source-cpp .ln{width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top}.cpp.source-cpp .li2{font-weight:700;vertical-align:top}.cpp.source-cpp .kw1{color:#00f}.cpp.source-cpp .kw2{color:#00f}.cpp.source-cpp .kw3{color:#00d}.cpp.source-cpp .kw4{color:#00f}.cpp.source-cpp .co1{color:#666}.cpp.source-cpp .co2{color:#390}.cpp.source-cpp .coMULTI{color:red;font-style:italic}.cpp.source-cpp .es0{color:#009;font-weight:700}.cpp.source-cpp .es1{color:#009;font-weight:700}.cpp.source-cpp .es2{color:#609;font-weight:700}.cpp.source-cpp .es3{color:#609;font-weight:700}.cpp.source-cpp .es4{color:#609;font-weight:700}.cpp.source-cpp .es5{color:#069;font-weight:700}.cpp.source-cpp .br0{color:green}.cpp.source-cpp .sy0{color:green}.cpp.source-cpp .sy1{color:navy}.cpp.source-cpp .sy2{color:#000040}.cpp.source-cpp .sy3{color:#000040}.cpp.source-cpp .sy4{color:teal}.cpp.source-cpp .st0{color:red}.cpp.source-cpp .nu0{color:#00d}.cpp.source-cpp .nu6{color:#208080}.cpp.source-cpp .nu8{color:#208080}.cpp.source-cpp .nu12{color:#208080}.cpp.source-cpp .nu16{color:purple}.cpp.source-cpp .nu17{color:purple}.cpp.source-cpp .nu18{color:purple}.cpp.source-cpp .nu19{color:purple}.cpp.source-cpp .me1{color:#078}.cpp.source-cpp .me2{color:#078}.cpp.source-cpp .ln-xtra,.cpp.source-cpp li.ln-xtra,.cpp.source-cpp div.ln-xtra{background-color:#ffc}.cpp.source-cpp span.xtra{display:block}</style></head><body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-GSoC2021_AABB_tree skin-monobook action-view"><div id=globalWrapper><div id=column-content><div id=content class=mw-body-primary role=main><a id=top></a><div id=mw-content-text dir=ltr class=mw-content-ltr lang=en><div id=toc class=toc><div id=toctitle><h2>Contents</h2></div><ul><li class="toclevel-1 tocsection-1"><a href=#Introduction><span class=tocnumber>1</span>
<span class=toctext>Introduction</span></a></li><li class="toclevel-1 tocsection-2"><a href=#Project_Goals><span class=tocnumber>2</span>
<span class=toctext>Project Goals</span></a><ul><li class="toclevel-2 tocsection-3"><a href=#Minimum_Viable_Product><span class=tocnumber>2.1</span> <span class=toctext>Minimum Viable Product</span></a></li><li class="toclevel-2 tocsection-4"><a href=#Stretch_Goals><span class=tocnumber>2.2</span> <span class=toctext>Stretch Goals</span></a></li></ul></li><li class="toclevel-1 tocsection-5"><a href=#Timeline><span class=tocnumber>3</span> <span class=toctext>Timeline</span></a><ul><li class="toclevel-2 tocsection-6"><a href=#Now_-_June_7><span class=tocnumber>3.1</span> <span class=toctext>Now - June 7</span></a></li><li class="toclevel-2 tocsection-7"><a href=#June_7_-_June_21><span class=tocnumber>3.2</span>
<span class=toctext>June 7 - June 21</span></a></li><li class="toclevel-2 tocsection-8"><a href=#June_21_-_July_7><span class=tocnumber>3.3</span>
<span class=toctext>June 21 - July 7</span></a></li><li class="toclevel-2 tocsection-9"><a href=#July_7_-_July_21><span class=tocnumber>3.4</span>
<span class=toctext>July 7 - July 21</span></a></li><li class="toclevel-2 tocsection-10"><a href=#July_21_-_August_7><span class=tocnumber>3.5</span> <span class=toctext>July 21 - August 7</span></a></li><li class="toclevel-2 tocsection-11"><a href=#August_7_-_August_14><span class=tocnumber>3.6</span> <span class=toctext>August 7 - August 14</span></a></li></ul></li><li class="toclevel-1 tocsection-12"><a href=#Progress><span class=tocnumber>4</span> <span class=toctext>Progress</span></a><ul><li class="toclevel-2 tocsection-13"><a href=#May_1_-_May_17><span class=tocnumber>4.1</span>
<span class=toctext>May 1 - May 17</span></a><ul><li class="toclevel-3 tocsection-14"><a href=#Architectural_Analysis><span class=tocnumber>4.1.1</span> <span class=toctext>Architectural Analysis</span></a></li><li class="toclevel-3 tocsection-15"><a href=#Prevalence_of_SIMD_Instructions_in_Existing_Code><span class=tocnumber>4.1.2</span> <span class=toctext>Prevalence of SIMD Instructions in Existing Code</span></a></li></ul></li><li class="toclevel-2 tocsection-16"><a href=#May_18_-_June_1><span class=tocnumber>4.2</span>
<span class=toctext>May 18 - June 1</span></a><ul><li class="toclevel-3 tocsection-17"><a href=#Examining_Ray-BBox_Intersection><span class=tocnumber>4.2.1</span> <span class=toctext>Examining Ray-BBox Intersection</span></a></li><li class="toclevel-3 tocsection-18"><a href=#Choosing_a_SIMD_Approach><span class=tocnumber>4.2.2</span> <span class=toctext>Choosing a SIMD Approach</span></a><ul><li class="toclevel-4 tocsection-19"><a href=#Libraries><span class=tocnumber>4.2.2.1</span> <span class=toctext>Libraries</span></a></li></ul></li><li class="toclevel-3 tocsection-20"><a href=#Automated_SIMD_Prevalence_Analysis><span class=tocnumber>4.2.3</span> <span class=toctext>Automated SIMD Prevalence Analysis</span></a></li></ul></li><li class="toclevel-2 tocsection-21"><a href=#June_2_-_June_7><span class=tocnumber>4.3</span>
<span class=toctext>June 2 - June 7</span></a><ul><li class="toclevel-3 tocsection-22"><a href=#Ray-BBox_Intersection_Codes><span class=tocnumber>4.3.1</span>
<span class=toctext>Ray-BBox Intersection Codes</span></a></li><li class="toclevel-3 tocsection-23"><a href=#SIMD_Prevalence_for_Different_Implementations><span class=tocnumber>4.3.2</span> <span class=toctext>SIMD Prevalence for Different Implementations</span></a><ul><li class="toclevel-4 tocsection-24"><a href=#Smits.27_Method><span class=tocnumber>4.3.2.1</span> <span class=toctext>Smits' Method</span></a></li><li class="toclevel-4 tocsection-25"><a href=#Improved><span class=tocnumber>4.3.2.2</span> <span class=toctext>Improved</span></a></li><li class="toclevel-4 tocsection-26"><a href=#Clarified><span class=tocnumber>4.3.2.3</span> <span class=toctext>Clarified</span></a></li><li class="toclevel-4 tocsection-27"><a href=#Branchless><span class=tocnumber>4.3.2.4</span> <span class=toctext>Branchless</span></a></li></ul></li></ul></li><li class="toclevel-2 tocsection-28"><a href=#June_8_-_June_15><span class=tocnumber>4.4</span> <span class=toctext>June 8 - June 15</span></a><ul><li class="toclevel-3 tocsection-29"><a href=#Collecting_Test_Data_for_Benchmarking><span class=tocnumber>4.4.1</span>
<span class=toctext>Collecting Test Data for Benchmarking</span></a></li><li class="toclevel-3 tocsection-30"><a href=#Initial_Benchmark_Results><span class=tocnumber>4.4.2</span> <span class=toctext>Initial Benchmark Results</span></a></li><li class="toclevel-3 tocsection-31"><a href=#Tweaks_to_Benchmarks><span class=tocnumber>4.4.3</span> <span class=toctext>Tweaks to Benchmarks</span></a></li><li class="toclevel-3 tocsection-32"><a href=#Intersection_using_XSimd><span class=tocnumber>4.4.4</span> <span class=toctext>Intersection using XSimd</span></a></li><li class="toclevel-3 tocsection-33"><a href=#Switching_from_Line_Segments_to_Rays><span class=tocnumber>4.4.5</span>
<span class=toctext>Switching from Line Segments to Rays</span></a></li><li class="toclevel-3 tocsection-34"><a href=#Effects_of_inline><span class=tocnumber>4.4.6</span> <span class=toctext>Effects of inline</span></a></li></ul></li><li class="toclevel-2 tocsection-35"><a href=#June_16_-_June_22><span class=tocnumber>4.5</span> <span class=toctext>June 16 - June 22</span></a><ul><li class="toclevel-3 tocsection-36"><a href=#Restructuring_Benchmarks><span class=tocnumber>4.5.1</span> <span class=toctext>Restructuring Benchmarks</span></a></li><li class="toclevel-3 tocsection-37"><a href=#Validating_benchmarks_for_Correctness><span class=tocnumber>4.5.2</span>
<span class=toctext>Validating benchmarks for Correctness</span></a><ul><li class="toclevel-4 tocsection-38"><a href=#Performance_Implications><span class=tocnumber>4.5.2.1</span> <span class=toctext>Performance Implications</span></a></li></ul></li><li class="toclevel-3 tocsection-39"><a href=#.22Struct-of-Arrays.22_BBox_type><span class=tocnumber>4.5.3</span> <span class=toctext>"Struct-of-Arrays" BBox type</span></a><ul><li class="toclevel-4 tocsection-40"><a href=#VBBox><span class=tocnumber>4.5.3.1</span> <span class=toctext>VBBox</span></a></li><li class="toclevel-4 tocsection-41"><a href=#Benchmark_Results><span class=tocnumber>4.5.3.2</span> <span class=toctext>Benchmark Results</span></a></li><li class="toclevel-4 tocsection-42"><a href=#Relevance_to_Real-life_use><span class=tocnumber>4.5.3.3</span>
<span class=toctext>Relevance to Real-life use</span></a></li></ul></li><li class="toclevel-3 tocsection-43"><a href=#Caching_Broadcasted_Ray><span class=tocnumber>4.5.4</span> <span class=toctext>Caching Broadcasted Ray</span></a><ul><li class="toclevel-4 tocsection-44"><a href=#Benchmark_Results_2><span class=tocnumber>4.5.4.1</span> <span class=toctext>Benchmark Results</span></a></li></ul></li></ul></li><li class="toclevel-2 tocsection-45"><a href=#June_23_-_June_30><span class=tocnumber>4.6</span> <span class=toctext>June 23 - June 30</span></a><ul><li class="toclevel-3 tocsection-46"><a href=#.22Array_of_Structs_of_Arrays.22_BBox><span class=tocnumber>4.6.1</span>
<span class=toctext>"Array of Structs of Arrays" BBox</span></a><ul><li class="toclevel-4 tocsection-47"><a href=#Benchmark_Results_3><span class=tocnumber>4.6.1.1</span> <span class=toctext>Benchmark Results</span></a></li></ul></li></ul></li><li class="toclevel-2 tocsection-48"><a href=#July_1_-_July_8><span class=tocnumber>4.7</span>
<span class=toctext>July 1 - July 8</span></a><ul><li class="toclevel-3 tocsection-49"><a href=#Performing_Benchmarks_on_Deepsat><span class=tocnumber>4.7.1</span> <span class=toctext>Performing Benchmarks on Deepsat</span></a><ul><li class="toclevel-4 tocsection-50"><a href=#Results><span class=tocnumber>4.7.1.1</span> <span class=toctext>Results</span></a></li></ul></li><li class="toclevel-3 tocsection-51"><a href=#Experimenting_with_Application_of_OpenMP_Directives><span class=tocnumber>4.7.2</span> <span class=toctext>Experimenting with Application of OpenMP Directives</span></a></li><li class="toclevel-3 tocsection-52"><a href=#Profiling_Mesh_3_remesh_polyhedral_surface_sm><span class=tocnumber>4.7.3</span> <span class=toctext>Profiling Mesh_3 remesh_polyhedral_surface_sm</span></a></li><li class="toclevel-3 tocsection-53"><a href=#Branchless_do_intersect_bbox_segment_aux><span class=tocnumber>4.7.4</span> <span class=toctext>Branchless do_intersect_bbox_segment_aux</span></a></li><li class="toclevel-3 tocsection-54"><a href=#Meeting_with_Adrien_Cassagne><span class=tocnumber>4.7.5</span> <span class=toctext>Meeting with Adrien Cassagne</span></a></li><li class="toclevel-3 tocsection-55"><a href=#Branchless_BBox-BBox_Intersection><span class=tocnumber>4.7.6</span> <span class=toctext>Branchless BBox-BBox Intersection</span></a></li></ul></li><li class="toclevel-2 tocsection-56"><a href=#July_9_-_July_16><span class=tocnumber>4.8</span> <span class=toctext>July 9 - July 16</span></a><ul><li class="toclevel-3 tocsection-57"><a href=#Truly_Branchless_do_intersect_bbox_segment_aux><span class=tocnumber>4.8.1</span> <span class=toctext><i>Truly</i> Branchless do_intersect_bbox_segment_aux</span></a></li><li class="toclevel-3 tocsection-58"><a href=#Benchmarking_the_Child-Skipping_Optimization><span class=tocnumber>4.8.2</span> <span class=toctext>Benchmarking the Child-Skipping Optimization</span></a></li><li class="toclevel-3 tocsection-59"><a href=#Preparing_to_implement_N-Way_Splitting><span class=tocnumber>4.8.3</span>
<span class=toctext>Preparing to implement N-Way Splitting</span></a><ul><li class="toclevel-4 tocsection-60"><a href=#Planning><span class=tocnumber>4.8.3.1</span> <span class=toctext>Planning</span></a></li><li class="toclevel-4 tocsection-61"><a href=#Child_Array><span class=tocnumber>4.8.3.2</span> <span class=toctext>Child Array</span></a></li><li class="toclevel-4 tocsection-62"><a href=#std::variant_Children><span class=tocnumber>4.8.3.3</span> <span class=toctext>std::variant Children</span></a></li><li class="toclevel-4 tocsection-63"><a href=#Pointer-to-array_replaces_Array-of-pointers><span class=tocnumber>4.8.3.4</span> <span class=toctext>Pointer-to-array replaces Array-of-pointers</span></a></li><li class="toclevel-4 tocsection-64"><a href=#Single-primitive_leaves><span class=tocnumber>4.8.3.5</span> <span class=toctext>Single-primitive leaves</span></a></li><li class="toclevel-4 tocsection-65"><a href=#Simplified_Traversal_Method><span class=tocnumber>4.8.3.6</span>
<span class=toctext>Simplified Traversal Method</span></a></li><li class="toclevel-4 tocsection-66"><a href=#Simplified_Ray-Traversal_Method><span class=tocnumber>4.8.3.7</span>
<span class=toctext>Simplified Ray-Traversal Method</span></a></li><li class="toclevel-4 tocsection-67"><a href=#Eliminating_use_of_.22left.22_and_.22right.22><span class=tocnumber>4.8.3.8</span> <span class=toctext>Eliminating use of "left" and "right"</span></a></li></ul></li></ul></li><li class="toclevel-2 tocsection-68"><a href=#July_17_-_July_24><span class=tocnumber>4.9</span> <span class=toctext>July 17 - July 24</span></a><ul><li class="toclevel-3 tocsection-69"><a href=#Enabling_N-Way_Splitting><span class=tocnumber>4.9.1</span> <span class=toctext>Enabling N-Way Splitting</span></a></li><li class="toclevel-3 tocsection-70"><a href=#Cleaning_up_Traversal_code><span class=tocnumber>4.9.2</span> <span class=toctext>Cleaning up Traversal code</span></a></li><li class="toclevel-3 tocsection-71"><a href=#Benchmarking_Different_types_of_Intersections><span class=tocnumber>4.9.3</span> <span class=toctext>Benchmarking Different types of Intersections</span></a></li><li class="toclevel-3 tocsection-72"><a href=#Implementing_a_simple_Boxed_Query_technique><span class=tocnumber>4.9.4</span> <span class=toctext>Implementing a simple Boxed Query technique</span></a></li></ul></li><li class="toclevel-2 tocsection-73"><a href=#July_25_-_August_2><span class=tocnumber>4.10</span> <span class=toctext>July 25 - August 2</span></a><ul><li class="toclevel-3 tocsection-74"><a href=#Using_Boxed_Queries_to_Traverse_the_Tree><span class=tocnumber>4.10.1</span> <span class=toctext>Using Boxed Queries to Traverse the Tree</span></a><ul><li class="toclevel-4 tocsection-75"><a href=#Specialized_Traversal_Function><span class=tocnumber>4.10.1.1</span>
<span class=toctext>Specialized Traversal Function</span></a></li><li class="toclevel-4 tocsection-76"><a href=#Invalidating_Traversal_Traits_Assumptions><span class=tocnumber>4.10.1.2</span> <span class=toctext>Invalidating Traversal Traits Assumptions</span></a></li></ul></li><li class="toclevel-3 tocsection-77"><a href=#Issues_with_Traversal_Correctness><span class=tocnumber>4.10.2</span> <span class=toctext>Issues with Traversal Correctness</span></a><ul><li class="toclevel-4 tocsection-78"><a href=#Compatibility_with_Epeck><span class=tocnumber>4.10.2.1</span>
<span class=toctext>Compatibility with Epeck</span></a></li></ul></li><li class="toclevel-3 tocsection-79"><a href=#Interval-based_Boxing><span class=tocnumber>4.10.3</span> <span class=toctext>Interval-based Boxing</span></a><ul><li class="toclevel-4 tocsection-80"><a href=#Performance_Results><span class=tocnumber>4.10.3.1</span> <span class=toctext>Performance Results</span></a></li></ul></li><li class="toclevel-3 tocsection-81"><a href=#Tunable_Parameters><span class=tocnumber>4.10.4</span> <span class=toctext>Tunable Parameters</span></a><ul><li class="toclevel-4 tocsection-82"><a href=#Conditional_Shrinking><span class=tocnumber>4.10.4.1</span> <span class=toctext>Conditional Shrinking</span></a></li><li class="toclevel-4 tocsection-83"><a href=#Multi-BBox><span class=tocnumber>4.10.4.2</span> <span class=toctext>Multi-BBox</span></a></li><li class="toclevel-4 tocsection-84"><a href=#Children_per_node><span class=tocnumber>4.10.4.3</span> <span class=toctext>Children per node</span></a></li><li class="toclevel-4 tocsection-85"><a href=#Trust_in_the_Filter><span class=tocnumber>4.10.4.4</span> <span class=toctext>Trust in the Filter</span></a></li><li class="toclevel-4 tocsection-86"><a href=#Optimal_Results><span class=tocnumber>4.10.4.5</span> <span class=toctext>Optimal Results</span></a></li></ul></li><li class="toclevel-3 tocsection-87"><a href=#Only_Lines_Benefit_from_this_Optimization><span class=tocnumber>4.10.5</span> <span class=toctext>Only Lines Benefit from this Optimization</span></a></li></ul></li><li class="toclevel-2 tocsection-88"><a href=#August_3_-_August_10><span class=tocnumber>4.11</span> <span class=toctext>August 3 - August 10</span></a><ul><li class="toclevel-3 tocsection-89"><a href=#Feasibility_of_a_Compact_Tree_Structure><span class=tocnumber>4.11.1</span>
<span class=toctext>Feasibility of a Compact Tree Structure</span></a><ul><li class="toclevel-4 tocsection-90"><a href=#Why_isn.27t_Embree_doing_this.3F><span class=tocnumber>4.11.1.1</span> <span class=toctext>Why isn't Embree doing this?</span></a></li></ul></li><li class="toclevel-3 tocsection-91"><a href=#Potential_API_for_an_Implicit_Tree><span class=tocnumber>4.11.2</span>
<span class=toctext>Potential API for an Implicit Tree</span></a></li><li class="toclevel-3 tocsection-92"><a href=#Preparing_to_implement_Implicit_Tree_construction><span class=tocnumber>4.11.3</span> <span class=toctext>Preparing to implement Implicit Tree construction</span></a><ul><li class="toclevel-4 tocsection-93"><a href=#Planning_2><span class=tocnumber>4.11.3.1</span> <span class=toctext>Planning</span></a></li><li class="toclevel-4 tocsection-94"><a href=#.22Fat_nodes.22_intermediate_solution><span class=tocnumber>4.11.3.2</span> <span class=toctext>"Fat nodes" intermediate solution</span></a></li><li class="toclevel-4 tocsection-95"><a href=#Making_the_nodes_more_compact><span class=tocnumber>4.11.3.3</span>
<span class=toctext>Making the nodes more compact</span></a></li><li class="toclevel-4 tocsection-96"><a href=#Moving_traversal_logic_to_the_tree><span class=tocnumber>4.11.3.4</span> <span class=toctext>Moving traversal logic to the tree</span></a></li></ul></li><li class="toclevel-3 tocsection-97"><a href=#The_source_of_N-Way_Tree.27s_performance_advantage><span class=tocnumber>4.11.4</span> <span class=toctext>The source of N-Way Tree's performance advantage</span></a></li><li class="toclevel-3 tocsection-98"><a href=#Building_a_tree_using_a_sort_along_the_Hilbert_curve><span class=tocnumber>4.11.5</span> <span class=toctext>Building a tree using a sort along the Hilbert curve</span></a><ul><li class="toclevel-4 tocsection-99"><a href=#Performance><span class=tocnumber>4.11.5.1</span> <span class=toctext>Performance</span></a></li></ul></li><li class="toclevel-3 tocsection-100"><a href=#Building_a_Complete_tree_with_repeated_subdivision><span class=tocnumber>4.11.6</span> <span class=toctext>Building a Complete tree with repeated subdivision</span></a><ul><li class="toclevel-4 tocsection-101"><a href=#Generalizing_to_higher-order_trees><span class=tocnumber>4.11.6.1</span> <span class=toctext>Generalizing to higher-order trees</span></a></li></ul></li><li class="toclevel-3 tocsection-102"><a href=#Better_benchmarks_for_Hilbert-sort_construction><span class=tocnumber>4.11.7</span> <span class=toctext>Better benchmarks for Hilbert-sort construction</span></a></li><li class="toclevel-3 tocsection-103"><a href=#Improving_Hilbert_sort_construction_performance><span class=tocnumber>4.11.8</span> <span class=toctext>Improving Hilbert sort construction performance</span></a><ul><li class="toclevel-4 tocsection-104"><a href=#Bottom-up_boxing><span class=tocnumber>4.11.8.1</span> <span class=toctext>Bottom-up boxing</span></a></li><li class="toclevel-4 tocsection-105"><a href=#Multithreading><span class=tocnumber>4.11.8.2</span> <span class=toctext>Multithreading</span></a></li></ul></li><li class="toclevel-3 tocsection-106"><a href=#More_challenging_benchmarks><span class=tocnumber>4.11.9</span> <span class=toctext>More challenging benchmarks</span></a><ul><li class="toclevel-4 tocsection-107"><a href=#Larger_dataset><span class=tocnumber>4.11.9.1</span> <span class=toctext>Larger dataset</span></a></li><li class="toclevel-4 tocsection-108"><a href=#Real-life_use_case><span class=tocnumber>4.11.9.2</span> <span class=toctext>Real-life use case</span></a></li></ul></li></ul></li><li class="toclevel-2 tocsection-109"><a href=#August_11_-_August_17><span class=tocnumber>4.12</span> <span class=toctext>August 11 - August 17</span></a><ul><li class="toclevel-3 tocsection-110"><a href=#Quantifying_tradeoffs><span class=tocnumber>4.12.1</span> <span class=toctext>Quantifying tradeoffs</span></a></li><li class="toclevel-3 tocsection-111"><a href=#More_diverse_test_data><span class=tocnumber>4.12.2</span> <span class=toctext>More diverse test data</span></a><ul><li class="toclevel-4 tocsection-112"><a href=#Gargoyle><span class=tocnumber>4.12.2.1</span> <span class=toctext>Gargoyle</span></a></li><li class="toclevel-4 tocsection-113"><a href=#Rotated_Sphere-grid><span class=tocnumber>4.12.2.2</span> <span class=toctext>Rotated Sphere-grid</span></a></li><li class="toclevel-4 tocsection-114"><a href=#Mixed_Sphere-grid><span class=tocnumber>4.12.2.3</span> <span class=toctext>Mixed Sphere-grid</span></a></li></ul></li><li class="toclevel-3 tocsection-115"><a href=#Switching_from_Median_to_Middle_Hilbert_Policy><span class=tocnumber>4.12.3</span> <span class=toctext>Switching from Median to Middle Hilbert Policy</span></a><ul><li class="toclevel-4 tocsection-116"><a href=#Gargoyle_2><span class=tocnumber>4.12.3.1</span> <span class=toctext>Gargoyle</span></a></li><li class="toclevel-4 tocsection-117"><a href=#Rotated_Sphere-grid_2><span class=tocnumber>4.12.3.2</span> <span class=toctext>Rotated Sphere-grid</span></a></li><li class="toclevel-4 tocsection-118"><a href=#Mixed_Sphere-grid_2><span class=tocnumber>4.12.3.3</span> <span class=toctext>Mixed Sphere-grid</span></a></li></ul></li><li class="toclevel-3 tocsection-119"><a href=#More_exploration_of_Implicit_Tree_Structures><span class=tocnumber>4.12.4</span> <span class=toctext>More exploration of Implicit Tree Structures</span></a><ul><li class="toclevel-4 tocsection-120"><a href=#Use_of_Assertions><span class=tocnumber>4.12.4.1</span> <span class=toctext>Use of Assertions</span></a></li></ul></li><li class="toclevel-3 tocsection-121"><a href=#.22Fully_boxed.22_vs_.22Leafless.22_trees><span class=tocnumber>4.12.5</span> <span class=toctext>"Fully boxed" vs "Leafless" trees</span></a><ul><li class="toclevel-4 tocsection-122"><a href=#Leafless_Implicit_Tree><span class=tocnumber>4.12.5.1</span> <span class=toctext>Leafless Implicit Tree</span></a></li></ul></li><li class="toclevel-3 tocsection-123"><a href=#Benchmarking_tree_configurations><span class=tocnumber>4.12.6</span> <span class=toctext>Benchmarking tree configurations</span></a></li></ul></li></ul></li><li class="toclevel-1 tocsection-124"><a href=#Proposed_Optimizations><span class=tocnumber>5</span>
<span class=toctext>Proposed Optimizations</span></a></li><li class="toclevel-1 tocsection-125"><a href=#Queue><span class=tocnumber>6</span> <span class=toctext>Queue</span></a></li></ul></div><h1><span class=mw-headline id=Introduction><span class=mw-headline-number>1</span> Introduction</span></h1><p>CGAL’s AABB-Tree is an acceleration structure which speeds up common
tasks such as collision-detection.
It is used both directly and throughout other packages in the library,
so any performance improvements made to this package will pay dividends
elsewhere.
The package has already been a major target of performance optimization,
but one approach that hasn’t yet been fully explored is the use of
SIMD,
a type of parallel computation where the processor operates on several
data values at a time.
The introduction of SIMD optimizations to the AABB tree has the
potential to substantially improve performance by better taking
advantage of the capabilities of modern computer processors.</p><h1><span class=mw-headline id=Project_Goals><span class=mw-headline-number>2</span> Project Goals</span></h1><h3><span class=mw-headline id=Minimum_Viable_Product><span class=mw-headline-number>2.1</span> Minimum Viable Product</span></h3><ul><li>Benchmarks which compare the performance of CGAL’s AABB-tree and
other implementations with realistic workloads. This includes benchmarks
of both intersection and distance query functionality, for a variety of
primitives.</li><li>Documentation of targets for improvement in the current implementation, based on profiling with
large-scale benchmarks.</li><li>Selection of a SIMD library, and incorporation of SIMD techniques into the AABB-tree.</li><li>Benchmarks which demonstrate an improvement in performance when SIMD is enabled.</li></ul><h3><span class=mw-headline id=Stretch_Goals><span class=mw-headline-number>2.2</span> Stretch Goals</span></h3><ul><li>Performance that approaches that of Embree’s Bounding Volume Hierarchy.</li><li>Application of similar optimization techniques to other tree
packages in CGAL, including the kD-Tree and the Orthtree, the subject of
my Google Summer of Code assignment in 2020.</li></ul><h1><span class=mw-headline id=Timeline><span class=mw-headline-number>3</span> Timeline</span></h1><h3><span class=mw-headline id=Now_-_June_7><span class=mw-headline-number>3.1</span> Now - June 7</span></h3><p><i>Community Bonding Period</i></p><ul><li>Learn about the AABB-tree’s functionality as well as its implementation details.</li><li>Build benchmarks for existing tree structures</li><li>Select a library for SIMD</li></ul><h3><span class=mw-headline id=June_7_-_June_21><span class=mw-headline-number>3.2</span> June 7 - June 21</span></h3><ul><li>Collect performance data through profiling using Intel’s VTune</li><li>Assemble a table with areas where Embree has the largest performance advantages</li></ul><p>[Benchmark Pull Request Merged]</p><h3><span class=mw-headline id=June_21_-_July_7><span class=mw-headline-number>3.3</span> June 21 - July 7</span></h3><ul><li>Document optimizations used by Embree</li><li>Rank optimizations by expected performance yield, and feasibility with respect to the
AABB-tree’s current structure.</li></ul><h3><span class=mw-headline id=July_7_-_July_21><span class=mw-headline-number>3.4</span> July 7 - July 21</span></h3><ul><li>Apply high-yield optimizations which don’t conflict with AABB-tree’s existing structure.</li><li>Apply any optimizations which are self-contained (for example, ones which only require changes
to individual functions)</li><li>Benchmark each change, and use unit tests to confirm that no changes conflict with one another</li></ul><h3><span class=mw-headline id=July_21_-_August_7><span class=mw-headline-number>3.5</span> July 21 - August 7</span></h3><ul><li>Apply high-yield optimizations which may require more invasive changes to AABB-tree’s
implementation</li><li>Benchmark new changes, repeat integration test</li></ul><h3><span class=mw-headline id=August_7_-_August_14><span class=mw-headline-number>3.6</span> August 7 - August 14</span></h3><ul><li>Apply any remaining optimizations that only require simple changes to the AABB-tree.</li><li>Extend AABB-tree manual to discuss all new optimizations.</li></ul><p>[Optimization Pull Request Merged]</p><h1><span class=mw-headline id=Progress><span class=mw-headline-number>4</span> Progress</span></h1><h2><span class=mw-headline id=May_1_-_May_17><span class=mw-headline-number>4.1</span> May 1 - May 17</span></h2><h3><span class=mw-headline id=Architectural_Analysis><span class=mw-headline-number>4.1.1</span> Architectural Analysis</span></h3><p><a href=https://cgal.geometryfactory.com/CGAL/Members/wiki/GSoC2020/Embree title=GSoC2020/Embree>Ayush Saraswat's work during GSoC 2020</a> demonstrated a massive performance advantage in favor of
Embree (over CGAL's AABB-tree).
It remains to be seen how much of this advantage comes from SIMD, and how much is architectural.</p><p>Pierre Alliez suggested I look at a <a rel=nofollow class="external text" href=https://diglib.eg.org/handle/10.1111/cgf142662>particular
survey</a> of contemporary Bounding Volume Hierarchy design practices.
The survey discusses a number of features and optimizations which trees might include.
Characterizing both trees with regard to this survey was a good way of doing a motivated tour of the
code-bases.</p><table class=wikitable><tbody><tr><th>Feature</th><th>CGAL</th><th>Embree</th><th>Description</th></tr><tr><th scope=row>Construction Strategy</th><td>Top-down</td><td>Top-down</td><td>Is the tree built root-first (then split), or leaves first (then combined)?</td></tr><tr><th scope=row>Incremental Construction</th><td>Yes</td><td>No</td><td>Can primitives be added to the tree without completely reconstructing it?</td></tr><tr><th scope=row>Linear BVH</th><td>No</td><td>Yes (Morton codes)</td><td>Can the tree be built faster by first sorting primitives along a space-filling curve?</td></tr><tr><th scope=row>Topology Optimization</th><td>No?</td><td>Yes (Binned SAH)</td><td>Can the tree be refined so that it's optimal by some measure, for example minimal total
surface area of bounding boxes?</td></tr><tr><th scope=row>Subtree Collapsing</th><td>No</td><td>No?</td><td>Can leaf nodes contain more than N primitives?</td></tr><tr><th scope=row>Data Layout Approach</th><td>Naive?</td><td>Preallocated, aligned</td><td>How is the tree explicitly arranged in memory to reduce cache misses during common
operations?</td></tr><tr><th scope=row>Hardware Acceleration</th><td>Multithreading</td><td>Multithreading, SIMD</td><td>What hardware features does the tree take advantage of?</td></tr><tr><th scope=row>Spatial Splits</th><td>No</td><td>Yes</td><td>Can primitives be broken into multiple parts along bbox boundaries?</td></tr><tr><th scope=row>Wide BVH</th><td>No</td><td>Yes (N-way splits)</td><td>Can the space be partitioned in more than two ways at each node?</td></tr><tr><th scope=row>Non-Polygonal Objects</th><td>No</td><td>Yes</td><td>Does the tree provide optimized support for different primitive types?</td></tr><tr><th scope=row>Compact Representation</th><td>Lower-precision bbox</td><td>Naive?</td><td>What efforts does the tree make to avoid taking up too much memory?</td></tr><tr><th scope=row>First-hit Traversal</th><td>Yes</td><td>Yes</td><td>Can you use the tree to find the first primitive a ray intersects with?</td></tr><tr><th scope=row>Any-hit Traversal</th><td>Yes</td><td>Yes</td><td>Can you use the tree to find out whether or not a ray intersects with any primitives?</td></tr><tr><th scope=row>Multi-hit Traversal</th><td>Yes</td><td>No</td><td>Can you use the tree to find the list of primitives a ray intersects with?</td></tr><tr><th scope=row>Stream Traversal</th><td>No?</td><td>Yes</td><td>Does the tree provide accelerated support for intersections with groups of similar rays?</td></tr><tr><th scope=row>Stackless Traversal</th><td>No</td><td>Yes? (Skip-links)</td><td>Is traversal done non-recursively, instead following a ray directly between adjacent nodes?</td></tr><tr><th scope=row>Ray-locality Opt.</th><td>No</td><td>No</td><td>Can you traverse the tree without loading faraway nodes into memory?</td></tr></tbody></table><p>CGAL's AABB-tree seems a lot more "vanilla" compared to Embree, and I
think that's because a lot of Embree's optimizations are incompatible
with CGAL's high level of genericity.
For example, it might be impossible to generate morton codes for a lot
of CGAL's kernels, and explicit data layout might not be useful for
variable-precision types.
CGAL naturally can't provide a lot of the same guarantees about the data
being worked with, and that excludes certain optimizations.</p><p>I think Embree's Wide BVH implementation is a good example of how it takes advantage of SIMD.
Each node of the tree has bounds defined using a custom vector type of size N (e.g. <code>vfloat&lt;N>
lower_x</code>).
When N is less than the number of SIMD units, bounds checking can be
done in a similar number of instructions to a conventional (two-child)
tree!
Notably, the underlying data structure of the <code>vfloat&lt;N></code>
type is a simple C-style array.
As I understand it, the team that develops Embree works closely with the
Intel compiler team to make sure that their code can be compiled to
packed SIMD instructions,
rather than using intrinsics explicitly.</p><p>I was hoping Ayush Saraswat's benchmarks would be indicative of
the performance gain SIMD can offer, but it seems like the two trees
might just be too different to compare directly like that.
Embree has some advantage because it doesn't need to guarantee
exactness, and some because of its more elaborate architecture.
In order to determine where SIMD is making the biggest difference, it's
necessary to either quantify or eliminate these other advantages.</p><h3><span class=mw-headline id=Prevalence_of_SIMD_Instructions_in_Existing_Code><span class=mw-headline-number>4.1.2</span> Prevalence of SIMD Instructions in Existing Code</span></h3><p>Before attempting to introduce SIMD, an important question is how
much the existing code already takes advantage of vectorized
instructions.
Modern compilers are very adept at vectorizing code that may not appear
to use SIMD, by unrolling loops or recognizing blocks of code with
implicitly parallel behavior.</p><p>The laptop I'm working on has an Intel i7-7700HQ CPU, which
supports instruction sets up to SSE 4.2 and AVX 2.
Depending on what compiler flags are set in CGAL's default release
config, this means that the emitted assembly should at least contain
some SSE instructions,
and perhaps AVX instructions too (though in my experience, AVX must be
explicitly enabled).</p><p>To determine this, I compiled the AABB-tree's Ray-shooting
example in release mode, with no modifications to CGAL's default
compiler flags.
I counted packed SIMD instructions with the help of awk (piped to wc), a
modification of the technique discussed <a rel=nofollow class="external text" href=https://stackoverflow.com/questions/47878352/how-to-check-if-compiled-code-uses-sse-and-avx-instructions/50056059>here</a>.</p><table class=wikitable><tbody><tr><th>Instruction Set</th><th># of Instructions</th><th>&nbsp;% of Program</th></tr><tr><td>All</td><td>23,256</td><td>100%</td></tr><tr><td>SSE</td><td>446</td><td>1.917%</td></tr><tr><td>SSE2</td><td>401</td><td>1.724%</td></tr><tr><td>SSE3</td><td>0</td><td>0.00%</td></tr><tr><td>SSSE3</td><td>0</td><td>0.00%</td></tr><tr><td>SSE4</td><td>0</td><td>0.00%</td></tr><tr><td>AVX</td><td>0</td><td>0.00%</td></tr></tbody></table><p>To my surprise, the program contains <u>no</u> SIMD instructions beyond SSE2.
It remains to be seen what the cause of this is, but this is actually very good news for this
project:
because the existing code isn't already taking full advantage of the CPU, I have a lot of
performance headroom!</p><p>Further examination shows that CGAL's default release config for CMake on Fedora does not enable
<code>-march=native</code>.
This is because it's intended to be distributed as a binary (with broad
hardware compatibility).
Because CGAL is a header-only library, users don't need to accept the
same compromise-- they can build with whatever flags they like.</p><h2><span class=mw-headline id=May_18_-_June_1><span class=mw-headline-number>4.2</span> May 18 - June 1</span></h2><h3><span class=mw-headline id=Examining_Ray-BBox_Intersection><span class=mw-headline-number>4.2.1</span> Examining Ray-BBox Intersection</span></h3><p>According to included comments, CGAL's ray-bbox intersection algorithm is inspired by <a rel=nofollow class="external text" href=http://people.csail.mit.edu/amy/papers/box-jgt.ps>this
paper</a>.
On Pierre's suggestion, I'm exploring how SIMD could be used to accelerate this operation.</p><p><i><b>NOTE: Technically this algorithm performs intersections
between line segments and bounding boxes, but it can generalize to
infinite rays. Both the algorithm and CGAL refer to it as Ray-BBox
intersection, so I will remain consistent with that pattern.</b></i></p><p>First, I read through the discussed algorithm, and traced its operation on paper for a very simple
example case.</p><p>Next, I put together a simplified version of the algorithm in the
paper.
This is somewhat closer to psuedocode than the paper, it's also written
more verbosely, to help understand exactly what's happening.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>class</span> BBox <span class=br0>{</span>
    Vector3 bounds<span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=sy4>;</span>
<span class=br0>}</span>
&nbsp;
<span class=kw2>class</span> Ray <span class=br0>{</span>
    Vector3 origin, direction, inv_direction<span class=sy4>;</span>
    <span class=kw4>int</span> sign<span class=br0>[</span><span class=nu0>3</span><span class=br0>]</span><span class=sy4>;</span> <span class=co1>// I'd like a more semantically appropriate way of representing this!</span>
<span class=br0>}</span>
&nbsp;
<span class=kw4>bool</span> intersects<span class=br0>(</span>BBox box, Ray ray, <span class=kw4>float</span> rmin, <span class=kw4>float</span> rmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=co1>// Determine bounds for x and y</span>
    <span class=kw4>float</span> xmin <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>x</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> xmax <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>x</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymin <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>y</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>y</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymax <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>y</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>y</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// If the x and y bounds don't overlap, the ray doesn't intersect with the box</span>
    <span class=kw1>if</span> <span class=br0>(</span>xmin <span class=sy1>&gt;</span> ymax <span class=sy3>||</span> ymin <span class=sy1>&gt;</span> xmax<span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the bounds of the overlapping region</span>
    min <span class=sy1>=</span> MAX<span class=br0>(</span>xmin, ymin<span class=br0>)</span><span class=sy4>;</span>
    max <span class=sy1>=</span> MIN<span class=br0>(</span>xmax, ymax<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine bounds for z</span>
    <span class=kw4>float</span> zmin <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>z</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>z</span><span class=sy4>;</span>
    <span class=kw4>float</span> zmax <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>z</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>z</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// If the z bounds don't overlap with the existing region, the ray doesn't intercept</span>
    <span class=kw1>if</span> <span class=br0>(</span>zmin <span class=sy1>&gt;</span> max <span class=sy3>||</span> min <span class=sy1>&gt;</span> zmax<span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Update the bounds to find the region where x, y, and z overlap</span>
    min <span class=sy1>=</span> MAX<span class=br0>(</span>min, zmin<span class=br0>)</span><span class=sy4>;</span>
    max <span class=sy1>=</span> MIN<span class=br0>(</span>max, zmax<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region overlaps with the bounds provided</span>
    <span class=kw1>return</span> <span class=br0>(</span>min <span class=sy1>&lt;</span> rmax<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> rmin<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
<span class=br0>}</span></pre></div></div><p>Once I had a starting point, it was possible to start thinking about how the code could be
vectorized.
Intel's <a rel=nofollow class="external text" href=https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/optimization-and-programming-guide/vectorization/automatic-vectorization/programming-guidelines-for-vectorization.html>official
guide</a> was a useful starting point when reasoning about what autovectorizer-friendly code
looks like.</p><p>A more SIMD-optimal version might look something like this:</p><p>(Assignments that are grouped together are those that I think will be vectorized, e.g. all mins will
be calculated as a group)</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span> intersects<span class=br0>(</span>BBox box, Ray ray, <span class=kw4>float</span> rmin, <span class=kw4>float</span> rmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=co1>// Determine minimum bounds for x, y, and z</span>
    <span class=kw4>float</span> xmin <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>x</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymin <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>y</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>y</span><span class=sy4>;</span>
    <span class=kw4>float</span> zmin <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>z</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>z</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine maximum bounds for x, y, and z</span>
    <span class=kw4>float</span> xmax <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>x</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymax <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>y</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>y</span><span class=sy4>;</span>
    <span class=kw4>float</span> zmax <span class=sy1>=</span> <span class=br0>(</span>box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span> <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>z</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>z</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the minimum bounds of the region where x, y, and z overlap</span>
    min <span class=sy1>=</span> MAX<span class=br0>(</span>xmin, ymin, zmin<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the maximum bounds of the region where x, y, and z overlap</span>
    max <span class=sy1>=</span> MIN<span class=br0>(</span>xmax, ymax, zmax<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region exists and overlaps with the bounds provided</span>
    <span class=kw1>return</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> min<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>min <span class=sy1>&lt;</span> rmax<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> rmin<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
<span class=br0>}</span></pre></div></div><p>Notice how we lose our early-exits: this function is now branch-free, for better or worse.
This enables wider SIMD operations (finding all three mins at once rather than finding z
separately),
but it may mean that this has worse best-case performance.</p><p>The compiler may pad the vector values so that they contain four elements rather than three.
If it's smart enough, this can enable the use of <a rel=nofollow class="external text" href=https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions/intrinsics-to-determine-minimum-and-maximum-values.html>appropriate
instructions</a> to rapidly find the min and max values.</p><p>This code still finds the min and max values separately, but the
compiler likely splits things up more to enable even wider SIMD
operations.
The following code might compile to exactly the same thing; because it's
only a change to the order of operations, the compiler should be smart
enough to make this optimization automatically:</p><p>(In this code I also explicitly acknowledge the padding values I might expect the vectorizer to add)</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span> intersects<span class=br0>(</span>BBox box, Ray ray, <span class=kw4>float</span> rmin, <span class=kw4>float</span> rmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=co1>// Determine intermediate value for minimum bounds</span>
    <span class=kw4>float</span> xmin <span class=sy1>=</span> box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymin <span class=sy1>=</span> box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=sy4>;</span>
    <span class=kw4>float</span> zmin <span class=sy1>=</span> box.<span class=me1>bounds</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=sy4>;</span>
    <span class=coMULTI>/* pad_min = FLOAT_MAX; */</span>
&nbsp;
    <span class=co1>// Determine intermediate value for maximum bounds</span>
    <span class=kw4>float</span> xmax <span class=sy1>=</span> box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymax <span class=sy1>=</span> box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=sy4>;</span>
    <span class=kw4>float</span> zmax <span class=sy1>=</span> box.<span class=me1>bounds</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=sy4>;</span>
    <span class=coMULTI>/* pad_max = FLOAT_MIN; */</span>
&nbsp;
    <span class=co1>// Apply transform to all bounds</span>
    <span class=kw4>float</span> xmin <span class=sy1>=</span> <span class=br0>(</span>xmin <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>x</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>x</span><span class=sy4>;</span>
    <span class=kw4>float</span> ymin <span class=sy1>=</span> <span class=br0>(</span>ymin <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>y</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>y</span><span class=sy4>;</span>
    <span class=kw4>float</span> zmin <span class=sy1>=</span> <span class=br0>(</span>zmin <span class=sy2>-</span> r.<span class=me1>origin</span>.<span class=me1>z</span><span class=br0>)</span> <span class=sy2>*</span> r.<span class=me1>inv_direction</span>.<span class=me1>z</span><span class=sy4>;</span>
    <span class=coMULTI>/* pad_min = (pading - 0.0)      * 1.0; /*
    float xmax = (zmax - r.origin.x) * r.inv_direction.x;
    float ymax = (ymax - r.origin.y) * r.inv_direction.y;
    float zmax = (zmax - r.origin.z) * r.inv_direction.z;
    /* pad_max = (pading - 0.0)      * 1.0; /*
&nbsp;
    // Determine the minimum bounds of the region where x, y, and z overlap
    min = MAX(xmin, ymin, zmin /*, pad_min */</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the maximum bounds of the region where x, y, and z overlap</span>
    max <span class=sy1>=</span> MIN<span class=br0>(</span>xmax, ymax, zmax <span class=coMULTI>/*, pad_max */</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region exists and overlaps with the bounds provided</span>
    <span class=kw1>return</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> min<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>min <span class=sy1>&lt;</span> rmax<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> rmin<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
<span class=br0>}</span></pre></div></div><p>This arrangement is mathematically equivalent, and the compiler may
choose to do something like this if it determines that it results in
better performance (though I'm not certain that's the case!).</p><p>Note: These comments are primarily speculative, based on my understanding of intel's documentation.</p><h3><span class=mw-headline id=Choosing_a_SIMD_Approach><span class=mw-headline-number>4.2.2</span> Choosing a SIMD Approach</span></h3><p>Note: ISPC is discussed in <a rel=nofollow class="external text" href=https://pharr.org/matt/blog/2018/04/30/ispc-all>this fantastic
blog</a></p><table class=wikitable><caption>SIMD Approaches in order of Explicitness</caption><tbody><tr><th>Most Readable</th></tr><tr><td>Compiler autovectorization</td></tr><tr><td>OpenMP (<code>#pragma omp simd</code>)</td></tr><tr><td>High level libraries (e.g. Eigen)</td></tr><tr><td>Low level libraries (wrappers over intrinsics)</td></tr><tr><td>SIMD intrinsics</td></tr><tr><td>Embedded assembly</td></tr><tr><th>Most Explicit</th></tr></tbody></table><table class=wikitable><caption>Advantages and Disadvantages of Different SIMD Approaches</caption><tbody><tr><th>Approach</th><th>Pros</th><th>Cons</th></tr><tr><td>Compiler autovectorization</td><td><ul><li>Doesn't require additional semantics, meaning that readability of code may be less
impacted</li><li>No libraries or additional dependencies needed</li><li>Compiler may find opportunities for optimization that would otherwise go undetected</li></ul></td><td><ul><li>Results in "invisible compiler magic": code that is arranged in a specific way for
no clear reason</li><li>Different optimizations will be found by different compilers, meaning performance
might be less consistent between users</li></ul></td></tr><tr><td>OpenMP (<code>#pragma omp simd</code>)</td><td><ul><li>Greater level of control, more confidence that SIMD will actually be used where we
think it's important</li><li>Adds clarity where SIMD techniques are being used (unlikely to be removed
accidentally during refactoring)</li></ul></td><td><ul><li>Only applicable a limited number of constructs (e.g. for loops)</li><li>Adding a #pragma doesn't always result in additional vectorization (the compiler
already does pretty well without hints)</li></ul></td></tr><tr><td>High level libraries (e.g. Eigen)</td><td><ul><li>Already thoroughly optimized to make good use of SIMD</li></ul></td><td><ul><li>Probably not usable within CGAL</li></ul></td></tr><tr><td>Low level libraries (wrappers over intrinsics)</td><td><ul><li>Very high level of control over how and when SIMD is applied</li><li>Where library constructs are used, there is a strong guarantee that SIMD
instructions will actually be emitted</li><li>Allow for refactoring with full confidence: as long as no library
constructs are removed, the code can be transformed radically without
reducing the use of SIMD</li></ul></td><td><ul><li>Puts a lot of responsibility on the engineer; it only makes sense
to work this low-level if we know we can write better SIMD code than the
compiler!</li><li>By writing explicit SIMD code, we risk cutting off implicit avenues of optimization
for the compiler.</li><li>Only gives access to "lowest common denominator" SIMD instructions,
some niche instructions only available on certain architectures might
be useful, but won't be available</li></ul></td></tr><tr><td>SIMD intrinsics</td><td><ul><li>Even higher level of control over how and when SIMD is applied</li><li>Allows us to use niche intrinsics which are useful for our situation</li></ul></td><td><ul><li>Requires careful handling for cross-platform support</li><li>Puts even more responsibility on the engineer; it only makes sense
to work this low-level if we know we can write better SIMD code than the
compiler!</li><li>By writing explicit SIMD code, we risk cutting off implicit avenues of optimization
for the compiler</li></ul></td></tr><tr><td>Embedded assembly</td><td><ul><li>Highest possible level of control over how and when SIMD is applied</li><li>Allows us to use niche intrinsics which are useful for our situation</li></ul></td><td><ul><li>Requires careful handling for cross-platform support</li><li>Puts all responsibility on the engineer; it only makes sense to
work this low-level if we know we can write better SIMD code than the
compiler!</li><li>By saying exactly what assembly we want emitted, we cut off all avenues of
optimization by the compiler</li></ul></td></tr></tbody></table><h4><span class=mw-headline id=Libraries><span class=mw-headline-number>4.2.2.1</span> Libraries</span></h4><table class=wikitable><tbody><tr><th>Library</th><th>License</th><th>Notes</th></tr><tr><td><s><a rel=nofollow class="external text" href=https://github.com/agenium-scale/boost.simd>Boost.SIMD</a></s></td><td>Closed</td><td>Originally planned for inclusion in Boost, sadly that was cancelled and the library was
made closed source.</td></tr><tr><td><a rel=nofollow class="external text" href=https://github.com/agenium-scale/nsimd>nsimd</a></td><td>MIT</td><td>Fork of Boost.SIMD</td></tr><tr><td><a rel=nofollow class="external text" href=https://github.com/xtensor-stack/xsimd>xsimd</a></td><td>BSD 3-clause</td><td>Reimplementation of Boost.SIMD's API</td></tr><tr><td><a rel=nofollow class="external text" href=https://www.agner.org/optimize/vectorclass.pdf>Vectorclass</a></td><td>GPLv3</td><td>Library by Agner Fog</td></tr><tr><td><a rel=nofollow class="external text" href=https://github.com/p12tic/libsimdpp>libsimdpp</a></td><td>Boost</td><td>Provides Dynamic Dispatch</td></tr><tr><td><a rel=nofollow class="external text" href=https://github.com/VcDevel/std-simd>std-simd</a></td><td>BSD 3-clause</td><td><code>std::experimental::simd</code>, might someday be included in libstdc++!</td></tr><tr><td><a rel=nofollow class="external text" href=https://github.com/google/dimsum>dimsum</a></td><td>Apache 2.0</td><td>Google's own implementation of the same standard simd proposal.</td></tr><tr><td><a rel=nofollow class="external text" href=https://github.com/simd-everywhere/simde>SIMD
Everywhere</a></td><td>MIT</td><td>Enables the use of any flavor of intrinsics, on any platform (automatically substitutes
unsupported intrinsics)</td></tr></tbody></table><table class=wikitable><caption>Advantages and Disadvantages of Different SIMD Libraries</caption><tbody><tr><th>Library</th><th>Pros</th><th>Cons</th></tr><tr><td>nsimd</td><td><ul><li>Boost-style API</li><li>Vector length agnostic</li><li>Adds support for SPMD (shader-style) programming</li><li>Compatible with all major instruction sets</li></ul></td><td><ul><li>Low visible activity, most recent PR merged 3 months ago</li><li>Not especially well documented</li></ul></td></tr><tr><td>xsimd</td><td><ul><li>Boost-style API</li><li>Compatible with all major instruction sets</li><li>Very active (last PR merged 1 hour ago)</li><li>Well documented, including a <a rel=nofollow class="external text" href=https://xsimd.readthedocs.io/en/latest/>doxygen</a>
manual</li></ul></td><td><ul><li>Doesn't automatically fallback to multiple smaller instructions when vector size is
too large for the platform</li></ul></td></tr><tr><td>Vectorclass</td><td><ul><li>Stable, library has been around nearly as long as SIMD itself</li><li>Very well documented, including a guide with examples</li><li>Compatible with all major instruction sets</li><li>Relatively active (last changed 15 days ago)</li></ul></td><td><ul><li>Documentation is in the form of a PDF</li><li>Primarily developed by one person only</li><li>Doesn't have a well-defined VCS workflow</li></ul></td></tr><tr><td>libsimdcpp</td><td><ul><li>Compatible with all major instruction sets, as well as some niche ones</li><li>Has support for dynamic dispatch</li></ul></td><td><ul><li>Not vector length agnostic</li><li>Little recent activity, most recent PR merged nearly 2 years ago</li></ul></td></tr><tr><td>std-simd</td><td><ul><li>Targeted for inclusion in the standard template library</li><li>Somewhat documented; already has a page on <a rel=nofollow class="external text" href=https://en.cppreference.com/w/cpp/experimental/simd>ccpreference.com</a></li><li>Because the API is an ISO standard, stability is guaranteed and
experience is transferable to other libraries which implement the
standard</li><li>Compatible with all major instruction sets</li><li>Vector length agnostic</li></ul></td><td><ul><li>Low visible activity, most recent PR merged 4 months ago</li><li>Documentation is incomplete: there are no examples, and many functions are left
undocumented</li></ul></td></tr><tr><td>dimsum</td><td><ul><li>Alternate implementation of the std-simd API</li><li>Developed at Google</li><li>Vector length agnostic</li></ul></td><td><ul><li>Not a complete implementation (missing certain features)</li><li>Currently only supports certain instruction sets</li></ul></td></tr><tr><td>SIMD Everywhere</td><td><ul><li>Different from other libraries: rather than providing a layer over
SIMD intrinsics for different instruction sets, enables use of
intrinsics for any platform on any other platform.</li><li>Compatible with Marc Glisse's existing (intrinsic-based) work, and
may even allow removing the macros used for checking platform
compatibility!</li><li>Allows access to more "niche" intrinsics, which are replaced with equivalent code
on unsupported platforms</li><li>Very active (last PR merged 10 hours ago)</li></ul></td><td><ul><li>Requires direct use of intrinsics, foregoing the more ergonomic API provided by
other libraries</li></ul></td></tr></tbody></table><p>In my opinion, the list can be reduced to the following libraries, each with their own advantages:</p><ul><li>xsimd: the most actively developed</li><li>libsimdcpp: might be the only library with macros to help with dynamic dispatch</li><li>std-simd: the API is an ISO standard, and this may be included in a future version of C++</li><li>SIMD everywhere: very different from the rest, can add
cross-platform support so Marc Glisse's existing code (but provides no
convenience layer over intrinsics)</li></ul><h3><span class=mw-headline id=Automated_SIMD_Prevalence_Analysis><span class=mw-headline-number>4.2.3</span> Automated SIMD Prevalence Analysis</span></h3><p>The earlier process of determining how many SIMD instructions were present in a binary file was
relatively time-consuming.
Because this is something I expect to do frequently in the course of the project, I decided to
automate it.
I created a simple bash script which counts the instructions as I did manually,
and also calculates their percents to produce a table like the one shown earlier.</p><p>This work is available on a <a rel=nofollow class="external text" href=https://github.com/JacksonCampolattaro/simd-experiments>new
repository</a>, which I intend to use for future such experimentation.</p><h2><span class=mw-headline id=June_2_-_June_7><span class=mw-headline-number>4.3</span> June 2 - June 7</span></h2><h3><span class=mw-headline id=Ray-BBox_Intersection_Codes><span class=mw-headline-number>4.3.1</span> Ray-BBox Intersection Codes</span></h3><p>In order to see how different compiler flags, optimizations, and SIMD
libraries effect the produced binary and its performance I'm using a
minimal test case.
I assembled a collection of ray-bbox intersection tests for spartan
implementations of Vector3, BBox, and Ray types.
These are inspired by the paper discussed earlier, with various
modifications added.</p><table class=wikitable><caption>Ray-BBox Intersection Implementations</caption><tbody><tr><th>Name</th><th>Code</th><th>Description</th></tr><tr><td>Smits' Method</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span> intersect_smits_method<span class=br0>(</span><span class=kw4>const</span> BBox <span class=sy3>&amp;</span>bbox, <span class=kw4>const</span> Ray <span class=sy3>&amp;</span>ray, <span class=kw4>float</span> t0, <span class=kw4>float</span> t1<span class=br0>)</span> <span class=br0>{</span>
    <span class=kw4>double</span> tmin, tmax, tymin, tymax, tzmin, tzmax<span class=sy4>;</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span>ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=br0>)</span> <span class=br0>{</span>
        tmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
        tmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span> <span class=kw1>else</span> <span class=br0>{</span>
        tmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
        tmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span>ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=br0>)</span> <span class=br0>{</span>
        tymin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
        tymax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span> <span class=kw1>else</span> <span class=br0>{</span>
        tymin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
        tymax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span><span class=br0>(</span>tmin <span class=sy1>&gt;</span> tymax<span class=br0>)</span> <span class=sy3>||</span> <span class=br0>(</span>tymin <span class=sy1>&gt;</span> tmax<span class=br0>)</span><span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tymin <span class=sy1>&gt;</span> tmin<span class=br0>)</span> tmin <span class=sy1>=</span> tymin<span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tymax <span class=sy1>&lt;</span> tmax<span class=br0>)</span> tmax <span class=sy1>=</span> tymax<span class=sy4>;</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span>ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=br0>)</span> <span class=br0>{</span>
        tzmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
        tzmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span> <span class=kw1>else</span> <span class=br0>{</span>
        tzmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
        tzmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>/</span> ray.<span class=me1>direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span><span class=br0>(</span>tmin <span class=sy1>&gt;</span> tzmax<span class=br0>)</span> <span class=sy3>||</span> <span class=br0>(</span>tzmin <span class=sy1>&gt;</span> tmax<span class=br0>)</span><span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tzmin <span class=sy1>&gt;</span> tmin<span class=br0>)</span> tmin <span class=sy1>=</span> tzmin<span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tzmax <span class=sy1>&lt;</span> tmax<span class=br0>)</span> tmax <span class=sy1>=</span> tzmax<span class=sy4>;</span>
&nbsp;
    <span class=kw1>return</span> <span class=br0>(</span>tmin <span class=sy1>&lt;</span> t1<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>tmax <span class=sy1>&gt;</span> t0<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><p>Included for completion's sake, this is a relatively naive approach discussed in the
paper.
The ray's inverse direction and sign are not pre-computed, so this should be expected to
under-perform all other methods.</p></td></tr><tr><td>Improved</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span> intersect_improved<span class=br0>(</span><span class=kw4>const</span> BBox <span class=sy3>&amp;</span>bbox, <span class=kw4>const</span> Ray <span class=sy3>&amp;</span>ray, <span class=kw4>float</span> t0, <span class=kw4>float</span> t1<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=kw4>double</span> tmin, tmax, tymin, tymax, tzmin, tzmax<span class=sy4>;</span>
&nbsp;
    tmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    tmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    tymin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    tymax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span><span class=br0>(</span>tmin <span class=sy1>&gt;</span> tymax<span class=br0>)</span> <span class=sy3>||</span> <span class=br0>(</span>tymin <span class=sy1>&gt;</span> tmax<span class=br0>)</span><span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tymin <span class=sy1>&gt;</span> tmin<span class=br0>)</span> tmin <span class=sy1>=</span> tymin<span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tymax <span class=sy1>&lt;</span> tmax<span class=br0>)</span> tmax <span class=sy1>=</span> tymax<span class=sy4>;</span>
&nbsp;
    tzmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    tzmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span><span class=br0>(</span>tmin <span class=sy1>&gt;</span> tzmax<span class=br0>)</span> <span class=sy3>||</span> <span class=br0>(</span>tzmin <span class=sy1>&gt;</span> tmax<span class=br0>)</span><span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tzmin <span class=sy1>&gt;</span> tmin<span class=br0>)</span> tmin <span class=sy1>=</span> tzmin<span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>tzmax <span class=sy1>&lt;</span> tmax<span class=br0>)</span> tmax <span class=sy1>=</span> tzmax<span class=sy4>;</span>
&nbsp;
    <span class=kw1>return</span> <span class=br0>(</span>tmin <span class=sy1>&lt;</span> t1<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>tmax <span class=sy1>&gt;</span> t0<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
<span class=br0>}</span></pre></div></div></td><td><p>This is the modified version of smits' method proposed by the paper, which uses the
pre-computed values for better performance.
This approach will serve as the overall baseline.</p></td></tr><tr><td>Clarified</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span> intersect_clarified<span class=br0>(</span><span class=kw4>const</span> BBox <span class=sy3>&amp;</span>bbox, <span class=kw4>const</span> Ray <span class=sy3>&amp;</span>ray, <span class=kw4>float</span> rmin, <span class=kw4>float</span> rmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=co1>// Determine bounds for x and y</span>
    <span class=kw4>double</span> xmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> xmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=kw4>double</span> ymin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> ymax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// If the x and y bounds don't overlap, the ray doesn't intersect with the box</span>
    <span class=kw1>if</span> <span class=br0>(</span>xmin <span class=sy1>&gt;</span> ymax <span class=sy3>||</span> ymin <span class=sy1>&gt;</span> xmax<span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the bounds of the overlapping region</span>
    <span class=kw4>double</span> min <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>xmin, ymin<span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> max <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>xmax, ymax<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine bounds for z</span>
    <span class=kw4>double</span> zmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> zmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// If the z bounds don't overlap with the existing region, the ray doesn't intercept</span>
    <span class=kw1>if</span> <span class=br0>(</span>min <span class=sy1>&gt;</span> zmax <span class=sy3>||</span> zmin <span class=sy1>&gt;</span> max<span class=br0>)</span> <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Update the bounds to find the region where x, y, and z overlap</span>
    min <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>min, zmin<span class=br0>)</span><span class=sy4>;</span>
    max <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>max, zmax<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region overlaps with the bounds provided</span>
    <span class=kw1>return</span> <span class=br0>(</span>min <span class=sy1>&lt;</span> rmax<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> rmin<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><p>This is my own interpretation of the paper's approach, modified for clarity.
I expect the use of semantic constructs like <code>std::max</code> to have no affect on
performance,
with identical binary being emitted by the compiler.</p></td></tr><tr><td>Branchless</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span> intersect_branchless<span class=br0>(</span><span class=kw4>const</span> BBox <span class=sy3>&amp;</span>bbox, <span class=kw4>const</span> Ray <span class=sy3>&amp;</span>ray, <span class=kw4>float</span> rmin, <span class=kw4>float</span> rmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=co1>// Determine bounds x, y, and z</span>
    <span class=kw4>double</span> xmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> xmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>0</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>x</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> ymin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> ymax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>y</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> zmin <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> zmax <span class=sy1>=</span> <span class=br0>(</span>bbox.<span class=me1>bounds</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> ray.<span class=me1>sign</span><span class=br0>(</span><span class=br0>)</span><span class=br0>[</span><span class=nu0>2</span><span class=br0>]</span><span class=br0>]</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span> <span class=sy2>-</span> ray.<span class=me1>origin</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>*</span> ray.<span class=me1>inv_direction</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>z</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the bounds of the overlapping region</span>
    <span class=kw4>double</span> min <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span><span class=br0>{</span>xmin, ymin, zmin<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw4>double</span> max <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span><span class=br0>{</span>xmax, ymax, zmax<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region overlaps with the interval provided</span>
    <span class=kw1>return</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> min<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>min <span class=sy1>&lt;</span> rmax<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=br0>(</span>max <span class=sy1>&gt;</span> rmin<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><p>This is the first major modification aiming to improve SIMD performance.
Removing the conditionals gives us straight-line code, but eliminates opportunities for
early exits.
This code should be more readily auto-vectorized by the compiler,
but only benchmarks can tell whether that advantage is enough to overcome the lack of
early exits in real-world scenarios.</p></td></tr></tbody></table><p>As I add more implementations, they will be added to this table.</p><h3><span class=mw-headline id=SIMD_Prevalence_for_Different_Implementations><span class=mw-headline-number>4.3.2</span> SIMD Prevalence for Different Implementations</span></h3><p>For analysis, the prevalence test was restricted to only the relevant function
(otherwise the testing framework and its use of the standard library can overwhelm the relevant
statistics).</p><p>This proved to be the right choice: for example the smits' method
program contained 1,957 instructions, but only 67 of those make up the
intersection function itself!</p><h4><span class=mw-headline id=Smits.27_Method><span class=mw-headline-number>4.3.2.1</span> Smits' Method</span></h4><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>67</td><td>100.00</td></tr><tr><td>SSE</td><td>1</td><td>1.49</td></tr><tr><td>SSE (Packed)</td><td>1</td><td>1.49</td></tr><tr><td>SSE2</td><td>32</td><td>47.76</td></tr><tr><td>SSE2 (Packed)</td><td>5</td><td>7.46</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>0</td><td>0</td></tr></tbody></table><p>This already contains a lot of SIMD instructions, but none above SSE2.
Note that non-packed SIMD instructions operate on single values, and not on the entire SSE register.
This means that they don't actually introduce parallelism to the code in the way packed instructions
do.</p><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3 -march=native</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>65</td><td>100.00</td></tr><tr><td>SSE</td><td>0</td><td>0</td></tr><tr><td>SSE (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE2</td><td>0</td><td>0</td></tr><tr><td>SSE2 (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>7</td><td>10.76</td></tr></tbody></table><p>Once the compiler is allowed to use newer instructions, it replaces all the SSE and SSE2 instructions
with AVX.
Though this looks like lower use of SIMD, only 6 of the SSE instructions were packed, while all 7
AVX instructions are packed.
The non-packed SSE instructions are only relevant when data is placed in SSE registers.
With AVX the same tasks are accomplished with conventional instructions.</p><p>Note that in general, it wouldn't be unreasonable to see fewer total SIMD instructions when AVX is
enabled.
Because modern AVX instructions can operate on larger sets of values at a time,
they should be able to accomplish the same tasks using fewer instructions.</p><h4><span class=mw-headline id=Improved><span class=mw-headline-number>4.3.2.2</span> Improved</span></h4><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>71</td><td>100.00</td></tr><tr><td>SSE</td><td>1</td><td>1.40</td></tr><tr><td>SSE (Packed)</td><td>1</td><td>1.40</td></tr><tr><td>SSE2</td><td>26</td><td>36.61</td></tr><tr><td>SSE2 (Packed)</td><td>2</td><td>2.81</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>0</td><td>0</td></tr></tbody></table><p>The improved version actually contains more instructions, despite its use of precomputed values.
It also contains fewer packed SIMD instructions, perhaps due to additional logic precluding their
use in certain cases.</p><p>When analyzing these results, it's important to be aware of two things:</p><ul><li>The improved version accounts for an edge case not caught by the original.</li><li>More instructions does not always mean slower code (not all instructions are created equal).</li></ul><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3 -march=native</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>69</td><td>100.00</td></tr><tr><td>SSE</td><td>0</td><td>0</td></tr><tr><td>SSE (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE2</td><td>0</td><td>0</td></tr><tr><td>SSE2 (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>12</td><td>17.39</td></tr></tbody></table><p>Enabling AVX seems to help the improved version.
Though it still has more instructions than the original, more of those instructions are SIMD.</p><p>Benchmarks will tell what effect this has on performance.</p><h4><span class=mw-headline id=Clarified><span class=mw-headline-number>4.3.2.3</span> Clarified</span></h4><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>67</td><td>100.00</td></tr><tr><td>SSE</td><td>1</td><td>1.49</td></tr><tr><td>SSE (Packed)</td><td>1</td><td>1.49</td></tr><tr><td>SSE2</td><td>24</td><td>35.82</td></tr><tr><td>SSE2 (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>0</td><td>0</td></tr></tbody></table><p>This result is actually unexpected: my version of the improved
algorithm was tweaked for readability, and I expected it to result in
identical assembly being emitted.
The new code compiles to fewer instructions, but also makes less use of
SIMD.
In order to see where the differences lie, I'll need take a closer look
at the assembly.
My first guess is that it comes from the additional variables, or my use
of <code>std::max</code> and <code>std::min</code>.</p><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3 -march=native</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>69</td><td>100.00</td></tr><tr><td>SSE</td><td>0</td><td>0</td></tr><tr><td>SSE (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE2</td><td>0</td><td>0</td></tr><tr><td>SSE2 (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>12</td><td>17.39</td></tr></tbody></table><p>After AVX instructions, things look more how I expected.
The function appears to compiler to the same assembly as its more verbose predecessor.</p><p>What remains a mystery is why enabling AVX would cause this,
as I understand, the <code>-march=native</code> flag only makes new instructions available to the
compiler, it shouldn't add any new paths for optimization!</p><h4><span class=mw-headline id=Branchless><span class=mw-headline-number>4.3.2.4</span> Branchless</span></h4><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>64</td><td>100.00</td></tr><tr><td>SSE</td><td>1</td><td>1.56</td></tr><tr><td>SSE (Packed)</td><td>1</td><td>1.56</td></tr><tr><td>SSE2</td><td>21</td><td>32.81</td></tr><tr><td>SSE2 (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>0</td><td>0</td></tr></tbody></table><p>Similar to the clarified code, this function only contains a single packed SSE function when compiled
without <code>-march=native</code>!
The only meaningful change made was to remove the conditionals (none of the math was altered),
my hope was that that would unlock more optimizations by the autovectorizer, but clearly that's not
the case.
There are fewer total instructions, but that's to be expected as a result of the reduction in logic.</p><p>This doesn't necessarily mean that there's no advantage to the branch-free approach,
but any measured advantage would likely be due to reduced branch-mispredictions, and not because of
increased SIMD utilization.</p><table class=wikitable><caption>SIMD Instruction Prevalence (<code>-O3 -march=native</code>)</caption><tbody><tr><th>Instruction Set</th><th>Count</th><th>Percent</th></tr><tr><td>All</td><td>64</td><td>100.00</td></tr><tr><td>SSE</td><td>0</td><td>0</td></tr><tr><td>SSE (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE2</td><td>0</td><td>0</td></tr><tr><td>SSE2 (Packed)</td><td>0</td><td>0</td></tr><tr><td>SSE3</td><td>0</td><td>0</td></tr><tr><td>SSSE3</td><td>0</td><td>0</td></tr><tr><td>SSE4</td><td>0</td><td>0</td></tr><tr><td>AVX</td><td>12</td><td>18.75</td></tr></tbody></table><p>Based on the previous table, these results aren't surprising:
the branchless function compiles to very similar assembly vs. the other two equivalent functions,
minus some conditional logic!</p><h2><span class=mw-headline id=June_8_-_June_15><span class=mw-headline-number>4.4</span> June 8 - June 15</span></h2><h3><span class=mw-headline id=Collecting_Test_Data_for_Benchmarking><span class=mw-headline-number>4.4.1</span> Collecting Test Data for Benchmarking</span></h3><p>Andreas, Pierre, and I discussed the challenges of producing
realistic test data when evaluating the performance of an like the
intersection function.
They proposed extracting scenarios from the tetrahedral remeshing tests,
because it's an example of a real package which heavily uses the
AABB-tree to shoot rays.
This is actually relatively simple to do, by inserting a print statement
like the following in CGAL's ray-bbox intersection code:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw1>if</span> <span class=br0>(</span>std<span class=sy4>::</span><span class=me2>is_same</span><span class=sy1>&lt;</span>FT, <span class=kw4>double</span><span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>value</span><span class=br0>)</span>
  std<span class=sy4>::</span><span class=kw3>cout</span> <span class=sy1>&lt;&lt;</span> px <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> py <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> pz <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span>
            <span class=sy1>&lt;&lt;</span> qx <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> qy <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> qz <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span>
            <span class=sy1>&lt;&lt;</span> bxmin <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> bymin <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> bzmin <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span>
            <span class=sy1>&lt;&lt;</span> bxmax <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> bymax <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span> <span class=sy1>&lt;&lt;</span> bzmax <span class=sy1>&lt;&lt;</span> <span class=st0>" "</span>
            <span class=sy1>&lt;&lt;</span> <span class=st0>"<span class=es1>\n</span>"</span><span class=sy4>;</span></pre></div></div><p>(only double types are saved because those are relevant the benchmark)</p><p>This is an easy and effective way to capture the real ways that the function is used.
Running <code>test_mesh_and_remesh_polyhedral_domain_with_features.cpp</code> saved 3,742,217
examples, producing a 376.5&nbsp;MB text file!
The format isn't particularly pretty or readable, but it's usable enough for parsing back into my
simplified Ray and BBox types.</p><p><i><b>You may call <code>std::cout.precision(17)</code> in case that was not called earlier. <a href=https://cgal.geometryfactory.com/CGAL/Members/wiki/User:Afabri title=User:Afabri>Andreas
Fabri</a> 08:21, 10 June 2021 (CEST)</b></i></p><ul><li><i><b>Thanks for the advice, enabling full precision data produced a slightly different
intersection frequency! <a href=https://cgal.geometryfactory.com/CGAL/Members/wiki/User:Jackson_Campolattaro title="User:Jackson Campolattaro">Jackson Campolattaro</a></b></i></li></ul><h3><span class=mw-headline id=Initial_Benchmark_Results><span class=mw-headline-number>4.4.2</span> Initial Benchmark Results</span></h3><p>I created a simple benchmarking program with a function for timing lambda functions using <code>std::chrono</code>.
Because I'm running this on a laptop, it was important to ensure that
later tests wouldn't have a disadvantage because of rising CPU
temperatures.
To accomplish this, I interleaved the runs of different functions:
I time the process of calculating N scenarios using each implementation,
and repeat that R times, results are averaged.
I found that even N=3742217 (my entire dataset) could be processed in a
reasonable amount of time.
For reducing time variance, I set R=100; this gave me a total runtime
slightly over 30s.</p><p>(Unless otherwise indicated, times correspond to a single run through all scenarios)</p><table class=wikitable><caption>Time to Complete 3,742,217 Intersection Tests</caption><tbody><tr><th>Implementations</th><th><code>-O3</code></th><th><code>-O3 -march=native</code></th><th>Average</th></tr><tr><td>Smits' Method</td><td>5.12781e+07 ms</td><td>5.07237e+07 ms</td><td>5.10E+07 ms</td></tr><tr><td>Improved</td><td>4.50296e+07 ms</td><td>4.34125e+07 ms</td><td>4.42E+07 ms</td></tr><tr><td>Clarified</td><td>4.53892e+07 ms</td><td>4.30072e+07 ms</td><td>4.42E+07 ms</td></tr><tr><td>Branchless</td><td>4.74904e+07 ms</td><td>4.5071e+07 ms</td><td>4.63E+07 ms</td></tr><tr><td>Average</td><td>4.73E+07 ms</td><td>4.56E+07 ms</td><td>4.64E+07 ms</td></tr></tbody></table><p>The averages along the bottom are useful for seeing how compiler flags broadly affect performance,
while the averages on the right side are useful for an idea of how each implementation performs,
irrespective of flags.</p><p>These benchmark results tell us a few things:</p><ul><li><code>-march=native</code> confers a 3-5% improvement in performance (for this task).</li><li>The clarified code has similar performance to the (functionally equivalent) improved code,
despite its different assembly.</li><li>The branchless code slightly underperforms the improved and
clarified versions, indicating that the early exits that those provide
are worthwhile for real data. (The fact that this is so close means that
I could have easily gotten the wrong impression, had I used the wrong
type of synthetic data!)</li></ul><p>Based on lessons learned here, I intend to base future implementations off of the clarified version.</p><h3><span class=mw-headline id=Tweaks_to_Benchmarks><span class=mw-headline-number>4.4.3</span> Tweaks to Benchmarks</span></h3><p>During our Friday meeting, we discussed ways to open up more
opportunities for SIMD parallelism in the benchmarks.
One idea was to take into account the fact that each ray is tested
against many bounding boxes.
Previously our input data contained scenarios that matched one ray
against one box, I changed this so that each unique ray is paired with
the collection of boxes that it's tested against.
Putting the boxes in groups like this may make it possible to perform
vectorizations on a larger scale,
looking not just at the relationship between one ray and one box, but at
how one ray relates to a large set of boxes.</p><p>This doesn't map as closely to existing real-life use of the
intersection function (bounding boxes are not guaranteed to be adjacent
in memory),
but it does do a good job of reflecting an ideal scenario, which we
should strive towards in order to make the best use of SIMD.</p><table class=wikitable><caption>Time to Complete 3,742,217 Intersection Tests (Split into independent Queries)</caption><tbody><tr><th>Implementations</th><th><code>-O3</code></th><th><code>-O3 -march=native</code></th><th>Average</th></tr><tr><td>Smits' Method</td><td>4.96E+07 ms</td><td>5.06E+07 ms</td><td>5.01E+07 ms</td></tr><tr><td>Improved</td><td>2.85E+07 ms</td><td>2.62E+07 ms</td><td>2.73E+07 ms</td></tr><tr><td>Clarified</td><td>2.76E+07 ms</td><td>2.65E+07 ms</td><td>2.71E+07 ms</td></tr><tr><td>Branchless</td><td>3.28E+07 ms</td><td>3.28E+07 ms</td><td>3.28E+07 ms</td></tr><tr><td>Average</td><td>3.46E+07 ms</td><td>3.40E+07 ms</td><td>3.43E+07 ms</td></tr></tbody></table><p><br>This simple change produced a massive improvement in performance!
Accross the board, times are cut by more than 25%.
This is a rather spectacular difference, considering that no change was made to the functions
themselves.</p><h3><span class=mw-headline id=Intersection_using_XSimd><span class=mw-headline-number>4.4.4</span> Intersection using XSimd</span></h3><p>I added another intersection test that uses XSimd to implement the
branchless version with more explicit use of SIMD.
I chose XSimd because of its better usage semantics than std-simd, but I
was disappointed to find that its types don't generalize as nicely for
different platforms.
For example, the <code>xs::batch&lt;double, 4></code> type is only available when <code>-march=native</code>is
used, and only on systems that provide registers of that size
Unlike std-simd, no fallback is provided in other cases (the code will simply fail to compile).</p><p>The code works properly, but doesn't perform well.
For the standard benchmark, its time averages around 3.99e+07 ms;
better than the naive version, but worse than all the others.
It has the same number of AVX instructions as the auto-vectorized branchless version,
but it also has a lot more instructions in general.</p><p>It's certainly possible to beat the compiler by using a library like this,
but I get the impression that I don't (yet) have the skill to pull that off.</p><p>XSimd in particular seems poorly suited to this type of
fine-grained optimization (parallelism between the x, y, z values of a
vector, in this case).
I get the impression that it's designed for the other type of
vectorization (parallelism between multiple vectors).</p><p><b>NOTE: Future benchmarks will be compiled with <code>-march=native</code> unless otherwise
indicated, because XSimd only supports 4-way batches of doubles when they're supported in hardware.</b></p><h3><span class=mw-headline id=Switching_from_Line_Segments_to_Rays><span class=mw-headline-number>4.4.5</span> Switching from Line Segments to Rays</span></h3><p>The intersection methods I've been working with take bounds arguments <code>t0</code> and
<code>t1</code>, meaning that they are actually testing for intersections with line segments, and
not rays.
In all previous benchmarks, I used values of +/- infinity to generalize to infinite rays.
For future tests I've removed those bounds checks, meaning that the code is now specialized to
infinite rays.
Eliminating the logic came with a corresponding performance advantage.</p><p><br></p><table class=wikitable><caption>Time to Complete 3,742,217 Intersection Tests</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Smits' Method</td><td>4.3852e+07 ms</td></tr><tr><td>Improved</td><td>1.98313e+07 ms</td></tr><tr><td>Clarified</td><td>1.97305e+07 ms</td></tr><tr><td>Branchless</td><td>2.1348e+07 ms</td></tr><tr><td>XSimd</td><td>2.59743e+07 ms</td></tr></tbody></table><h3><span class=mw-headline id=Effects_of_inline><span class=mw-headline-number>4.4.6</span> Effects of <code>inline</code></span></h3><p>Marking a function inline can increase binary sizes, but it has the
benefit of putting each invocation of a function in context.
This is especially important for autovectorization, because it gives the
compiler the ability to recognize natural parallelism on a broader
scale.
Before, vectorization could only happen within the function, exploiting
the paralellism of the x, y, and z coordinates.
Puting the <code>inline</code> tag on the functions being tested lets the compiler make
optimizations that span across function calls,
this means that it can exploit the parallelism of the outer loop, using SIMD to check a ray against
multiple boxes at once.</p><p>I was disappointed by the speed of the branchless implementation
in earlier tests, but this is where its advantages shine through.
Early exits helped performance before, but -- critically -- they hinder
this type of higher-level vectorization.
When a function uses different instructions depending on the data its
applied to, it naturally can't be applied to batches of data.
The branchless version has no such issue, so more coarse-grained
optimizations can be applied.</p><table class=wikitable><caption>Time to Complete 3,742,217 Intersection Tests</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Smits' Method</td><td>4.36403e+07 ms</td></tr><tr><td>Improved</td><td>2.01639e+07 ms</td></tr><tr><td>Clarified</td><td>1.97437e+07 ms</td></tr><tr><td>Branchless</td><td>1.3715e+07 ms</td></tr><tr><td>XSimd</td><td>1.8891e+07 ms</td></tr></tbody></table><p>These results leave the question: is this representative of real world usage?</p><h2><span class=mw-headline id=June_16_-_June_22><span class=mw-headline-number>4.5</span> June 16 - June 22</span></h2><h3><span class=mw-headline id=Restructuring_Benchmarks><span class=mw-headline-number>4.5.1</span> Restructuring Benchmarks</span></h3><p>In preparation for creating a new data arrangement, I spent some time cleaning up the simd
experimentation code.
The main changes included:</p><ul><li>More narrowly defined responsibilities for the Vector3 and BBox classes.</li><li>Improved deserialization code for loading data from files (including istream operators for each
of the custom types).</li><li>Namespaces for each intersection implementation</li><li>Results are formatted as a WikiText-syntax table, so that I can paste directly into the wiki.</li></ul><h3><span class=mw-headline id=Validating_benchmarks_for_Correctness><span class=mw-headline-number>4.5.2</span> Validating benchmarks for Correctness</span></h3><p>My original approach for catching logic errors in the different
implementations was to watch the hit-rate of their intersection tests;
this was done by counting the intersections in each benchmark.
Unfortunately, this doesn't catch "symmetrical" errors, where a logic
mistake will result in the same number of spurious intersections as
missed ones.
To resolve this, I began saving results into an <code>std::vector&lt;bool></code>, to be compared
at the end of the benchmark.
I actually caught more than one mistake when I added this, but nothing that required additional
complexity to fix
(the mistakes didn't have performance implications).</p><h4><span class=mw-headline id=Performance_Implications><span class=mw-headline-number>4.5.2.1</span> Performance Implications</span></h4><p>Unfortunately, adding this validation logic does come with a cost.
Adding each result to the end of the <code>std::vector</code> consumes some time,
and ultimately this produces significantly slower benchmarks.</p><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Smits' Method</td><td>4.95657e+07 ms</td></tr><tr><td>Improved</td><td>3.43701e+07 ms</td></tr><tr><td>Clarified</td><td>3.43883e+07 ms</td></tr><tr><td>Branchless</td><td>3.36523e+07 ms</td></tr><tr><td>XSimd</td><td>4.16125e+07 ms</td></tr></tbody></table><p>Luckily because each benchmark is adding the same number of results to the array, the effect is
"flat".
The relative performance of the different methods is left unchanged, and so the same conclusions can
be reached.</p><h3><span class=mw-headline id=.22Struct-of-Arrays.22_BBox_type><span class=mw-headline-number>4.5.3</span> "Struct-of-Arrays" BBox type</span></h3><p>A <a rel=nofollow class="external text" href=https://software.intel.com/content/www/us/en/develop/articles/memory-layout-transformations.html>common
approach</a> to improve a program's use of SIMD
is to arrange the data in a "Struct-of-Arrays" rather than an "Array-of-Structs" format.
This means that data can be collected into SIMD registers using aligned load operations, rather than
a "gather".</p><p>For example, a collection of 8 (x, y, z) vectors stored in the AoS format would look like <code>...xyzxyzxyzxyzxyzxyzxyzxyz...</code>
in memory;
this makes it easy to load an entire vector at once, but not to load a group of x values as a batch.
On the other hand, the same data in SoA format would look more like <code>xxxxxxxx...yyyyyyyy...zzzzzzzz</code>.
This makes it easier to operate on groups of x values using simd
registers, but it has the downside that the data associated with a
specific vector is scattered.</p><p>I am optimistic that an SoA packing strategy could be used to improve performance on this benchmark,
but it's notably less straightforward to apply to CGAL than the AoS strategy already being used.
Arranging data in this way is an optimization that punctures the veil of many high-level
abstractions.</p><p>The use-case I've been exploring for the intersection function compares each ray to a large number of
bounding boxes.
Because of this, we should be able to apply an SoA philosophy to the boxes only, while keeping the
rays AoS.</p><h4><span class=mw-headline id=VBBox><span class=mw-headline-number>4.5.3.1</span> VBBox</span></h4><p>My "Vector-Bounding Box" type extends the <code>BBox&lt;T></code> type, where <code>T</code> is an
<code>std::vector</code>.</p><p>The <code>VBBox</code> has a constructor which takes a vector of
scalar bounding boxes and packs their underlying data into vectors.
The files containing test data are naturally in Array-of-Structs form,
so loading them directly into the new data structures would be awkward.
Instead, I created a function which produces SoA data from already
loaded SoA data.</p><p>It also adds an access method <code>getr(std::size_t i)</code> which retrieves a "cross-sectional
view" of the data structure.
This is another bounding box, where <code>T</code> is a <code>const T&</code>.
Because I'm using STL data structures to hold <code>T</code> inside my classes, I substituted <code>std::reference_wrapper&lt;const
T></code> for <code>const T&</code>.
With the help of this accessor, I can perform intersection tests on individual boxes in the <code>VBBox</code>
without any changes to the scalar intersection code.</p><h4><span class=mw-headline id=Benchmark_Results><span class=mw-headline-number>4.5.3.2</span> Benchmark Results</span></h4><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Explicit SIMD</td><td>4.53096e+07 ms</td></tr><tr><td>Implicit SIMD</td><td>4.74185e+07 ms</td></tr></tbody></table><p>The fact that the explicit version of the algorithm outperformed the implicit one surprised me.
Though the difference is small, it seems like by manually adding simd instructions
I found some avenues for optimization that the compiler could not.</p><p>Sadly, I was unimpressed with the performance of both AoS methods;
both perform worse than the SoA version, while using an equivalent branchless algorithm.
My suspicion is that the new arrangement in memory hurts cache performance,
which becomes relevant for a computationally-light task like intersection tests.</p><h4><span class=mw-headline id=Relevance_to_Real-life_use><span class=mw-headline-number>4.5.3.3</span> Relevance to Real-life use</span></h4><p>Could we use this strategy in CGAL?
Knowing that this approach underperforms perhaps makes this question less relevant, but it's still
worth looking at.</p><p>I believe this isn't actually an option,
in order to pack our bounding boxes, we would need to know the relevant
ones (the ones we'll be checking for intersections) beforehand.
This is easy for some applications (particularly brute force),
but to do this in the course of traversing a tree would be tantamount to
seeing the future.</p><h3><span class=mw-headline id=Caching_Broadcasted_Ray><span class=mw-headline-number>4.5.4</span> Caching Broadcasted Ray</span></h3><p>Because our intersection compares one ray to several boxes,
there are many places in the code where it's necessary to apply a scalar operation to many elements,
for example <code>[1.0, 2.0, 3.5, 2.0] * 4.0 = [4.0, 8.0, 14.0, 8.0]</code>.
In python/numpy terms, this type of elementwise math is known as a
"broadcasted" operation.
xsimd provides overloaded operators that make this easy to do, and
that's how I created the original explicit intersection function.</p><p>The catch, here, is that AVX, SSE, et al don't actually support broadcasted operations!
The CPU can only perform operations between simd registers.
As a result, any time we want to do a broadcast operation we also need to do a "broadcast load",
which puts the same value in each slot of the simd register.
This is repeated every time the intersection is invoked -- even if the ray is the same --
and the optimizer doesn't appear to notice the repeated loads.</p><p>We can fix this by performing the broadcast in the outer loop, and then using that cached result for
our intersections.
Whenever we start performing intersections with a new ray, we (manually) broadcast the ray's
parameters to xsimd registers.
These broadcasted values are used for all the relevant intersections.</p><h4><span class=mw-headline id=Benchmark_Results_2><span class=mw-headline-number>4.5.4.1</span> Benchmark Results</span></h4><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Explicit SIMD</td><td>4.35466e+07 ms</td></tr><tr><td>Implicit SIMD</td><td>4.61569e+07 ms</td></tr></tbody></table><p>This change appears to have produced a modest performance improvement vs performing the broadcast
each time.
The explicit code now outperforms the implicit code by a slightly larger margin.</p><h2><span class=mw-headline id=June_23_-_June_30><span class=mw-headline-number>4.6</span> June 23 - June 30</span></h2><h3><span class=mw-headline id=.22Array_of_Structs_of_Arrays.22_BBox><span class=mw-headline-number>4.6.1</span> "Array of Structs of Arrays" BBox</span></h3><p>In an "AoSoA" arrangement, the values are grouped together into batches, each batch the size of the
CPU's SIMD registers.
On a CPU with 4-way SIMD, data would be arranged like <code>...xxxxyyyyzzzzxxxxyyyyzzzzxxxxyyyyzzzz...</code>
in memory.</p><p>This strategy has several advantages:</p><ul><li>Data does not need to be loaded from scattered locations when filling a single SIMD register
(unlike the AoS strategy).</li><li>Data does not need to be loaded from faraway locations in memory
when loading relevant variables into different registers (unlike the SoA
strategy, where each x, y, z set can be very far away in memory).</li><li>This model actually lines up closely with the way some proposed
improvements to the AABB-tree would arrange the bounding boxes in
memory.</li></ul><p>It also comes with its own challenges:</p><ul><li>The number of items may not be aligned with the chosen batch size,
(e.g. 47 elements won't cleanly fit into a AoSoA data structure with
batch size 4). In this case, it's necessary to retain an additional AoS
data structure to hold the leftovers.</li></ul><p>So what does it look like to implement this for my own BBox type?
Because of my use of templates, the relevant data structure is almost as simple as a <code>std::vector&lt;BBox&lt;xsimd::batch&lt;double,
4>>></code> coupled with an <code>std::vector&lt;BBox&lt;double>></code>
to hold the leftovers.
Most of the challenges in implementation actually came from loading the
data structure during parsing, and I ended up creating a <code>XBBox</code>
type (which extends the BBox&lt;xsimd::batch&lt;>>>` type) to
help with conversion from scalar boxes.
Once the data was packed properly, it became simple to use intersection
methods I had previously written to process the structure (using
explicit or implicit SIMD).</p><h4><span class=mw-headline id=Benchmark_Results_3><span class=mw-headline-number>4.6.1.1</span> Benchmark Results</span></h4><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests (AoSoA Data)</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Explicit SIMD</td><td>3.61035e+07 ms</td></tr><tr><td>Implicit SIMD</td><td>3.50253e+07 ms</td></tr></tbody></table><p>Benchmarking shows that this strategy performs better than the SoA model, but doesn't quite beat the
original AoS approach.</p><h2><span class=mw-headline id=July_1_-_July_8><span class=mw-headline-number>4.7</span> July 1 - July 8</span></h2><h3><span class=mw-headline id=Performing_Benchmarks_on_Deepsat><span class=mw-headline-number>4.7.1</span> Performing Benchmarks on Deepsat</span></h3><p>Deepsat is a Xeon server that I and other members of the Inria TITANE
team share access to.
After arriving at the Inria campus, I decided to re-run my benchmarks on
the machine as a way to build familiarity with the workflow here.
Most of the server's advantages aren't relevant to my test case:
the 20 CPU cores don't benefit my single-threaded program,
and the 132Gb of ram aren't necessary for my 900Mb dataset.
What's important to me is the consistency the machine can provide.
Whereas my laptop is thermally limited, the server has the ability to
run benchmark after benchmark with no decrease to its performance!</p><p>I connected to Deepsat over SSH, and recompiled the solutions to
take full advantage of the modern Xeon CPU's instruction set.
Because my benchmarks contain their own timing and result-reporting
logic, producing the following tables was as simple as running each in
turn.</p><h4><span class=mw-headline id=Results><span class=mw-headline-number>4.7.1.1</span> Results</span></h4><div style=display:inline-table><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests on AoS Data</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Smits' Method</td><td>6.38517e+07 ms</td></tr><tr><td>Improved</td><td>3.70988e+07 ms</td></tr><tr><td>Clarified</td><td>3.65901e+07 ms</td></tr><tr><td>Branchless</td><td>3.68068e+07 ms</td></tr><tr><td>XSimd</td><td>4.14903e+07 ms</td></tr></tbody></table></div><div style=display:inline-table><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests on SoA Data</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Explicit SIMD</td><td>5.93713e+07 ms</td></tr><tr><td>Implicit SIMD</td><td>4.44437e+07 ms</td></tr></tbody></table></div><div style=display:inline-table><table class=wikitable><caption>Time to Complete 3742217 Intersection Tests on AoSoA Data</caption><tbody><tr><th>Implementation</th><th>Time</th></tr><tr><td>Explicit SIMD</td><td>3.96977e+07 ms</td></tr><tr><td>Implicit SIMD</td><td>3.93736e+07 ms</td></tr></tbody></table></div><p>Performance was slightly worse across the board, but this was
expected; Deepsat's Xeon CPU excels at embarrassingly parallel workloads
processing massive datasets, and this benchmark is neither of those
things.
Consumer hardware is optimized for single-core speed, and that's an
advantage for this type of work.</p><p>Despite its differences, this data leads us to the same conclusions as previous results.</p><h3><span class=mw-headline id=Experimenting_with_Application_of_OpenMP_Directives><span class=mw-headline-number>4.7.2</span> Experimenting with Application of OpenMP Directives</span></h3><p>One approach for SIMD that we haven't discussed so far is OpenMP.
This is because I've been having trouble getting interesting results from it.</p><p>Simply put, I've yet to run into a case where adding a <code>#pragma omp ...</code> tag resulted in
the compiler making any different choices.
Adding it to the benchmark code didn't affect performance, so to confirm my suspicions I created <a rel=nofollow class="external text" href=https://github.com/CGAL/cgal-public-dev/blob/gsoc2021-simd-campolattaro/_simd-experiments/openmp/main.cpp>a
simple program</a>
similar to <a rel=nofollow class="external text" href="https://www.ibm.com/docs/en/xl-c-and-cpp-linux/16.1.0?topic=parallelization-pragma-omp-declare-simd">IBM's
example</a> of how to apply OpenMP for SIMD.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=co1>// Naive function</span>
<span class=kw4>float</span> func_naive<span class=br0>(</span><span class=kw4>float</span> a, <span class=kw4>float</span> b<span class=br0>)</span> <span class=br0>{</span>
    <span class=kw1>return</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>a, b<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span>
&nbsp;
<span class=co1>// Openmp-vectorized function</span>
<span class=co2>#pragma omp declare simd</span>
<span class=kw4>float</span> func_openmp<span class=br0>(</span><span class=kw4>float</span> a, <span class=kw4>float</span> b<span class=br0>)</span> <span class=br0>{</span>
    <span class=kw1>return</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>a, b<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div><p>These implementations give us the following results:</p><pre>Naive: 0.677483s
Openmp:  0.554589s
</pre><p>The OpenMP tag does give us some improvement, but the difference is
marginal (and I haven't yet confirmed how much of that comes from not
interleaving the benchmarks).</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=co1>// Naive function</span>
<span class=kw2>inline</span> <span class=kw4>float</span> func_naive<span class=br0>(</span><span class=kw4>float</span> a, <span class=kw4>float</span> b<span class=br0>)</span> <span class=br0>{</span>
    <span class=kw1>return</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>a, b<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span>
&nbsp;
<span class=co1>// Openmp-vectorized function</span>
<span class=co2>#pragma omp declare simd</span>
<span class=kw2>inline</span> <span class=kw4>float</span> func_openmp<span class=br0>(</span><span class=kw4>float</span> a, <span class=kw4>float</span> b<span class=br0>)</span> <span class=br0>{</span>
    <span class=kw1>return</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>a, b<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div><pre>Naive: 0.730367
Openmp:  0.571762
</pre><p>Inlining both functions doesn't result in significant changes to
performance; they're small enough that they were likely already
effectively inlined by the compiler.</p><h3><span class=mw-headline id=Profiling_Mesh_3_remesh_polyhedral_surface_sm><span class=mw-headline-number>4.7.3</span> Profiling Mesh_3 <code>remesh_polyhedral_surface_sm</code></span></h3><p>On Andreas' suggestion, I will be using Mesh_3's <code>remesh_polyhedral_surface_sm</code> as a
representation of typical usage of the AABB-tree in future tests.</p><p>I started by using the profiling tool Perf to identify "hot
points" in the program.
This is important, because it helps us determine where our efforts are
best applied if we want to improve performance.
Up until now, I've been using ray-bbox intersection as a target for
optimization, under the assumption that because that operation is
necessary very often during traversal it must be important to
performance.
My hope is that a significant amount of time is spent on checking for
these intersections, because it means that my work up until now has the
potential to be more impactful.</p><p>Luckily, profiling results seemed to confirm this prediction:
348 of Perf's samples were during the Mesh refinement operation (most of the remaining were during
data-loading).
Of those, 155 were inside the ray-bbox intersection code (<code>CGAL::Intersections::internal::do_intersect_bbox_segment_aux</code>).
This
tells us that approximately 44.5% of the time performing the remeshing
operation is spent just on checking for intersections between rays and
bounding boxes, while traversing the tree!</p><h3><span class=mw-headline id=Branchless_do_intersect_bbox_segment_aux><span class=mw-headline-number>4.7.4</span> Branchless <code>do_intersect_bbox_segment_aux</code></span></h3><p>The ray-bbox intersection reference implementation has been a good
way of experimenting with different ideas and learning about SIMD
techniques, but continuing to optimize it encounters diminishing
returns.
It's begun to make sense to experiment with applying similar techniques
to real CGAL code.
With that in mind, I evaluated making CGAL's own ray-bbox intersection
code branchless.
This is a good first step because it's closely related to the work I've
done so far, and future optimizations like child-skipping can benefit
from such a change.</p><p>I started by creating <a rel=nofollow class="external text" href=https://github.com/JacksonCampolattaro/cgal/tree/branchless-ray-bbox-intersection>a
new branch on my own fork of CGAL</a>
dedicated to the branchless intersection change,
I'm planning to create branches dedicated to many tests like this one,
so it doesn't make sense to add all of these branches to cgal-public-dev
(instead I'll merge them into my branch there if they produce good
results).
Next, I <a rel=nofollow class="external text" href=https://github.com/JacksonCampolattaro/cgal/commit/e302b896adeb1782f6a8fedfaa17f19ee77e926a>annotated
the relevant function</a>
to build familiarity.
CGAL's intersection guarantees exactness, but doesn't lean on the
inherent exactness of the kernel.
Instead, it coerces the floating point type to double and does the
intersection math in double precision, but uses a custom class to keep
track of the possible accumulated error.
It uses that class to determine the margin it needs to be certain of its
result, and has a return type of <code>Uncertain&lt;bool></code>, so
that it can return an indeterminate result if the values fall within
the margin.
The result is an intersection function significantly more elaborate than
the ones I've been working with, totaling over 350 lines.</p><p>The existing function was not easily amenable to a branchless
structure.
I especially had trouble with the way it mixes conditional logic that's
based on template parameters, and logic based on arguments.
For example, in <code>if(bounded_1 && qx > bxmax) return false;</code>,
<code>bounded_1</code>
is a template parameter, so conditional logic which depends on it can
be evaluated as a constexpr (resulting in branchless assembly).
<code>qx > bxmax</code> does not have the same advantage, so for instantiations
<code>bounded_1</code>
is true this becomes an early exit.
This type of structuring makes perfect sense in context, but doesn't map
cleanly to a branchless alternative.
More challenging, a lot of the logic later in the code depends on the
guarantees provided by early exits.
This means that eliminating branches has to be done holistically, rather
than as a series of local transformations to the function's logic.</p><p>For a simpler test, I replaced the entire existing code with a simple version adapted from my
previous branchless code.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span>
        <span class=kw2>typename</span> FT,
        <span class=kw2>typename</span> BFT,
        <span class=kw4>bool</span> bounded_0,
        <span class=kw4>bool</span> bounded_1,
        <span class=kw4>bool</span> use_static_filters
<span class=sy1>&gt;</span>
<span class=kw2>inline</span> <span class=kw2>typename</span> Do_intersect_bbox_segment_aux_is_greater<span class=sy1>&lt;</span>
        FT,
        bounded_0,
        use_static_filters
<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>result_type</span>
do_intersect_bbox_segment_aux<span class=br0>(</span>
              <span class=kw4>const</span> FT <span class=sy3>&amp;</span>px, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>py, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>pz,
              <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qx, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qy, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qz,
              <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bxmin, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bymin, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bzmin,
              <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bxmax, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bymax, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bzmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
        <span class=kw4>const</span> BFT bx<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bxmin, bxmax<span class=br0>}</span><span class=sy4>;</span>
        <span class=kw4>const</span> BFT by<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bymin, bymax<span class=br0>}</span><span class=sy4>;</span>
        <span class=kw4>const</span> BFT bz<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bzmin, bzmax<span class=br0>}</span><span class=sy4>;</span>
&nbsp;
        <span class=kw4>const</span> <span class=kw4>int</span> sx <span class=sy1>=</span> qx <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
        <span class=kw4>const</span> <span class=kw4>int</span> sy <span class=sy1>=</span> qy <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
        <span class=kw4>const</span> <span class=kw4>int</span> sz <span class=sy1>=</span> qz <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
&nbsp;
        <span class=co1>// Determine bounds x, y, and z</span>
        FT xmin <span class=sy1>=</span> <span class=br0>(</span>bx<span class=br0>[</span>sx<span class=br0>]</span> <span class=sy2>-</span> px<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qx <span class=sy2>-</span> px<span class=br0>)</span><span class=sy4>;</span>
        FT xmax <span class=sy1>=</span> <span class=br0>(</span>bx<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sx<span class=br0>]</span> <span class=sy2>-</span> px<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qx <span class=sy2>-</span> px<span class=br0>)</span><span class=sy4>;</span>
        FT ymin <span class=sy1>=</span> <span class=br0>(</span>by<span class=br0>[</span>sy<span class=br0>]</span> <span class=sy2>-</span> py<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qy <span class=sy2>-</span> py<span class=br0>)</span><span class=sy4>;</span>
        FT ymax <span class=sy1>=</span> <span class=br0>(</span>by<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sy<span class=br0>]</span> <span class=sy2>-</span> py<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qy <span class=sy2>-</span> py<span class=br0>)</span><span class=sy4>;</span>
        FT zmin <span class=sy1>=</span> <span class=br0>(</span>bz<span class=br0>[</span>sz<span class=br0>]</span> <span class=sy2>-</span> pz<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qz <span class=sy2>-</span> pz<span class=br0>)</span><span class=sy4>;</span>
        FT zmax <span class=sy1>=</span> <span class=br0>(</span>bz<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sz<span class=br0>]</span> <span class=sy2>-</span> pz<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qz <span class=sy2>-</span> pz<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
        <span class=co1>// Determine the bounds of the overlapping region</span>
        FT min <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span><span class=br0>{</span>xmin, ymin, zmin<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
        FT max <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span><span class=br0>{</span>xmax, ymax, zmax<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
        <span class=co1>// The ray intercepts if this region overlaps with the interval provided</span>
        <span class=kw1>return</span> <span class=br0>(</span>max <span class=sy1>&gt;=</span> min<span class=br0>)</span> <span class=sy3>&amp;&amp;</span>            <span class=co1>// Check if there is any overlap at all</span>
               <span class=sy3>!</span><span class=br0>(</span>bounded_0 <span class=sy3>&amp;&amp;</span> max <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=co1>// Check if the overlap is outside the ray (before the start)</span>
               <span class=sy3>!</span><span class=br0>(</span>bounded_1 <span class=sy3>&amp;&amp;</span> min <span class=sy1>&gt;</span> <span class=nu0>1</span><span class=br0>)</span><span class=sy4>;</span>   <span class=co1>// Check if the overlap is outside the ray (after the end)</span>
<span class=br0>}</span></pre></div></div><p>I also added a simple parity check against the old method, when it's not uncertain.
This gives me some confidence in this code's correctness, though the dataset tested probably doesn't
hit every edge case.</p><p>This version uses the full precision types provided by the kernel, meaning that it will never return
an uncertain value.
This comes with a performance penalty (especially for the kernels with the strongest guarantees of
exactness),
but it massively simplifies the logic, and may improve performance in real tasks.
This is because in the old code, uncertain results were <a rel=nofollow class="external text" href=https://github.com/CGAL/cgal/blob/7a105b418d2ea78301fbe750bfb0db0f13111d23/Filtered_kernel/include/CGAL/internal/Static_filters/Do_intersect_3.h#L123>assumed
to be hits</a>,
resulting in looking at more nodes than strictly necessary.</p><p>Simple benchmarking was done using the <code>time</code> command on single runs of the compiled
program.
Using the old solution, I get performance that tends to look like:</p><pre>time ~/Documents/cgal-public-dev/Mesh_3/examples/Mesh_3/cmake-build-release/remesh_polyhedral_surface_sm

real    0m0.461s
user    0m0.453s
sys     0m0.006s

</pre><p>Once the optimization is applied, the program is much faster:</p><pre>time ~/Documents/cgal-public-dev/Mesh_3/examples/Mesh_3/cmake-build-release/remesh_polyhedral_surface_sm

real    0m0.181s
user    0m0.172s
sys     0m0.005s
</pre><p>The actual improvement is actually much larger than this might
suggest, my profiler indicates that the number of samples during
traversal went from 182 to just 18 (most of the time is spent
constructing the tree).
It's challenging to determine how much of this improvement comes from
the simpler, faster intersection function, and how much comes from the
reduction of spurious intersections.
In any case, the complexity of the kernel's exact floating point type
means that it's unlikely that this change actually meaningfully
increased the use of SIMD.</p><h3><span class=mw-headline id=Meeting_with_Adrien_Cassagne><span class=mw-headline-number>4.7.5</span> Meeting with Adrien Cassagne</span></h3><p>Adrien Cassagne is a researcher elsewhere at Inria with work that makes extensive use of SIMD.
Most relevant is <a rel=nofollow class="external text" href=https://dl.acm.org/doi/10.1145/3178433.3178435>his paper on MIPP</a>, a
custom SIMD wrapper library which he wrote as part of another line of research.
Pierre contacted Adrien, and was able to schedule a meeting for the 6th of July.
In preparation for our meeting, I prepared <a rel=nofollow class="external text" href="https://docs.google.com/presentation/d/1Tl9CtJhZNM4LSBjV_jwz3aBnVMmrMcdCMMWE13NZ4Aw/edit?usp=sharing">a
set of slides</a> to explain the problem statement.</p><p>Adrien's experience turned out to be relevant to our work, and he
made some salient points about our approach so far.
He said that wrapper libraries seemed like a good level of abstraction
for our needs, which is the same conclusion we came to.
He was surprised that our "AoS" and "AoSoA" implementations weren't
faster (especially given our high ratio of memory-heavy operations to
numerically intense ones),
and he offered to examine the test code to try and understand why it
would underperform.</p><p>Adrien agreed that SIMD was a worthwhile endeavor for CGAL, and
he expects to have extra free time until September, so he's interested
in arranging more meetings to help.</p><p>He also made several suggestions about how to best vectorize the
AABB-tree, though he noted that he's never vectorized a tree structure
like this before.
One that interested me was his mention of <a rel=nofollow class="external text" href=https://dl.acm.org/doi/abs/10.1145/2601097.2601222>stream
traversal</a>,
performing queries with groups of similar rays simultaneously. This is
something that Embree does, so it caught my attention that he
independently proposed the same optimization. Stream traversal would
mesh well with CGAL's existing abstractions (it could be as simple as
defining a new query type which bundles several ray queries), but the
catch is that it works best when the rays being cast are very similar.
In rendering this is as done by casting rays of adjacent pixels, but for
CGAL it's difficult to think of a relevant use-case. Do any of CGAL's
packages have a tendency to perform queries of similar rays?</p><h3><span class=mw-headline id=Branchless_BBox-BBox_Intersection><span class=mw-headline-number>4.7.6</span> Branchless BBox-BBox Intersection</span></h3><p>CGAL's BBox-BBox intersection function is significantly simpler than Ray-BBox intersection.
This is because bounding boxes are axis-aligned, so a pair of boxes intersect whenever their x, y,
and z bounds all intersect.
Because all of the comparisons are along axes there isn't any opportunity for accumulated error,
this means all the math can be done using the <code>double</code> type without any additional logic
needed to add margins.</p><p>As you'll see in the assembly, making the logic branchless isn't as simple as combining the logic
into a single expression.</p><table class=wikitable><caption>Branchless Conversion of BBox-BBox Intersection</caption><tbody><tr><th>Approach</th><th>Code</th><th>Assembly</th></tr><tr><td rowspan=2>Original</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span>
do_overlap<span class=br0>(</span><span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb1, <span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb2<span class=br0>)</span>
<span class=br0>{</span>
    <span class=co1>// check for emptiness&nbsp;??</span>
    <span class=kw1>if</span> <span class=br0>(</span>bb1.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>||</span> bb2.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span>
        <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>bb1.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>||</span> bb2.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span>
        <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>if</span> <span class=br0>(</span>bb1.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>||</span> bb2.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span>
        <span class=kw1>return</span> <span class=kw2>false</span><span class=sy4>;</span>
    <span class=kw1>return</span> <span class=kw2>true</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><pre>00000000004012b0 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)&gt;:
  4012b0:           f2 0f 10 06                 movsd  (%rsi),%xmm0
  4012b4:           31 c0                       xor   &nbsp;%eax,%eax
  4012b6:           66 0f 2f 47 18              comisd 0x18(%rdi),%xmm0
  4012bb:       /-- 77 3c                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012bd:       |   f2 0f 10 07                 movsd  (%rdi),%xmm0
  4012c1:       |   66 0f 2f 46 18              comisd 0x18(%rsi),%xmm0
  4012c6:       +-- 77 31                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012c8:       |   f2 0f 10 46 08              movsd  0x8(%rsi),%xmm0
  4012cd:       |   66 0f 2f 47 20              comisd 0x20(%rdi),%xmm0
  4012d2:       +-- 77 25                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012d4:       |   f2 0f 10 47 08              movsd  0x8(%rdi),%xmm0
  4012d9:       |   66 0f 2f 46 20              comisd 0x20(%rsi),%xmm0
  4012de:       +-- 77 19                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012e0:       |   f2 0f 10 46 10              movsd  0x10(%rsi),%xmm0
  4012e5:       |   66 0f 2f 47 28              comisd 0x28(%rdi),%xmm0
  4012ea:       +-- 77 0d                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012ec:       |   f2 0f 10 47 10              movsd  0x10(%rdi),%xmm0
  4012f1:       |   66 0f 2f 46 28              comisd 0x28(%rsi),%xmm0
  4012f6:       |   0f 96 c0                    setbe &nbsp;%al
  4012f9:       \-&gt; c3                          retq
</pre></td></tr><tr><td colspan=2><p>It's immediately clear the original code is riddled with early exits.
These early exits may or may not be helpful for performance during sequential operation,
but they pose a problem when we want to vectorize this code.</p></td></tr><tr><td rowspan=2>Single-expression</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span>
do_overlap<span class=br0>(</span><span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb1, <span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb2<span class=br0>)</span>
<span class=br0>{</span>
  <span class=co1>// Only return true if there's overlap on every axis</span>
  <span class=kw1>return</span> <span class=sy3>!</span><span class=br0>(</span>bb1.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>||</span> bb2.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=co1>// No overlap on x</span>
         <span class=sy3>!</span><span class=br0>(</span>bb1.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>||</span> bb2.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=co1>// No overlap on y</span>
         <span class=sy3>!</span><span class=br0>(</span>bb1.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>||</span> bb2.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>   <span class=co1>// No overlap on z</span>
<span class=br0>}</span></pre></div></div></td><td><pre>00000000004012b0 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)&gt;:
  4012b0:           f2 0f 10 06                 movsd  (%rsi),%xmm0
  4012b4:           31 c0                       xor   &nbsp;%eax,%eax
  4012b6:           66 0f 2f 47 18              comisd 0x18(%rdi),%xmm0
  4012bb:       /-- 77 3c                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012bd:       |   f2 0f 10 07                 movsd  (%rdi),%xmm0
  4012c1:       |   66 0f 2f 46 18              comisd 0x18(%rsi),%xmm0
  4012c6:       +-- 77 31                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012c8:       |   f2 0f 10 46 08              movsd  0x8(%rsi),%xmm0
  4012cd:       |   66 0f 2f 47 20              comisd 0x20(%rdi),%xmm0
  4012d2:       +-- 77 25                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012d4:       |   f2 0f 10 47 08              movsd  0x8(%rdi),%xmm0
  4012d9:       |   66 0f 2f 46 20              comisd 0x20(%rsi),%xmm0
  4012de:       +-- 77 19                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012e0:       |   f2 0f 10 46 10              movsd  0x10(%rsi),%xmm0
  4012e5:       |   66 0f 2f 47 28              comisd 0x28(%rdi),%xmm0
  4012ea:       +-- 77 0d                       ja     4012f9 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x49&gt;
  4012ec:       |   f2 0f 10 47 10              movsd  0x10(%rdi),%xmm0
  4012f1:       |   66 0f 2f 46 28              comisd 0x28(%rsi),%xmm0
  4012f6:       |   0f 96 c0                    setbe &nbsp;%al
  4012f9:       \-&gt; c3                          retq
</pre></td></tr><tr><td colspan=2><p>Refactoring into a single expression may seem like it should result in branchless
operation
-- after all, it's only producing a single boolean and returning it --
but for reasons I'll explain shortly it produces exactly the same assembly as the
original version!</p></td></tr><tr><td rowspan=2>"Branchless"</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span>
do_overlap<span class=br0>(</span><span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb1, <span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb2<span class=br0>)</span>
<span class=br0>{</span>
  <span class=co1>// Determine how much overlap exists in each axis</span>
  <span class=kw4>double</span> x_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=kw4>double</span> y_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=kw4>double</span> z_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
  <span class=co1>// Only return true if there's overlap on every axis</span>
  <span class=kw1>return</span> x_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span> <span class=sy3>&amp;&amp;</span>
         y_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span> <span class=sy3>&amp;&amp;</span>
         z_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><pre>00000000004012b0 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)&gt;:
  4012b0:           f2 0f 10 46 18              movsd  0x18(%rsi),%xmm0
  4012b5:           f2 0f 10 0e                 movsd  (%rsi),%xmm1
  4012b9:           66 0f ef ed                 pxor  &nbsp;%xmm5,%xmm5
  4012bd:           f2 0f 5f 0f                 maxsd  (%rdi),%xmm1
  4012c1:           f2 0f 5d 47 18              minsd  0x18(%rdi),%xmm0
  4012c6:           f2 0f 10 5e 08              movsd  0x8(%rsi),%xmm3
  4012cb:           f2 0f 10 56 28              movsd  0x28(%rsi),%xmm2
  4012d0:           f2 0f 10 66 10              movsd  0x10(%rsi),%xmm4
  4012d5:           f2 0f 5f 5f 08              maxsd  0x8(%rdi),%xmm3
  4012da:           f2 0f 5c c1                 subsd &nbsp;%xmm1,%xmm0
  4012de:           f2 0f 5d 57 28              minsd  0x28(%rdi),%xmm2
  4012e3:           f2 0f 10 4e 20              movsd  0x20(%rsi),%xmm1
  4012e8:           f2 0f 5f 67 10              maxsd  0x10(%rdi),%xmm4
  4012ed:           f2 0f 5d 4f 20              minsd  0x20(%rdi),%xmm1
  4012f2:           66 0f 2f c5                 comisd&nbsp;%xmm5,%xmm0
  4012f6:       /-- 72 18                       jb     401310 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x60&gt;
  4012f8:       |   f2 0f 5c cb                 subsd &nbsp;%xmm3,%xmm1
  4012fc:       |   66 0f 2f cd                 comisd&nbsp;%xmm5,%xmm1
  401300:       +-- 72 0e                       jb     401310 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)+0x60&gt;
  401302:       |   f2 0f 5c d4                 subsd &nbsp;%xmm4,%xmm2
  401306:       |   66 0f 2f d5                 comisd&nbsp;%xmm5,%xmm2
  40130a:       |   0f 93 c0                    setae &nbsp;%al
  40130d:       |   c3                          retq
  40130e:       |   66 90                       xchg  &nbsp;%ax,%ax
  401310:       \-&gt; 31 c0                       xor   &nbsp;%eax,%eax
  401312:           c3                          retq
</pre></td></tr><tr><td colspan=2><p>This version replaces the original approach with something that looks at the problem
"intuitively".
It does reduce the number of early exits, but it still doesn't actually produce
branchless logic.
Looking at the code, it's not entirely clear where our conditional behavior comes from.</p><p>The catch: C++'s short circuit evaluation introduces jumps!
In our logical expression <code>x_overlap >= 0 && y_overlap >= 0 &&
z_overlap >= 0</code>, the C++ standard guarantees that <code>y_overlap >= 0
&& z_overlap >= 0</code> should not be evaluated if <code>x_overlap >=
0</code> is <code>false</code>.
To achieve this, the compiler must add an "invisible" conditional.</p><p>I've found short-circuiting behavior helpful only on occasion,
and I hadn't considered the degree to which it hamstrings the compiler.
Even though <code>y_overlap >= 0 && z_overlap >= 0</code> clearly has no
side-effects, the compiler must insert logic to avoid evaluating it, when it may be
detrimental to performance.
Luckily, C++ provides <a rel=nofollow class="external text" href=https://stackoverflow.com/questions/1758608/is-there-an-non-short-circuited-logical-and-in-c>several
ways</a> of avoiding short-circuits in logic.</p></td></tr><tr><td rowspan=2>Explicit branchless<p>(intermediate values)</p></td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span>
do_overlap<span class=br0>(</span><span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb1, <span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb2<span class=br0>)</span>
<span class=br0>{</span>
&nbsp;
  <span class=co1>// Determine how much overlap exists in each axis</span>
  <span class=kw4>double</span> x_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=kw4>double</span> y_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=kw4>double</span> z_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
  <span class=co1>// Determine whether each axis has a positive overlap</span>
  <span class=kw4>bool</span> x_intersect <span class=sy1>=</span> x_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
  <span class=kw4>bool</span> y_intersect <span class=sy1>=</span> y_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
  <span class=kw4>bool</span> z_intersect <span class=sy1>=</span> z_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
&nbsp;
  <span class=co1>// Only intersects if there's overlap on every axis</span>
  <span class=kw4>bool</span> xy_intersect <span class=sy1>=</span> x_intersect <span class=sy3>&amp;&amp;</span> y_intersect<span class=sy4>;</span>
  <span class=kw4>bool</span> intersect <span class=sy1>=</span> xy_intersect <span class=sy3>&amp;&amp;</span> z_intersect<span class=sy4>;</span>
&nbsp;
  <span class=kw1>return</span> intersect<span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><pre>00000000004012b0 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)&gt;:
  4012b0:       f2 0f 10 56 18          movsd  0x18(%rsi),%xmm2
  4012b5:       f2 0f 10 0e             movsd  (%rsi),%xmm1
  4012b9:       f2 0f 5d 57 18          minsd  0x18(%rdi),%xmm2
  4012be:       f2 0f 5f 0f             maxsd  (%rdi),%xmm1
  4012c2:       f2 0f 10 5e 08          movsd  0x8(%rsi),%xmm3
  4012c7:       f2 0f 5f 5f 08          maxsd  0x8(%rdi),%xmm3
  4012cc:       f2 0f 10 46 28          movsd  0x28(%rsi),%xmm0
  4012d1:       f2 0f 10 66 10          movsd  0x10(%rsi),%xmm4
  4012d6:       f2 0f 5c d1             subsd &nbsp;%xmm1,%xmm2
  4012da:       f2 0f 10 4e 20          movsd  0x20(%rsi),%xmm1
  4012df:       f2 0f 5d 4f 20          minsd  0x20(%rdi),%xmm1
  4012e4:       f2 0f 5d 47 28          minsd  0x28(%rdi),%xmm0
  4012e9:       f2 0f 5f 67 10          maxsd  0x10(%rdi),%xmm4
  4012ee:       f2 0f 5c cb             subsd &nbsp;%xmm3,%xmm1
  4012f2:       66 0f ef db             pxor  &nbsp;%xmm3,%xmm3
  4012f6:       66 0f 2f d3             comisd&nbsp;%xmm3,%xmm2
  4012fa:       f2 0f 5c c4             subsd &nbsp;%xmm4,%xmm0
  4012fe:       0f 93 c0                setae &nbsp;%al
  401301:       66 0f 2f cb             comisd&nbsp;%xmm3,%xmm1
  401305:       0f 93 c2                setae &nbsp;%dl
  401308:       21 d0                   and   &nbsp;%edx,%eax
  40130a:       66 0f 2f c3             comisd&nbsp;%xmm3,%xmm0
  40130e:       0f 93 c2                setae &nbsp;%dl
  401311:       21 d0                   and   &nbsp;%edx,%eax
  401313:       c3                      retq
</pre></td></tr><tr><td colspan=2><p>Here, I use additional variables to ensure that intermediate values are actually
computed.
This is the first version to produce true straight-line assembly!</p><p>This tends to be the best-practice for this type of thing, in this case the resulting
code is terribly unclear.
Even if this isn't how the assembly does things, it's preferable to treat x, y, and z
symmetrically.</p></td></tr><tr><td rowspan=2>Explicit branchless<p>(boolean operations)</p></td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span>
do_overlap<span class=br0>(</span><span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb1, <span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb2<span class=br0>)</span>
<span class=br0>{</span>
  <span class=co1>// Determine how much overlap exists in each axis</span>
  <span class=kw4>double</span> x_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=kw4>double</span> y_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=kw4>double</span> z_overlap <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span>bb1.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy2>-</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span>bb1.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span>, bb2.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
  <span class=co1>// Determine whether each axis has a positive overlap</span>
  <span class=kw4>bool</span> x_intersect <span class=sy1>=</span> x_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
  <span class=kw4>bool</span> y_intersect <span class=sy1>=</span> y_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
  <span class=kw4>bool</span> z_intersect <span class=sy1>=</span> z_overlap <span class=sy1>&gt;=</span> <span class=nu0>0</span><span class=sy4>;</span>
&nbsp;
  <span class=co1>// Only intersects if there's overlap on every axis</span>
  <span class=kw4>bool</span> intersect <span class=sy1>=</span> x_intersect <span class=sy3>&amp;</span> y_intersect <span class=sy3>&amp;</span> z_intersect<span class=sy4>;</span>
&nbsp;
  <span class=kw1>return</span> intersect<span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><pre>00000000004012b0 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)&gt;:
  4012b0:       f2 0f 10 56 18          movsd  0x18(%rsi),%xmm2
  4012b5:       f2 0f 10 0e             movsd  (%rsi),%xmm1
  4012b9:       f2 0f 5d 57 18          minsd  0x18(%rdi),%xmm2
  4012be:       f2 0f 5f 0f             maxsd  (%rdi),%xmm1
  4012c2:       f2 0f 10 5e 08          movsd  0x8(%rsi),%xmm3
  4012c7:       f2 0f 5f 5f 08          maxsd  0x8(%rdi),%xmm3
  4012cc:       f2 0f 10 46 28          movsd  0x28(%rsi),%xmm0
  4012d1:       f2 0f 10 66 10          movsd  0x10(%rsi),%xmm4
  4012d6:       f2 0f 5c d1             subsd &nbsp;%xmm1,%xmm2
  4012da:       f2 0f 10 4e 20          movsd  0x20(%rsi),%xmm1
  4012df:       f2 0f 5d 4f 20          minsd  0x20(%rdi),%xmm1
  4012e4:       f2 0f 5d 47 28          minsd  0x28(%rdi),%xmm0
  4012e9:       f2 0f 5f 67 10          maxsd  0x10(%rdi),%xmm4
  4012ee:       f2 0f 5c cb             subsd &nbsp;%xmm3,%xmm1
  4012f2:       66 0f ef db             pxor  &nbsp;%xmm3,%xmm3
  4012f6:       66 0f 2f d3             comisd&nbsp;%xmm3,%xmm2
  4012fa:       f2 0f 5c c4             subsd &nbsp;%xmm4,%xmm0
  4012fe:       0f 93 c0                setae &nbsp;%al
  401301:       66 0f 2f cb             comisd&nbsp;%xmm3,%xmm1
  401305:       0f 93 c2                setae &nbsp;%dl
  401308:       21 d0                   and   &nbsp;%edx,%eax
  40130a:       66 0f 2f c3             comisd&nbsp;%xmm3,%xmm0
  40130e:       0f 93 c2                setae &nbsp;%dl
  401311:       21 d0                   and   &nbsp;%edx,%eax
  401313:       c3                      retq
</pre></td></tr><tr><td colspan=2><p>Using bitwise operators produces identical assembly, but lets us preserve code structure.
Both this solution and the previous solution suffer the same readability issue:
someone who isn't familiar with the reason behind the "ugly" code is liable to clean it
up, reintroducing the short circuits.
This issue can be resolved by surrounding the code with explanatory comments.
With that in mind I prefer this solution, because it's more easily readable at a glance.</p></td></tr><tr><td rowspan=2>Legible branchless</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>bool</span>
do_overlap<span class=br0>(</span><span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb1, <span class=kw4>const</span> Bbox_3<span class=sy3>&amp;</span> bb2<span class=br0>)</span>
<span class=br0>{</span>
  <span class=co1>// Only return true if there's overlap on every axis</span>
  <span class=kw1>return</span> <span class=sy3>!</span><span class=br0>(</span>bb1.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>|</span> bb2.<span class=me1>xmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>xmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy3>&amp;</span> <span class=co1>// No overlap on x</span>
         <span class=sy3>!</span><span class=br0>(</span>bb1.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>|</span> bb2.<span class=me1>ymax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>ymin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=sy3>&amp;</span> <span class=co1>// No overlap on y</span>
         <span class=sy3>!</span><span class=br0>(</span>bb1.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb2.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy3>|</span> bb2.<span class=me1>zmax</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>&lt;</span> bb1.<span class=me1>zmin</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>  <span class=co1>// No overlap on z</span>
<span class=br0>}</span></pre></div></div></td><td><pre>00000000004012b0 &lt;CGAL::do_overlap(CGAL::Bbox_3 const&amp;, CGAL::Bbox_3 const&amp;)&gt;:
  4012b0:       f2 0f 10 06             movsd  (%rsi),%xmm0
  4012b4:       66 0f 2f 47 18          comisd 0x18(%rdi),%xmm0
  4012b9:       f2 0f 10 07             movsd  (%rdi),%xmm0
  4012bd:       0f 97 c0                seta  &nbsp;%al
  4012c0:       66 0f 2f 46 18          comisd 0x18(%rsi),%xmm0
  4012c5:       f2 0f 10 46 08          movsd  0x8(%rsi),%xmm0
  4012ca:       0f 97 c2                seta  &nbsp;%dl
  4012cd:       09 d0                   or    &nbsp;%edx,%eax
  4012cf:       66 0f 2f 47 20          comisd 0x20(%rdi),%xmm0
  4012d4:       f2 0f 10 47 08          movsd  0x8(%rdi),%xmm0
  4012d9:       0f 97 c2                seta  &nbsp;%dl
  4012dc:       09 d0                   or    &nbsp;%edx,%eax
  4012de:       66 0f 2f 46 20          comisd 0x20(%rsi),%xmm0
  4012e3:       f2 0f 10 46 10          movsd  0x10(%rsi),%xmm0
  4012e8:       0f 97 c2                seta  &nbsp;%dl
  4012eb:       09 d0                   or    &nbsp;%edx,%eax
  4012ed:       66 0f 2f 47 28          comisd 0x28(%rdi),%xmm0
  4012f2:       f2 0f 10 47 10          movsd  0x10(%rdi),%xmm0
  4012f7:       0f 97 c2                seta  &nbsp;%dl
  4012fa:       09 d0                   or    &nbsp;%edx,%eax
  4012fc:       66 0f 2f 46 28          comisd 0x28(%rsi),%xmm0
  401301:       0f 97 c2                seta  &nbsp;%dl
  401304:       09 d0                   or    &nbsp;%edx,%eax
  401306:       83 f0 01                xor    $0x1,%eax
  401309:       c3                      retq
</pre></td></tr><tr><td colspan=2><p>Now that we know a solution to the root issue, we can apply it to our first approach.
This code contains none of the jumps that approach had, despite appearing almost
identical!</p></td></tr></tbody></table><p>This process illustrates the unique challenges that come with making complex logic branchless.
Problems are often well-hidden, and solutions unintuitive.
This is related to one of the advantages that a library like xsimd presents:
it's explicitness means that we can have greater confidence in the structure of the produced
assembly,
without needing to examine it directly.</p><h2><span class=mw-headline id=July_9_-_July_16><span class=mw-headline-number>4.8</span> July 9 - July 16</span></h2><h3><span class=mw-headline id=Truly_Branchless_do_intersect_bbox_segment_aux><span class=mw-headline-number>4.8.1</span> <i>Truly</i> Branchless <code>do_intersect_bbox_segment_aux</code></span></h3><p>Earlier I said that the FT type used by the new ray-bbox intersection
function was likely too elaborate to be effectively vectorized.
Further investigation revealed that in the case of the program I'm using
as a benchmark, <code>FT</code> is defined as <code>double</code>!
This can't be assumed to be true for most Kernels, but in this
particular case it provides an opportunity to look more closely at how
the function gets optimized.</p><table class=wikitable><caption>Branchless Conversion of Ray-BBox Intersection</caption><tbody><tr><th>Approach</th><th>Code</th><th>Assembly</th></tr><tr><td rowspan=2>With Short-circuits</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span>
        <span class=kw2>typename</span> FT,
        <span class=kw2>typename</span> BFT,
        <span class=kw4>bool</span> bounded_0,
        <span class=kw4>bool</span> bounded_1,
        <span class=kw4>bool</span> use_static_filters
<span class=sy1>&gt;</span>
<span class=kw2>typename</span> Do_intersect_bbox_segment_aux_is_greater<span class=sy1>&lt;</span>
        FT,
        bounded_0,
        use_static_filters
<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>result_type</span>
do_intersect_bbox_segment_aux<span class=br0>(</span>
        <span class=kw4>const</span> FT <span class=sy3>&amp;</span>px, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>py, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>pz,
        <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qx, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qy, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qz,
        <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bxmin, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bymin, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bzmin,
        <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bxmax, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bymax, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bzmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=kw4>const</span> BFT bx<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bxmin, bxmax<span class=br0>}</span><span class=sy4>;</span>
    <span class=kw4>const</span> BFT by<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bymin, bymax<span class=br0>}</span><span class=sy4>;</span>
    <span class=kw4>const</span> BFT bz<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bzmin, bzmax<span class=br0>}</span><span class=sy4>;</span>
&nbsp;
    <span class=kw4>const</span> <span class=kw4>int</span> sx <span class=sy1>=</span> qx <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
    <span class=kw4>const</span> <span class=kw4>int</span> sy <span class=sy1>=</span> qy <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
    <span class=kw4>const</span> <span class=kw4>int</span> sz <span class=sy1>=</span> qz <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine bounds x, y, and z</span>
    FT xmin <span class=sy1>=</span> <span class=br0>(</span>bx<span class=br0>[</span>sx<span class=br0>]</span> <span class=sy2>-</span> px<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qx <span class=sy2>-</span> px<span class=br0>)</span><span class=sy4>;</span>
    FT xmax <span class=sy1>=</span> <span class=br0>(</span>bx<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sx<span class=br0>]</span> <span class=sy2>-</span> px<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qx <span class=sy2>-</span> px<span class=br0>)</span><span class=sy4>;</span>
    FT ymin <span class=sy1>=</span> <span class=br0>(</span>by<span class=br0>[</span>sy<span class=br0>]</span> <span class=sy2>-</span> py<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qy <span class=sy2>-</span> py<span class=br0>)</span><span class=sy4>;</span>
    FT ymax <span class=sy1>=</span> <span class=br0>(</span>by<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sy<span class=br0>]</span> <span class=sy2>-</span> py<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qy <span class=sy2>-</span> py<span class=br0>)</span><span class=sy4>;</span>
    FT zmin <span class=sy1>=</span> <span class=br0>(</span>bz<span class=br0>[</span>sz<span class=br0>]</span> <span class=sy2>-</span> pz<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qz <span class=sy2>-</span> pz<span class=br0>)</span><span class=sy4>;</span>
    FT zmax <span class=sy1>=</span> <span class=br0>(</span>bz<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sz<span class=br0>]</span> <span class=sy2>-</span> pz<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qz <span class=sy2>-</span> pz<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the bounds of the overlapping region</span>
    FT min <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span><span class=br0>{</span>xmin, ymin, zmin<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
    FT max <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span><span class=br0>{</span>xmax, ymax, zmax<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region overlaps with the interval provided</span>
    Uncertain<span class=sy1>&lt;</span><span class=kw4>bool</span><span class=sy1>&gt;</span> new_result <span class=sy1>=</span>
            <span class=br0>(</span>max <span class=sy1>&gt;=</span> min<span class=br0>)</span> <span class=sy3>&amp;&amp;</span>            <span class=co1>// Check if there is any overlap at all</span>
            <span class=sy3>!</span><span class=br0>(</span>bounded_0 <span class=sy3>&amp;&amp;</span> max <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=br0>)</span> <span class=sy3>&amp;&amp;</span> <span class=co1>// Check if the overlap is outside the ray (before the start)</span>
            <span class=sy3>!</span><span class=br0>(</span>bounded_1 <span class=sy3>&amp;&amp;</span> min <span class=sy1>&gt;</span> <span class=nu0>1</span><span class=br0>)</span><span class=sy4>;</span>   <span class=co1>// Check if the overlap is outside the ray (after the end)</span>
&nbsp;
    <span class=kw1>return</span> new_result<span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><pre>000000000040c480 &lt;CCGAL::Intersections::internal::do_intersect_bbox_segment_aux&lt;...&gt;(...)&gt;:
  40c480:           f2 0f 11 7c 24 e0           movsd &nbsp;%xmm7,-0x20(%rsp)
  40c486:           66 0f ef ff                 pxor  &nbsp;%xmm7,%xmm7
  40c48a:           31 c0                       xor   &nbsp;%eax,%eax
  40c48c:           66 44 0f 28 c0              movapd&nbsp;%xmm0,%xmm8
  40c491:           66 0f 2f fb                 comisd&nbsp;%xmm3,%xmm7
  40c495:           f2 0f 10 44 24 10           movsd  0x10(%rsp),%xmm0
  40c49b:           f2 0f 11 74 24 d0           movsd &nbsp;%xmm6,-0x30(%rsp)
  40c4a1:           66 0f 28 f3                 movapd&nbsp;%xmm3,%xmm6
  40c4a5:           f2 41 0f 5c f0              subsd &nbsp;%xmm8,%xmm6
  40c4aa:           f2 0f 11 44 24 d8           movsd &nbsp;%xmm0,-0x28(%rsp)
  40c4b0:           f2 0f 10 44 24 18           movsd  0x18(%rsp),%xmm0
  40c4b6:           0f 97 c0                    seta  &nbsp;%al
  40c4b9:           31 f6                       xor   &nbsp;%esi,%esi
  40c4bb:           66 0f 2f fc                 comisd&nbsp;%xmm4,%xmm7
  40c4bf:           f2 0f 11 44 24 e8           movsd &nbsp;%xmm0,-0x18(%rsp)
  40c4c5:           48 89 c7                    mov   &nbsp;%rax,%rdi
  40c4c8:           f2 0f 5c e1                 subsd &nbsp;%xmm1,%xmm4
  40c4cc:           f2 0f 10 44 24 08           movsd  0x8(%rsp),%xmm0
  40c4d2:           f2 0f 10 5c c4 d0           movsd  -0x30(%rsp,%rax,8),%xmm3
  40c4d8:           b8 01 00 00 00              mov    $0x1,%eax
  40c4dd:           89 c2                       mov   &nbsp;%eax,%edx
  40c4df:           40 0f 97 c6                 seta  &nbsp;%sil
  40c4e3:           31 c9                       xor   &nbsp;%ecx,%ecx
  40c4e5:           f2 0f 11 44 24 f0           movsd &nbsp;%xmm0,-0x10(%rsp)
  40c4eb:           f2 0f 10 44 24 20           movsd  0x20(%rsp),%xmm0
  40c4f1:           66 0f 2f fd                 comisd&nbsp;%xmm5,%xmm7
  40c4f5:           f2 41 0f 5c d8              subsd &nbsp;%xmm8,%xmm3
  40c4fa:           f2 0f 5c ea                 subsd &nbsp;%xmm2,%xmm5
  40c4fe:           f2 0f 11 44 24 f8           movsd &nbsp;%xmm0,-0x8(%rsp)
  40c504:           f2 0f 5e de                 divsd &nbsp;%xmm6,%xmm3
  40c508:           0f 97 c1                    seta  &nbsp;%cl
  40c50b:           29 fa                       sub   &nbsp;%edi,%edx
  40c50d:           48 63 d2                    movslq&nbsp;%edx,%rdx
  40c510:           f2 0f 10 44 d4 d0           movsd  -0x30(%rsp,%rdx,8),%xmm0
  40c516:           48 63 d6                    movslq&nbsp;%esi,%rdx
  40c519:           f2 41 0f 5c c0              subsd &nbsp;%xmm8,%xmm0
  40c51e:           f2 44 0f 10 44 d4 e0        movsd  -0x20(%rsp,%rdx,8),%xmm8
  40c525:           89 c2                       mov   &nbsp;%eax,%edx
  40c527:           29 c8                       sub   &nbsp;%ecx,%eax
  40c529:           29 f2                       sub   &nbsp;%esi,%edx
  40c52b:           48 98                       cltq
  40c52d:           48 63 d2                    movslq&nbsp;%edx,%rdx
  40c530:           f2 44 0f 5c c1              subsd &nbsp;%xmm1,%xmm8
  40c535:           f2 0f 5e c6                 divsd &nbsp;%xmm6,%xmm0
  40c539:           f2 0f 10 74 d4 e0           movsd  -0x20(%rsp,%rdx,8),%xmm6
  40c53f:           48 63 d1                    movslq&nbsp;%ecx,%rdx
  40c542:           f2 0f 5c f1                 subsd &nbsp;%xmm1,%xmm6
  40c546:           f2 0f 10 4c c4 f0           movsd  -0x10(%rsp,%rax,8),%xmm1
  40c54c:           f2 0f 5c ca                 subsd &nbsp;%xmm2,%xmm1
  40c550:           f2 44 0f 5e c4              divsd &nbsp;%xmm4,%xmm8
  40c555:           f2 0f 5e f4                 divsd &nbsp;%xmm4,%xmm6
  40c559:           f2 0f 10 64 d4 f0           movsd  -0x10(%rsp,%rdx,8),%xmm4
  40c55f:           31 d2                       xor   &nbsp;%edx,%edx
  40c561:           f2 0f 5c e2                 subsd &nbsp;%xmm2,%xmm4
  40c565:           f2 44 0f 5f c3              maxsd &nbsp;%xmm3,%xmm8
  40c56a:           f2 0f 5e e5                 divsd &nbsp;%xmm5,%xmm4
  40c56e:           f2 0f 5d f0                 minsd &nbsp;%xmm0,%xmm6
  40c572:           f2 0f 5e cd                 divsd &nbsp;%xmm5,%xmm1
  40c576:           f2 41 0f 5f e0              maxsd &nbsp;%xmm8,%xmm4
  40c57b:           f2 0f 5d ce                 minsd &nbsp;%xmm6,%xmm1
  40c57f:           66 0f 2f cc                 comisd&nbsp;%xmm4,%xmm1
  40c583:       /-- 72 07                       jb     40c58c &lt;CGAL::Intersections::internal::do_intersect_bbox_segment_aux&lt;...&gt;(...)+0x10c&gt;
  40c585:       |   66 0f 2f f9                 comisd&nbsp;%xmm1,%xmm7
  40c589:       |   0f 96 c2                    setbe &nbsp;%dl
  40c58c:       \-&gt; 31 c0                       xor   &nbsp;%eax,%eax
  40c58e:           88 d0                       mov   &nbsp;%dl,%al
  40c590:           88 d4                       mov   &nbsp;%dl,%ah
  40c592:           c3                          retq
</pre></td></tr><tr><td colspan=2><p>My previous work produced something that was nearly branchless, but clearly it wasn't
quite perfect!
The short-circuiting behavior causes the same problems it did in my last experience, but
we can fix it with the same solution.</p></td></tr><tr><td rowspan=2>Short-circuits removed</td><td><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span>
        <span class=kw2>typename</span> FT,
        <span class=kw2>typename</span> BFT,
        <span class=kw4>bool</span> bounded_0,
        <span class=kw4>bool</span> bounded_1,
        <span class=kw4>bool</span> use_static_filters
<span class=sy1>&gt;</span>
<span class=kw2>typename</span> Do_intersect_bbox_segment_aux_is_greater<span class=sy1>&lt;</span>
        FT,
        bounded_0,
        use_static_filters
<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>result_type</span>
do_intersect_bbox_segment_aux<span class=br0>(</span>
        <span class=kw4>const</span> FT <span class=sy3>&amp;</span>px, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>py, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>pz,
        <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qx, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qy, <span class=kw4>const</span> FT <span class=sy3>&amp;</span>qz,
        <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bxmin, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bymin, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bzmin,
        <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bxmax, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bymax, <span class=kw4>const</span> BFT <span class=sy3>&amp;</span>bzmax<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=kw4>const</span> BFT bx<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bxmin, bxmax<span class=br0>}</span><span class=sy4>;</span>
    <span class=kw4>const</span> BFT by<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bymin, bymax<span class=br0>}</span><span class=sy4>;</span>
    <span class=kw4>const</span> BFT bz<span class=br0>[</span><span class=br0>]</span> <span class=sy1>=</span> <span class=br0>{</span>bzmin, bzmax<span class=br0>}</span><span class=sy4>;</span>
&nbsp;
    <span class=kw4>const</span> <span class=kw4>int</span> sx <span class=sy1>=</span> qx <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
    <span class=kw4>const</span> <span class=kw4>int</span> sy <span class=sy1>=</span> qy <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
    <span class=kw4>const</span> <span class=kw4>int</span> sz <span class=sy1>=</span> qz <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine bounds x, y, and z</span>
    FT xmin <span class=sy1>=</span> <span class=br0>(</span>bx<span class=br0>[</span>sx<span class=br0>]</span> <span class=sy2>-</span> px<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qx <span class=sy2>-</span> px<span class=br0>)</span><span class=sy4>;</span>
    FT xmax <span class=sy1>=</span> <span class=br0>(</span>bx<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sx<span class=br0>]</span> <span class=sy2>-</span> px<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qx <span class=sy2>-</span> px<span class=br0>)</span><span class=sy4>;</span>
    FT ymin <span class=sy1>=</span> <span class=br0>(</span>by<span class=br0>[</span>sy<span class=br0>]</span> <span class=sy2>-</span> py<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qy <span class=sy2>-</span> py<span class=br0>)</span><span class=sy4>;</span>
    FT ymax <span class=sy1>=</span> <span class=br0>(</span>by<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sy<span class=br0>]</span> <span class=sy2>-</span> py<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qy <span class=sy2>-</span> py<span class=br0>)</span><span class=sy4>;</span>
    FT zmin <span class=sy1>=</span> <span class=br0>(</span>bz<span class=br0>[</span>sz<span class=br0>]</span> <span class=sy2>-</span> pz<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qz <span class=sy2>-</span> pz<span class=br0>)</span><span class=sy4>;</span>
    FT zmax <span class=sy1>=</span> <span class=br0>(</span>bz<span class=br0>[</span><span class=nu0>1</span> <span class=sy2>-</span> sz<span class=br0>]</span> <span class=sy2>-</span> pz<span class=br0>)</span> <span class=sy2>/</span> <span class=br0>(</span>qz <span class=sy2>-</span> pz<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Determine the bounds of the overlapping region</span>
    FT min <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>max</span><span class=br0>(</span><span class=br0>{</span>xmin, ymin, zmin<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
    FT max <span class=sy1>=</span> std<span class=sy4>::</span><span class=me2>min</span><span class=br0>(</span><span class=br0>{</span>xmax, ymax, zmax<span class=br0>}</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// The ray intercepts if this region overlaps with the interval provided</span>
    Uncertain<span class=sy1>&lt;</span><span class=kw4>bool</span><span class=sy1>&gt;</span> new_result <span class=sy1>=</span>
            <span class=br0>(</span>max <span class=sy1>&gt;=</span> min<span class=br0>)</span> <span class=sy3>&amp;</span>            <span class=co1>// Check if there is any overlap at all</span>
            <span class=sy3>!</span><span class=br0>(</span>bounded_0 <span class=sy3>&amp;&amp;</span> max <span class=sy1>&lt;</span> <span class=nu0>0</span><span class=br0>)</span> <span class=sy3>&amp;</span> <span class=co1>// Check if the overlap is outside the ray (before the start)</span>
            <span class=sy3>!</span><span class=br0>(</span>bounded_1 <span class=sy3>&amp;&amp;</span> min <span class=sy1>&gt;</span> <span class=nu0>1</span><span class=br0>)</span><span class=sy4>;</span>  <span class=co1>// Check if the overlap is outside the ray (after the end)</span>
&nbsp;
    <span class=kw1>return</span> new_result<span class=sy4>;</span>
<span class=br0>}</span></pre></div></div></td><td><pre>000000000040c460 &lt;CGAL::Intersections::internal::do_intersect_bbox_segment_aux&lt;...&gt;(...)&gt;:
  40c460:       f2 0f 11 7c 24 e0       movsd &nbsp;%xmm7,-0x20(%rsp)
  40c466:       66 0f ef ff             pxor  &nbsp;%xmm7,%xmm7
  40c46a:       31 c0                   xor   &nbsp;%eax,%eax
  40c46c:       66 44 0f 28 c0          movapd&nbsp;%xmm0,%xmm8
  40c471:       66 0f 2f fb             comisd&nbsp;%xmm3,%xmm7
  40c475:       f2 0f 10 44 24 10       movsd  0x10(%rsp),%xmm0
  40c47b:       f2 0f 11 74 24 d0       movsd &nbsp;%xmm6,-0x30(%rsp)
  40c481:       66 0f 28 f3             movapd&nbsp;%xmm3,%xmm6
  40c485:       f2 41 0f 5c f0          subsd &nbsp;%xmm8,%xmm6
  40c48a:       f2 0f 11 44 24 d8       movsd &nbsp;%xmm0,-0x28(%rsp)
  40c490:       f2 0f 10 44 24 18       movsd  0x18(%rsp),%xmm0
  40c496:       0f 97 c0                seta  &nbsp;%al
  40c499:       31 f6                   xor   &nbsp;%esi,%esi
  40c49b:       66 0f 2f fc             comisd&nbsp;%xmm4,%xmm7
  40c49f:       f2 0f 11 44 24 e8       movsd &nbsp;%xmm0,-0x18(%rsp)
  40c4a5:       48 89 c7                mov   &nbsp;%rax,%rdi
  40c4a8:       f2 0f 5c e1             subsd &nbsp;%xmm1,%xmm4
  40c4ac:       f2 0f 10 44 24 08       movsd  0x8(%rsp),%xmm0
  40c4b2:       f2 0f 10 5c c4 d0       movsd  -0x30(%rsp,%rax,8),%xmm3
  40c4b8:       b8 01 00 00 00          mov    $0x1,%eax
  40c4bd:       89 c2                   mov   &nbsp;%eax,%edx
  40c4bf:       40 0f 97 c6             seta  &nbsp;%sil
  40c4c3:       31 c9                   xor   &nbsp;%ecx,%ecx
  40c4c5:       f2 0f 11 44 24 f0       movsd &nbsp;%xmm0,-0x10(%rsp)
  40c4cb:       f2 0f 10 44 24 20       movsd  0x20(%rsp),%xmm0
  40c4d1:       66 0f 2f fd             comisd&nbsp;%xmm5,%xmm7
  40c4d5:       f2 41 0f 5c d8          subsd &nbsp;%xmm8,%xmm3
  40c4da:       f2 0f 5c ea             subsd &nbsp;%xmm2,%xmm5
  40c4de:       f2 0f 11 44 24 f8       movsd &nbsp;%xmm0,-0x8(%rsp)
  40c4e4:       f2 0f 5e de             divsd &nbsp;%xmm6,%xmm3
  40c4e8:       0f 97 c1                seta  &nbsp;%cl
  40c4eb:       29 fa                   sub   &nbsp;%edi,%edx
  40c4ed:       48 63 d2                movslq&nbsp;%edx,%rdx
  40c4f0:       f2 0f 10 44 d4 d0       movsd  -0x30(%rsp,%rdx,8),%xmm0
  40c4f6:       48 63 d6                movslq&nbsp;%esi,%rdx
  40c4f9:       f2 41 0f 5c c0          subsd &nbsp;%xmm8,%xmm0
  40c4fe:       f2 44 0f 10 44 d4 e0    movsd  -0x20(%rsp,%rdx,8),%xmm8
  40c505:       89 c2                   mov   &nbsp;%eax,%edx
  40c507:       29 c8                   sub   &nbsp;%ecx,%eax
  40c509:       29 f2                   sub   &nbsp;%esi,%edx
  40c50b:       48 98                   cltq
  40c50d:       48 63 d2                movslq&nbsp;%edx,%rdx
  40c510:       f2 44 0f 5c c1          subsd &nbsp;%xmm1,%xmm8
  40c515:       f2 0f 5e c6             divsd &nbsp;%xmm6,%xmm0
  40c519:       f2 0f 10 74 d4 e0       movsd  -0x20(%rsp,%rdx,8),%xmm6
  40c51f:       48 63 d1                movslq&nbsp;%ecx,%rdx
  40c522:       f2 0f 5c f1             subsd &nbsp;%xmm1,%xmm6
  40c526:       f2 0f 10 4c c4 f0       movsd  -0x10(%rsp,%rax,8),%xmm1
  40c52c:       f2 0f 5c ca             subsd &nbsp;%xmm2,%xmm1
  40c530:       f2 0f 5e f4             divsd &nbsp;%xmm4,%xmm6
  40c534:       f2 44 0f 5e c4          divsd &nbsp;%xmm4,%xmm8
  40c539:       f2 0f 10 64 d4 f0       movsd  -0x10(%rsp,%rdx,8),%xmm4
  40c53f:       f2 0f 5c e2             subsd &nbsp;%xmm2,%xmm4
  40c543:       f2 0f 5d f0             minsd &nbsp;%xmm0,%xmm6
  40c547:       f2 0f 5e cd             divsd &nbsp;%xmm5,%xmm1
  40c54b:       f2 44 0f 5f c3          maxsd &nbsp;%xmm3,%xmm8
  40c550:       f2 0f 5e e5             divsd &nbsp;%xmm5,%xmm4
  40c554:       f2 0f 5d ce             minsd &nbsp;%xmm6,%xmm1
  40c558:       66 0f 2f f9             comisd&nbsp;%xmm1,%xmm7
  40c55c:       0f 96 c0                setbe &nbsp;%al
  40c55f:       f2 41 0f 5f e0          maxsd &nbsp;%xmm8,%xmm4
  40c564:       66 0f 2f cc             comisd&nbsp;%xmm4,%xmm1
  40c568:       0f 93 c2                setae &nbsp;%dl
  40c56b:       21 d0                   and   &nbsp;%edx,%eax
  40c56d:       31 d2                   xor   &nbsp;%edx,%edx
  40c56f:       88 c2                   mov   &nbsp;%al,%dl
  40c571:       88 c6                   mov   &nbsp;%al,%dh
  40c573:       89 d0                   mov   &nbsp;%edx,%eax
  40c575:       c3                      retq
</pre></td></tr><tr><td colspan=2><p>By using bitwise operators in place of normal boolean logic, we get true straight-line
code.</p></td></tr></tbody></table><p>I should emphasize that the fact that FT is a double is only incidental,
and this can't be relied upon for general use.
Neither of these solutions behave exactly the same as the original version either,
and they're liable to be giving false precision by never returning uncertain results.
Nevertheless, it's useful to have a branchless version of the intersection function,
and this lets us evaluate the advantages of some approaches that can be combined with it.</p><h3><span class=mw-headline id=Benchmarking_the_Child-Skipping_Optimization><span class=mw-headline-number>4.8.2</span> Benchmarking the Child-Skipping Optimization</span></h3><p>Last month, Andreas <a rel=nofollow class="external text" href=https://github.com/CGAL/cgal-public-dev/commit/1d2f6e2748c7a34f78fa509159df015d6b348109>experimented
with adding a child-skipping optimization</a> to the aabb-tree's traversal code.
By retrieving the grandchildren of each node, we can compare our bounding boxes in groups of 4 at a
time.
My intention is to examine how the Child-Skipping optimization combines with our branchless
intersection code.
Because the child skipping optimization uses the intersection function with groups of bounding boxes
at a time,
the hope is that when those are inlined they can be combined into a vectorized version of the same
function.</p><p>To this end, I would like to be able to use the child-skipping
approach in benchmarks,
once this is done it becomes trivial to integrate it with the branchless
intersection code (which is already working in the benchmark on another
branch).
Unfortunately because I'm using <code>remesh_polyhedral_surface_sm</code> as my benchmark, the
child-skipping approach isn't immediately compatible with existing code.</p><p>I had hoped the conversion process would be as simple as <a rel=nofollow class="external text" href=https://github.com/JacksonCampolattaro/cgal/blob/7298cefd96d83353aa8c4e8c3b0c0a7963a91849/Mesh_3/examples/Mesh_3/remesh_polyhedral_surface_sm.cpp#L2>enabling
the 4-way traversal with a <code>#define</code></a>,
as in Andreas' example code.
The first issue I encountered was that there are actually a large number
of intersection traits types provided by the AABB-tree,
and I had to <a rel=nofollow class="external text" href=https://github.com/JacksonCampolattaro/cgal/commit/7298cefd96d83353aa8c4e8c3b0c0a7963a91849#diff-c467ac9fe7540368e6b79416a994b157d1baddcf6c5ec1c81e7b525992bbac50>add
the 4-way intersection function to each of them</a>.
That helped, but I then discovered that the program also used a traits
class defined in the Polygon_mesh_processing package:
Ray_3_Triangle_3_traversal_traits.
Some traits classes have slightly different behavior, which meant that I
couldn't simply factor the 4 way intersection out.
Ray_3_Triangle_3_traversal_traits has some unique behavior of its own,
but it also has a template specialization that uses a much more
elaborate intersection function!
This intersection function (which conditionally invokes the branchless
one) is the source of a lot of trouble.
It's challenging to produce a straight-line version of it, and it may
also prevent the branchless code it invokes from being inlined the way
I'd like.</p><p>These complications make child-skipping a much less appealing
optimization;
I originally thought that it could be done in a low-impact way, only
affecting certain traversal functions, instead it requires invasive
changes to the way traversal is done.
We have no guarantee that this change would actually be a net
improvement to performance, let alone a quantitative prediction for its
value.
As a result, I'm considering shelving this change and dedicating time to
examining more straightforward solutions instead.</p><h3><span class=mw-headline id=Preparing_to_implement_N-Way_Splitting><span class=mw-headline-number>4.8.3</span> Preparing to implement N-Way Splitting</span></h3><h4><span class=mw-headline id=Planning><span class=mw-headline-number>4.8.3.1</span> Planning</span></h4><p>This list of steps is by no means complete,
it primarily focuses on the member variables the Node type is composed
of.
Each of the changes has implications for the rest of the code, for
example putting my pointers in a small array will require changes to the
relevant accessors.
The idea is that changes to how the data is structured will be the
driver for the rest of the work.
I expect each change to cause minor issues throughout the code-base,
which I can fix before moving on to the next step.
By breaking things up in this way I keep the code close to a working
state at every point during the development.
I expect the largest challenges to come from other packages in CGAL with
a dependence on particular implementation details of the existing tree;
with luck I'll be able to change them to better respect the AABB-tree's
abstractions.</p><p>Steps:</p><ul><li>Convert children from a pair of independent pointers to an array of pointers with size 2.<dl><dd><code>void *left, *right;</code> → <code>std::array&lt;void *, 2> children;</code></dd></dl></li><li>Use <code>std::variant</code> to differentiate between child pointers and primitive pointers
(rather than using a <code>void *</code>)<dl><dd><code>std::array&lt;void *, 2> children;</code> → <code>std::array&lt;std::variant&lt;Node
*, Primitive *>, 2> children;</code></dd></dl></li><li>Replace array of pointers with pointer to array, to pack the relevant data closer together.<dl><dd><code>std::array&lt;std::variant&lt;Node *, Primitive *>, 2> children;</code> →
<code>std::array&lt;std::variant&lt;Node, Primitive *>, 2> *children;</code></dd></dl></li><li>Replace uses of left and right children with operations applied to the list.<dl><dd><code>func(n.left()); func(n.right());</code> → <code>for (const auto &c&nbsp;:
n.children()) func(c);</code></dd></dl></li><li>Parametrize size of children list using a hard-coded value or a <code>#define</code>.<dl><dd><code>std::array&lt;std::variant&lt;Node *, Primitive *>, 2> children;</code> →
<code>std::array&lt;std::variant&lt;Node *, Primitive *>, N> children;</code></dd></dl></li><li>Replace hard-coded child count with a template parameter for the node, having a default value
of 2.</li><li>Add child count template parameter to tree's Traits class, using
that value when instantiating the node class (again, with a default
value of 2).</li><li>Change default value to 4 or 8.</li></ul><p>Additionally, once these changes are made it becomes simpler to pack the bounding boxes efficiently:</p><ul><li>Move BBox into parent node.</li><li>Break BBoxes into efficiently packed parallel arrays.</li></ul><h4><span class=mw-headline id=Child_Array><span class=mw-headline-number>4.8.3.2</span> Child Array</span></h4><p>The first planned change was to replace the independent children with an <code>std::array</code>
containing them.
This change went very quickly, and because the Node class is nicely
encapsulated the difference could be accounted for simply by altering
the accessors.
I'm using the <code>aabb_any_all_benchmark.cpp</code> test to verify the program, and it actually
showed a marginal but consistent improvement in performance!
This improvement is around 1% for all kernels used, and may come from <code>std::array</code>'s
semantics, (for example, perhaps both children can be initialized to <code>nullptr</code> in a more
efficient way).</p><h4><span class=mw-headline id=std::variant_Children><span class=mw-headline-number>4.8.3.3</span> <code>std::variant</code> Children</span></h4><p>Because CGAL doesn't yet depend on C++17, I substituted <code>boost::variant</code> for <code>std::variant</code>,
this went almost as smoothly as switching to an array, besides some
extra effort to initialize the node with nullptrs of the correct type.
<code>variant</code> provides some additional safety guarantees, but that comes with a performance
penalty;
the same program runs a little over 1% slower than the original.</p><h4><span class=mw-headline id=Pointer-to-array_replaces_Array-of-pointers><span class=mw-headline-number>4.8.3.4</span> Pointer-to-array replaces Array-of-pointers</span></h4><p>Though not strictly necessary, it seemed prudent to replace my array
of pointers of nodes with a pointer to an array of nodes.
This could theoretically produce simpler syntax, but more importantly it
guarantees that nodes with the same parent will be adjacent in memory.</p><p>The first complication I ran into here was that the nodes are
already being stored in an underlying vector.
Whenever we allocate new nodes, they get emplaced at the back of the
vector.
This does mean that nodes hold references to other places in the vector,
which would be invalidated if the vector were to reallocate.
To avoid this, the vector has enough space reserved beforehand to avoid
the need to reallocate for even the largest (degenerate case) tree.
To have pointers to arrays, I actually need to have pointers to subsets
of the underlying node vector.
CGAL isn't on C++20 (yet), so I can't use <code>std::span</code>; instead, I'm using a bare pointer
to the group's first element as a stopgap solution.</p><p>The next issue was that I needed to change the contents of the underlying vector.
Because nodes were allowed to contain a combination of primitives and other nodes, the vector needed
to be able to do the same.
As an temporary solution, this is done with the help of <code>boost::variant</code>.
In the next step, I'm planning to change the structure of the tree, so
that each node can contain either a pair of nodes or a primitive.
This moves the use of <code>variant</code> into the Node type, reduces pointer chaining, and opens
the door to experimenting with bucket sizes in the future.</p><p>I expected this to perform worse than previous methods, primarily because the underlying node vector
is much more poorly packed.
My expectations were borne out, as the new code performs nearly 10% worse.</p><h4><span class=mw-headline id=Single-primitive_leaves><span class=mw-headline-number>4.8.3.5</span> Single-primitive leaves</span></h4><p>I was expecting this change to be more challenging, because it's a fundamental difference in how the
tree is constructed.</p><p>In the original tree structure, a node could point to a pair of
child nodes (not shown), or a child node and a primitive (the root
node), or a pair of primitives (the first node on the right).</p><pre>          N
         / \
        P   N
           / \
          P   P
</pre><p>With the new way I'm defining the node type, it can either point to a
pair of child nodes (which are contiguous in memory) or a single
primitive.</p><pre>    N
     \
      {N, N}
       |   \
       P    {N, N}
             |  |
             P  P
</pre><p>The implementation actually turned out simple (each node contains an
std::variant determining whether it has children or a primitive),
and the Node class is well encapsulated, so I could hide the change with
shim code in the <code>left_data</code> and <code>right_data</code>
methods.
I'll need to remove explicit references to "left" and "right" when I
increase the number of children, so these methods will be temporary.</p><p>I expected this to hurt performance, but if it does that's counteracted by the node's better
arrangement in memory.
This performs significantly better than the last approach, only a couple of percent worse than the
original.</p><h4><span class=mw-headline id=Simplified_Traversal_Method><span class=mw-headline-number>4.8.3.6</span> Simplified Traversal Method</span></h4><p>This is where the previous changes start to pay off.
A node now contains either a single primitive, or the set of its children (for now, always a pair).
This is a reduction in the number of valid states a node can be in, and actually simplifies the
traversal function.
Not only is this an improvement for readability, it actually results in better performance, too.
The traversal benchmarks run between 5 and 15% faster than the original version, depending on the
kernel!</p><h4><span class=mw-headline id=Simplified_Ray-Traversal_Method><span class=mw-headline-number>4.8.3.7</span> Simplified Ray-Traversal Method</span></h4><p>The <code>ray_intersection()</code> method in <code>AABB_ray_intersection.h</code>
behaves a little bit differently than the tree's built in traversal
function.
That method can be used to find out if there are any intersections with
the query, or to collect all intersecting primitives, depending on the
provided traversal traits.
This method specifically finds the first intersected primitive (closest
to the source), naturally, this is a concept specific to the ray type.
The most clearly relevant use here is rendering, where it's obvious that
only the closest intersection is needed.</p><p>To achieve this functionality efficiently, a very different approach is used.
A priority queue is used to look at the nearest nodes first,
and the closest intersection is updated whenever a closer one is found.
The traversal doesn't stop until the next nearest node is further than current closest intersection,
because none of its children could possibly be closer.</p><p>Similar to the other traversal method, the algorithm is complicated by the number of states the node
is allowed to be in.
Now that we have a less complicated node type, we can simplify this method significantly.
Here, the simplifications actually hurt performance by around 10%.
My theory is that before primitives would immediately be checked for intersection when they were
encountered,
but now they are being added to the queue, since they have their own nodes with bounding boxes.
There are workarounds to prevent this from happening, which I plan to explore once other
optimizations have been applied.</p><h4><span class=mw-headline id=Eliminating_use_of_.22left.22_and_.22right.22><span class=mw-headline-number>4.8.3.8</span> Eliminating use of "left" and "right"</span></h4><p>The left/right data accessors actually fell out of use when I
simplified the traversal functions.
Because they didn't reflect the structure of the tree anymore, they
didn't have any reason to appear in the new version of the functions.</p><p>The left/right child accessors were a more complicated situation.
These make perfect sense in the context of the tree's current structure,
but if I want to have more than two accessors than it's obvious that
they can't be used.
Instead, wherever an operation was performed on the left and then the
right children, I substituted an iterator over the children.
This tended to complicate things only minimally, the main problems came
from where left and right nodes aren't treated uniformly.
When distributing primitives between a pair of nodes the total count was
divided in half to find the count for the left node,
and the right node received any that were left over.
This is a nice solution for a pair of nodes because it doesn't require
special considerations for rounding,
but it won't work for larger numbers of nodes.
Instead, I created a function that decides how many primitives each
child should get.
What's convenient is that this function could distribute the primitives
however I'd like, it just needs to be consistent because it will be used
for both construction and traversal.
Naturally, the best solution is to make the distribution as even as
possible.</p><p>This change did hurt performance, and I suspect that these newly introduced loops aren't being
unrolled.
I also suspect that the code for determining how many primitives a node should contain is performing
poorly.
Overall, benchmarks run around 50% slower.</p><h2><span class=mw-headline id=July_17_-_July_24><span class=mw-headline-number>4.9</span> July 17 - July 24</span></h2><h3><span class=mw-headline id=Enabling_N-Way_Splitting><span class=mw-headline-number>4.9.1</span> Enabling N-Way Splitting</span></h3><p>All of my preparatory work paid off,
and getting a tree with N-way splits was accomplished by simply replacing all instances of a
hard-coded "2" with a variable N.
By changing N, I successfully produced trees of different widths.</p><p>Changing N to 4 results in a tree that is traversed marginally slower (a couple of percent);
this makes sense, because generally it's now necessary to intersect with more bounding boxes as we
descend the tree.
This doesn't become an advantage until we begin using SIMD to perform those intersections at minimal
additional cost.</p><p>I also discovered that the earlier change which massively hurt performance was actually due to
omitting the <code>traits.go_further()</code>
check that stops the search early.
Reintroducing this check actually greatly improved performance, and the
current code is actually only around 12% slower than the original.</p><p>A clear future step is to define a solid API for the modified tree (for example, N should be a
template parameter),
but serious time shouldn't be spent on that until after we can show a performance advantage.</p><h3><span class=mw-headline id=Cleaning_up_Traversal_code><span class=mw-headline-number>4.9.2</span> Cleaning up Traversal code</span></h3><p>The following is my solution for performing a traversal on a N-way
tree.
The intention of splitting the recursive into two for loops is to enable
SIMD between the different invocations of the non-recursive loop.
If we calculated each box intersection just before deciding to recurse,
there would be no potential for them to combined into a batched
operation.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1>  AABB_node<span class=sy1>&lt;</span>Tr<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>traversal</span><span class=br0>(</span><span class=kw4>const</span> Query <span class=sy3>&amp;</span>query,
                           Traversal_traits <span class=sy3>&amp;</span>traits,
                           <span class=kw4>const</span> std<span class=sy4>::</span><span class=kw4>size_t</span> nb_primitives<span class=br0>)</span> <span class=kw4>const</span> <span class=br0>{</span>
    <span class=kw1>if</span> <span class=br0>(</span><span class=sy3>!</span>traits.<span class=me1>go_further</span><span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=kw1>return</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// This is a Depth-first traversal</span>
&nbsp;
    <span class=kw1>if</span> <span class=br0>(</span>nb_primitives <span class=sy1>==</span> <span class=nu0>1</span><span class=br0>)</span> <span class=br0>{</span>
&nbsp;
      <span class=co1>// If there's only one primitive, we've reached a leaf node</span>
      traits.<span class=me1>intersection</span><span class=br0>(</span>query, data<span class=br0>(</span><span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=br0>}</span> <span class=kw1>else</span> <span class=br0>{</span>
&nbsp;
      <span class=co1>// Determine whether each child intersects</span>
      std<span class=sy4>::</span><span class=me2>array</span><span class=sy1>&lt;</span><span class=kw4>bool</span>, N<span class=sy1>&gt;</span> intersections<span class=br0>{</span><span class=kw2>false</span><span class=br0>}</span><span class=sy4>;</span>
      <span class=kw1>for</span> <span class=br0>(</span><span class=kw4>size_t</span> i <span class=sy1>=</span> <span class=nu0>0</span><span class=sy4>;</span> i <span class=sy1>&lt;</span> N<span class=sy4>;</span> <span class=sy2>++</span>i<span class=br0>)</span>
        intersections<span class=br0>[</span>i<span class=br0>]</span> <span class=sy1>=</span> traits.<span class=me1>do_intersect</span><span class=br0>(</span>query, children<span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>i<span class=br0>]</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
      <span class=co1>// Recursively check each child that intersected</span>
      <span class=kw1>for</span> <span class=br0>(</span><span class=kw4>size_t</span> i <span class=sy1>=</span> <span class=nu0>0</span><span class=sy4>;</span> i <span class=sy1>&lt;</span> N<span class=sy4>;</span> <span class=sy2>++</span>i<span class=br0>)</span> <span class=br0>{</span>
        <span class=kw1>if</span> <span class=br0>(</span>intersections<span class=br0>[</span>i<span class=br0>]</span><span class=br0>)</span>
          children<span class=br0>(</span><span class=br0>)</span><span class=br0>[</span>i<span class=br0>]</span>.<span class=me1>traversal</span><span class=br0>(</span>query, traits, num_primitives<span class=br0>(</span>i, nb_primitives<span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
      <span class=br0>}</span>
    <span class=br0>}</span></pre></div></div><p>This is where it becomes clear that we're reaching the limits of
optimization that can be done simply by analyzing assembly.
When this is compiled along with the branchless intersection method from
earlier, the result is a tangle of jumps which is a challenge to
interpret.</p><pre style=font-size:40%;width:40%;overflow:hidden>
0000000000435830 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const&gt;:
  435830:	      /-------------------------------------------------------&gt; 41 56                	push  &nbsp;%r14
  435832:	      |                                                         41 55                	push  &nbsp;%r13
  435834:	      |                                                         49 89 d5             	mov   &nbsp;%rdx,%r13
  435837:	      |                                                         41 54                	push  &nbsp;%r12
  435839:	      |                                                         49 89 fc             	mov   &nbsp;%rdi,%r12
  43583c:	      |                                                         55                   	push  &nbsp;%rbp
  43583d:	      |                                                         48 89 f5             	mov   &nbsp;%rsi,%rbp
  435840:	      |                                                         53                   	push  &nbsp;%rbx
  435841:	      |                                                         48 89 cb             	mov   &nbsp;%rcx,%rbx
  435844:	      |                                                         48 83 ec 50          	sub    $0x50,%rsp
  435848:	      |  /----------------------------------------------------&gt; 41 80 7d 00 00       	cmpb   $0x0,0x0(%r13)
  43584d:	/-----|--|----------------------------------------------------- 0f 85 54 02 00 00    	jne    435aa7 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x277&gt;
  435853:	|     |  |                                                      49 8b 7c 24 30       	mov    0x30(%r12),%rdi
  435858:	|     |  |                                                      48 83 fb 01          	cmp    $0x1,%rbx
  43585c:	|  /--|--|----------------------------------------------------- 0f 84 d6 03 00 00    	je     435c38 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x408&gt;
  435862:	|  |  |  |                                                      f3 0f 10 6d 14       	movss  0x14(%rbp),%xmm5
  435867:	|  |  |  |                                                      f3 0f 10 7d 0c       	movss  0xc(%rbp),%xmm7
  43586c:	|  |  |  |                                                      66 0f ef c0          	pxor  &nbsp;%xmm0,%xmm0
  435870:	|  |  |  |                                                      48 89 f8             	mov   &nbsp;%rdi,%rax
  435873:	|  |  |  |                                                      f3 44 0f 10 4d 10    	movss  0x10(%rbp),%xmm9
  435879:	|  |  |  |                                                      48 8d 54 24 1c       	lea    0x1c(%rsp),%rdx
  43587e:	|  |  |  |                                                      4c 8d 44 24 20       	lea    0x20(%rsp),%r8
  435883:	|  |  |  |                                                      c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%rsp)
  43588a:	|  |  |  |                                                      00
  43588b:	|  |  |  |                                                      44 0f 28 d5          	movaps&nbsp;%xmm5,%xmm10
  43588f:	|  |  |  |                                                      0f 28 f7             	movaps&nbsp;%xmm7,%xmm6
  435892:	|  |  |  |                                                      f3 0f 11 6c 24 0c    	movss &nbsp;%xmm5,0xc(%rsp)
  435898:	|  |  |  |                                                      0f 28 cf             	movaps&nbsp;%xmm7,%xmm1
  43589b:	|  |  |  |                                                      f3 44 0f 59 d0       	mulss &nbsp;%xmm0,%xmm10
  4358a0:	|  |  |  |                                                      45 0f 28 c1          	movaps&nbsp;%xmm9,%xmm8
  4358a4:	|  |  |  |                                                      41 0f 28 d9          	movaps&nbsp;%xmm9,%xmm3
  4358a8:	|  |  |  |                                                      f3 44 0f 59 c0       	mulss &nbsp;%xmm0,%xmm8
  4358ad:	|  |  |  |                                                      f3 44 0f 58 55 08    	addss  0x8(%rbp),%xmm10
  4358b3:	|  |  |  |                                                      0f 57 0d f6 4f 04 00 	xorps  0x44ff6(%rip),%xmm1        # 47a8b0 &lt;vtable for CGAL::Polyhedron_scan_OFF&lt;CGAL::HalfedgeDS_default&lt;CGAL::Epick, CGAL::I_Polyhedron_derived_items_3&lt;CGAL::Polyhedron_items_3&gt;, std::allocator&lt;int&gt; &gt; &gt;+0x308&gt;
  4358ba:	|  |  |  |                                                      f3 0f 59 f0          	mulss &nbsp;%xmm0,%xmm6
  4358be:	|  |  |  |                                                      0f 57 2d eb 4f 04 00 	xorps  0x44feb(%rip),%xmm5        # 47a8b0 &lt;vtable for CGAL::Polyhedron_scan_OFF&lt;CGAL::HalfedgeDS_default&lt;CGAL::Epick, CGAL::I_Polyhedron_derived_items_3&lt;CGAL::Polyhedron_items_3&gt;, std::allocator&lt;int&gt; &gt; &gt;+0x308&gt;
  4358c5:	|  |  |  |                                                      0f 57 1d e4 4f 04 00 	xorps  0x44fe4(%rip),%xmm3        # 47a8b0 &lt;vtable for CGAL::Polyhedron_scan_OFF&lt;CGAL::HalfedgeDS_default&lt;CGAL::Epick, CGAL::I_Polyhedron_derived_items_3&lt;CGAL::Polyhedron_items_3&gt;, std::allocator&lt;int&gt; &gt; &gt;+0x308&gt;
  4358cc:	|  |  |  |                                                      f3 44 0f 58 45 04    	addss  0x4(%rbp),%xmm8
  4358d2:	|  |  |  |                                                      f3 0f 58 75 00       	addss  0x0(%rbp),%xmm6
  4358d7:	|  |  |  |                                                      66 0f 7e c9          	movd  &nbsp;%xmm1,%ecx
  4358db:	|  |  |  |                                                      f3 44 0f 11 54 24 08 	movss &nbsp;%xmm10,0x8(%rsp)
  4358e2:	|  |  |  |                                                      66 41 0f 7e eb       	movd  &nbsp;%xmm5,%r11d
  4358e7:	|  |  |  |                                                      66 41 0f 7e da       	movd  &nbsp;%xmm3,%r10d
  4358ec:	|  |  |  |                                               /----&gt; 0f 2f f8             	comiss&nbsp;%xmm0,%xmm7
  4358ef:	|  |  |  |                                               |      66 0f ef c9          	pxor  &nbsp;%xmm1,%xmm1
  4358f3:	|  |  |  |                                               |      66 0f ef db          	pxor  &nbsp;%xmm3,%xmm3
  4358f7:	|  |  |  |                                               |      f2 0f 10 50 20       	movsd  0x20(%rax),%xmm2
  4358fc:	|  |  |  |                                               |      f2 44 0f 10 58 28    	movsd  0x28(%rax),%xmm11
  435902:	|  |  |  |                                               |      f2 44 0f 10 50 10    	movsd  0x10(%rax),%xmm10
  435908:	|  |  |  |                                               |      f2 0f 5a 48 18       	cvtsd2ss 0x18(%rax),%xmm1
  43590d:	|  |  |  |                                               |      f2 0f 5a 18          	cvtsd2ss (%rax),%xmm3
  435911:	|  |  |  |                                               |      f2 0f 10 60 08       	movsd  0x8(%rax),%xmm4
  435916:	|  |  |  |                 /-----------------------------|----- 0f 82 9c 01 00 00    	jb     435ab8 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x288&gt;
  43591c:	|  |  |  |                 |                             |      0f 28 eb             	movaps&nbsp;%xmm3,%xmm5
  43591f:	|  |  |  |                 |                             |      f3 0f 5c ce          	subss &nbsp;%xmm6,%xmm1
  435923:	|  |  |  |                 |                             |      0f 28 df             	movaps&nbsp;%xmm7,%xmm3
  435926:	|  |  |  |                 |                             |      f3 0f 5c ee          	subss &nbsp;%xmm6,%xmm5
  43592a:	|  |  |  |                 |  /--------------------------|----&gt; 0f 2e d8             	ucomiss&nbsp;%xmm0,%xmm3
  43592d:	|  |  |  |                 |  |                          |  /-- 7a 17                	jp     435946 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x116&gt;
  43592f:	|  |  |  |                 |  |                          |  +-- 75 15                	jne    435946 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x116&gt;
  435931:	|  |  |  |                 |  |                          |  |   45 31 f6             	xor   &nbsp;%r14d,%r14d
  435934:	|  |  |  |                 |  |                          |  |   0f 2f e8             	comiss&nbsp;%xmm0,%xmm5
  435937:	|  |  |  |        /--------|--|--------------------------|--|-- 0f 87 23 01 00 00    	ja     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  43593d:	|  |  |  |        |        |  |                          |  |   0f 2f c1             	comiss&nbsp;%xmm1,%xmm0
  435940:	|  |  |  |        +--------|--|--------------------------|--|-- 0f 87 1a 01 00 00    	ja     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  435946:	|  |  |  |        |        |  |                          |  \-&gt; 44 0f 2f c8          	comiss&nbsp;%xmm0,%xmm9
  43594a:	|  |  |  |        |        |  |                          |      f2 0f 5a d2          	cvtsd2ss&nbsp;%xmm2,%xmm2
  43594e:	|  |  |  |        |        |  |                          |      f2 0f 5a e4          	cvtsd2ss&nbsp;%xmm4,%xmm4
  435952:	|  |  |  |        |  /-----|--|--------------------------|----- 0f 82 d8 01 00 00    	jb     435b30 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x300&gt;
  435958:	|  |  |  |        |  |     |  |                          |      f3 41 0f 5c e0       	subss &nbsp;%xmm8,%xmm4
  43595d:	|  |  |  |        |  |     |  |                          |      f3 41 0f 5c d0       	subss &nbsp;%xmm8,%xmm2
  435962:	|  |  |  |        |  |     |  |                          |      45 0f 28 e1          	movaps&nbsp;%xmm9,%xmm12
  435966:	|  |  |  |        |  |     |  |                          |      44 0f 28 fc          	movaps&nbsp;%xmm4,%xmm15
  43596a:	|  |  |  |        |  |  /--|--|--------------------------|----&gt; 44 0f 2e e0          	ucomiss&nbsp;%xmm0,%xmm12
  43596e:	|  |  |  |        |  |  |  |  |              /-----------|----- 0f 8a 5c 01 00 00    	jp     435ad0 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x2a0&gt;
  435974:	|  |  |  |        |  |  |  |  |              +-----------|----- 0f 85 56 01 00 00    	jne    435ad0 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x2a0&gt;
  43597a:	|  |  |  |        |  |  |  |  |              |           |      45 31 f6             	xor   &nbsp;%r14d,%r14d
  43597d:	|  |  |  |        |  |  |  |  |              |           |      44 0f 2f f8          	comiss&nbsp;%xmm0,%xmm15
  435981:	|  |  |  |        +--|--|--|--|--------------|-----------|----- 0f 87 d9 00 00 00    	ja     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  435987:	|  |  |  |        |  |  |  |  |              |           |      0f 2f c2             	comiss&nbsp;%xmm2,%xmm0
  43598a:	|  |  |  |        +--|--|--|--|--------------|-----------|----- 0f 87 d0 00 00 00    	ja     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  435990:	|  |  |  |        |  |  |  |  |              |           |      44 0f 28 f3          	movaps&nbsp;%xmm3,%xmm14
  435994:	|  |  |  |        |  |  |  |  |              |           |      44 0f 28 ed          	movaps&nbsp;%xmm5,%xmm13
  435998:	|  |  |  |        |  |  |  |  |              |           |      0f 28 e3             	movaps&nbsp;%xmm3,%xmm4
  43599b:	|  |  |  |        |  |  |  |  |              |           |      f3 45 0f 59 f7       	mulss &nbsp;%xmm15,%xmm14
  4359a0:	|  |  |  |        |  |  |  |  |              |           |      f3 45 0f 59 ec       	mulss &nbsp;%xmm12,%xmm13
  4359a5:	|  |  |  |        |  |  |  |  |              |           |      f3 0f 59 e2          	mulss &nbsp;%xmm2,%xmm4
  4359a9:	|  |  |  |        |  |  |  |  |              |           |      66 44 0f 7e f6       	movd  &nbsp;%xmm14,%esi
  4359ae:	|  |  |  |        |  |  |  |  |              |           |      44 0f 28 f1          	movaps&nbsp;%xmm1,%xmm14
  4359b2:	|  |  |  |        |  |  |  |  |              |           |      f3 45 0f 59 f4       	mulss &nbsp;%xmm12,%xmm14
  4359b7:	|  |  |  |        |  |  |  |  |              |           |      f3 0f 11 24 24       	movss &nbsp;%xmm4,(%rsp)
  4359bc:	|  |  |  |        |  |  |  |  |              |           |      f3 44 0f 11 74 24 04 	movss &nbsp;%xmm14,0x4(%rsp)
  4359c3:	|  |  |  |        |  |  |  |  |              |           |      66 44 0f 6e f6       	movd  &nbsp;%esi,%xmm14
  4359c8:	|  |  |  |        |  |  |  |  |              |           |      45 0f 2f f5          	comiss&nbsp;%xmm13,%xmm14
  4359cc:	|  |  |  |        |  |  |  |  |  /-----------|-----------|----- 0f 87 7e 01 00 00    	ja     435b50 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x320&gt;
  4359d2:	|  |  |  |        |  |  |  |  |  |           |     /-----|----&gt; 44 0f 28 eb          	movaps&nbsp;%xmm3,%xmm13
  4359d6:	|  |  |  |        |  |  |  |  |  |  /--------|-----|-----|----&gt; f3 44 0f 10 7c 24 04 	movss  0x4(%rsp),%xmm15
  4359dd:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      f3 0f 10 24 24       	movss  (%rsp),%xmm4
  4359e2:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      f3 41 0f c2 e7 05    	cmpnltss&nbsp;%xmm15,%xmm4
  4359e8:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      0f 54 dc             	andps &nbsp;%xmm4,%xmm3
  4359eb:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      44 0f 28 f4          	movaps&nbsp;%xmm4,%xmm14
  4359ef:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      0f 54 cc             	andps &nbsp;%xmm4,%xmm1
  4359f2:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      0f 55 e2             	andnps&nbsp;%xmm2,%xmm4
  4359f5:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      45 0f 55 f4          	andnps&nbsp;%xmm12,%xmm14
  4359f9:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      66 0f ef d2          	pxor  &nbsp;%xmm2,%xmm2
  4359fd:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      0f 56 cc             	orps  &nbsp;%xmm4,%xmm1
  435a00:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      66 0f ef e4          	pxor  &nbsp;%xmm4,%xmm4
  435a04:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      41 0f 56 de          	orps  &nbsp;%xmm14,%xmm3
  435a08:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      f2 41 0f 5a d2       	cvtsd2ss&nbsp;%xmm10,%xmm2
  435a0d:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      f2 41 0f 5a e3       	cvtsd2ss&nbsp;%xmm11,%xmm4
  435a12:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      f3 44 0f 10 5c 24 0c 	movss  0xc(%rsp),%xmm11
  435a19:	|  |  |  |        |  |  |  |  |  |  |        |     |     |      44 0f 2f d8          	comiss&nbsp;%xmm0,%xmm11
  435a1d:	|  |  |  |  /-----|--|--|--|--|--|--|--------|-----|-----|----- 0f 82 ed 01 00 00    	jb     435c10 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x3e0&gt;
  435a23:	|  |  |  |  |     |  |  |  |  |  |  |        |     |     |      f3 44 0f 10 54 24 08 	movss  0x8(%rsp),%xmm10
  435a2a:	|  |  |  |  |     |  |  |  |  |  |  |        |     |     |      f3 41 0f 5c d2       	subss &nbsp;%xmm10,%xmm2
  435a2f:	|  |  |  |  |     |  |  |  |  |  |  |        |     |     |      f3 41 0f 5c e2       	subss &nbsp;%xmm10,%xmm4
  435a34:	|  |  |  |  |     |  |  |  |  |  |  |        |     |     |      44 0f 28 e2          	movaps&nbsp;%xmm2,%xmm12
  435a38:	|  |  |  |  |     |  |  |  |  |  |  |        |     |     |      41 0f 28 d3          	movaps&nbsp;%xmm11,%xmm2
  435a3c:	|  |  |  |  |  /--|--|--|--|--|--|--|--------|-----|-----|----&gt; f3 41 0f 59 e5       	mulss &nbsp;%xmm13,%xmm4
  435a41:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      45 31 f6             	xor   &nbsp;%r14d,%r14d
  435a44:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      f3 0f 59 ea          	mulss &nbsp;%xmm2,%xmm5
  435a48:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      0f 2f e5             	comiss&nbsp;%xmm5,%xmm4
  435a4b:	|  |  |  |  |  |  +--|--|--|--|--|--|--------|-----|-----|----- 72 13                	jb     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  435a4d:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      f3 41 0f 59 dc       	mulss &nbsp;%xmm12,%xmm3
  435a52:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      f3 0f 59 ca          	mulss &nbsp;%xmm2,%xmm1
  435a56:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      0f 2f cb             	comiss&nbsp;%xmm3,%xmm1
  435a59:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      41 0f 93 c6          	setae &nbsp;%r14b
  435a5d:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      0f 1f 00             	nopl   (%rax)
  435a60:	|  |  |  |  |  |  &gt;--|--|--|--|--|--|--------|-----|-----|----&gt; 44 88 32             	mov   &nbsp;%r14b,(%rdx)
  435a63:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      48 83 c2 01          	add    $0x1,%rdx
  435a67:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      48 83 c0 38          	add    $0x38,%rax
  435a6b:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     |      49 39 d0             	cmp   &nbsp;%rdx,%r8
  435a6e:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |     \----- 0f 85 78 fe ff ff    	jne    4358ec &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0xbc&gt;
  435a74:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |            49 89 de             	mov   &nbsp;%rbx,%r14
  435a77:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |            49 c1 ee 02          	shr    $0x2,%r14
  435a7b:	|  |  |  |  |  |  |  |  |  |  |  |  |        |     |            80 7c 24 1c 00       	cmpb   $0x0,0x1c(%rsp)
  435a80:	|  |  |  |  |  |  |  |  |  |  |  |  |        |  /--|----------- 0f 85 5a 01 00 00    	jne    435be0 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x3b0&gt;
  435a86:	|  |  |  |  |  |  |  |  |  |  |  |  |        |  |  |            80 7c 24 1d 00       	cmpb   $0x0,0x1d(%rsp)
  435a8b:	|  |  |  |  |  |  |  |  |  |  |  |  |  /-----|--|--|----------- 0f 85 1f 01 00 00    	jne    435bb0 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x380&gt;
  435a91:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  /--|--|--|----------&gt; 80 7c 24 1e 00       	cmpb   $0x0,0x1e(%rsp)
  435a96:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  /-------- 0f 85 dc 00 00 00    	jne    435b78 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x348&gt;
  435a9c:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  /----&gt; 80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
  435aa1:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  /-- 0f 85 b9 00 00 00    	jne    435b60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x330&gt;
  435aa7:	&gt;--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|-&gt; 48 83 c4 50          	add    $0x50,%rsp
  435aab:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   5b                   	pop   &nbsp;%rbx
  435aac:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   5d                   	pop   &nbsp;%rbp
  435aad:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   41 5c                	pop   &nbsp;%r12
  435aaf:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   41 5d                	pop   &nbsp;%r13
  435ab1:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   41 5e                	pop   &nbsp;%r14
  435ab3:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   c3                   	retq
  435ab4:	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   0f 1f 40 00          	nopl   0x0(%rax)
  435ab8:	|  |  |  |  |  |  |  |  |  \--|--|--|--|--|--|--|--|--|--|--|-&gt; 0f 28 ee             	movaps&nbsp;%xmm6,%xmm5
  435abb:	|  |  |  |  |  |  |  |  |     |  |  |  |  |  |  |  |  |  |  |   f3 0f 5c e9          	subss &nbsp;%xmm1,%xmm5
  435abf:	|  |  |  |  |  |  |  |  |     |  |  |  |  |  |  |  |  |  |  |   0f 28 ce             	movaps&nbsp;%xmm6,%xmm1
  435ac2:	|  |  |  |  |  |  |  |  |     |  |  |  |  |  |  |  |  |  |  |   f3 0f 5c cb          	subss &nbsp;%xmm3,%xmm1
  435ac6:	|  |  |  |  |  |  |  |  |     |  |  |  |  |  |  |  |  |  |  |   66 0f 6e d9          	movd  &nbsp;%ecx,%xmm3
  435aca:	|  |  |  |  |  |  |  |  |     \--|--|--|--|--|--|--|--|--|--|-- e9 5b fe ff ff       	jmpq   43592a &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0xfa&gt;
  435acf:	|  |  |  |  |  |  |  |  |        |  |  |  |  |  |  |  |  |  |   90                   	nop
  435ad0:	|  |  |  |  |  |  |  |  |        |  |  |  |  \--|--|--|--|--|-&gt; 0f 28 e3             	movaps&nbsp;%xmm3,%xmm4
  435ad3:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   44 0f 28 ed          	movaps&nbsp;%xmm5,%xmm13
  435ad7:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   45 31 f6             	xor   &nbsp;%r14d,%r14d
  435ada:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   f3 0f 59 e2          	mulss &nbsp;%xmm2,%xmm4
  435ade:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   f3 45 0f 59 ec       	mulss &nbsp;%xmm12,%xmm13
  435ae3:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   f3 0f 11 24 24       	movss &nbsp;%xmm4,(%rsp)
  435ae8:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   44 0f 2f ec          	comiss&nbsp;%xmm4,%xmm13
  435aec:	|  |  |  |  |  |  +--|--|--------|--|--|--|-----|--|--|--|--|-- 0f 87 6e ff ff ff    	ja     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  435af2:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   44 0f 28 f3          	movaps&nbsp;%xmm3,%xmm14
  435af6:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   f3 45 0f 59 f7       	mulss &nbsp;%xmm15,%xmm14
  435afb:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   66 44 0f 7e f6       	movd  &nbsp;%xmm14,%esi
  435b00:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   44 0f 28 f1          	movaps&nbsp;%xmm1,%xmm14
  435b04:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   f3 45 0f 59 f4       	mulss &nbsp;%xmm12,%xmm14
  435b09:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   66 0f 6e e6          	movd  &nbsp;%esi,%xmm4
  435b0d:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   41 0f 2f e6          	comiss&nbsp;%xmm14,%xmm4
  435b11:	|  |  |  |  |  |  |  |  |        |  |  |  |     |  |  |  |  |   f3 44 0f 11 74 24 04 	movss &nbsp;%xmm14,0x4(%rsp)
  435b18:	|  |  |  |  |  |  \--|--|--------|--|--|--|-----|--|--|--|--|-- 0f 87 42 ff ff ff    	ja     435a60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x230&gt;
  435b1e:	|  |  |  |  |  |     |  |        |  |  |  |     |  |  |  |  |   66 44 0f 6e f6       	movd  &nbsp;%esi,%xmm14
  435b23:	|  |  |  |  |  |     |  |        |  |  |  |     |  |  |  |  |   45 0f 2f f5          	comiss&nbsp;%xmm13,%xmm14
  435b27:	|  |  |  |  |  |     |  |        |  |  |  |     |  \--|--|--|-- 0f 86 a5 fe ff ff    	jbe    4359d2 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x1a2&gt;
  435b2d:	|  |  |  |  |  |     |  |        +--|--|--|-----|-----|--|--|-- eb 21                	jmp    435b50 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x320&gt;
  435b2f:	|  |  |  |  |  |     |  |        |  |  |  |     |     |  |  |   90                   	nop
  435b30:	|  |  |  |  |  |     \--|--------|--|--|--|-----|-----|--|--|-&gt; 45 0f 28 f8          	movaps&nbsp;%xmm8,%xmm15
  435b34:	|  |  |  |  |  |        |        |  |  |  |     |     |  |  |   66 45 0f 6e e2       	movd  &nbsp;%r10d,%xmm12
  435b39:	|  |  |  |  |  |        |        |  |  |  |     |     |  |  |   f3 44 0f 5c fa       	subss &nbsp;%xmm2,%xmm15
  435b3e:	|  |  |  |  |  |        |        |  |  |  |     |     |  |  |   41 0f 28 d0          	movaps&nbsp;%xmm8,%xmm2
  435b42:	|  |  |  |  |  |        |        |  |  |  |     |     |  |  |   f3 0f 5c d4          	subss &nbsp;%xmm4,%xmm2
  435b46:	|  |  |  |  |  |        \--------|--|--|--|-----|-----|--|--|-- e9 1f fe ff ff       	jmpq   43596a &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x13a&gt;
  435b4b:	|  |  |  |  |  |                 |  |  |  |     |     |  |  |   0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  435b50:	|  |  |  |  |  |                 \--|--|--|-----|-----|--|--|-&gt; 41 0f 28 ef          	movaps&nbsp;%xmm15,%xmm5
  435b54:	|  |  |  |  |  |                    |  |  |     |     |  |  |   45 0f 28 ec          	movaps&nbsp;%xmm12,%xmm13
  435b58:	|  |  |  |  |  |                    \--|--|-----|-----|--|--|-- e9 79 fe ff ff       	jmpq   4359d6 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x1a6&gt;
  435b5d:	|  |  |  |  |  |                       |  |     |     |  |  |   0f 1f 00             	nopl   (%rax)
  435b60:	|  |  |  |  |  |                       |  |     |     |  |  &gt;-&gt; 4d 8b 64 24 30       	mov    0x30(%r12),%r12
  435b65:	|  |  |  |  |  |                       |  |     |     |  |  |   4c 89 f3             	mov   &nbsp;%r14,%rbx
  435b68:	|  |  |  |  |  |                       |  |     |     |  |  |   49 81 c4 a8 00 00 00 	add    $0xa8,%r12
  435b6f:	|  |  |  \--|--|-----------------------|--|-----|-----|--|--|-- e9 d4 fc ff ff       	jmpq   435848 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x18&gt;
  435b74:	|  |  |     |  |                       |  |     |     |  |  |   0f 1f 40 00          	nopl   0x0(%rax)
  435b78:	|  |  |     |  |                       |  |     |     &gt;--|--|-&gt; 83 e3 03             	and    $0x3,%ebx
  435b7b:	|  |  |     |  |                       |  |     |     |  |  |   49 8b 44 24 30       	mov    0x30(%r12),%rax
  435b80:	|  |  |     |  |                       |  |     |     |  |  |   31 c9                	xor   &nbsp;%ecx,%ecx
  435b82:	|  |  |     |  |                       |  |     |     |  |  |   4c 89 ea             	mov   &nbsp;%r13,%rdx
  435b85:	|  |  |     |  |                       |  |     |     |  |  |   48 83 fb 02          	cmp    $0x2,%rbx
  435b89:	|  |  |     |  |                       |  |     |     |  |  |   48 89 ee             	mov   &nbsp;%rbp,%rsi
  435b8c:	|  |  |     |  |                       |  |     |     |  |  |   0f 97 c1             	seta  &nbsp;%cl
  435b8f:	|  |  |     |  |                       |  |     |     |  |  |   48 8d 78 70          	lea    0x70(%rax),%rdi
  435b93:	|  |  |     |  |                       |  |     |     |  |  |   4c 01 f1             	add   &nbsp;%r14,%rcx
  435b96:	|  |  +-----|--|-----------------------|--|-----|-----|--|--|-- e8 95 fc ff ff       	callq  435830 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const&gt;
  435b9b:	|  |  |     |  |                       |  |     |     |  |  |   80 7c 24 1f 00       	cmpb   $0x0,0x1f(%rsp)
  435ba0:	+--|--|-----|--|-----------------------|--|-----|-----|--|--|-- 0f 84 01 ff ff ff    	je     435aa7 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x277&gt;
  435ba6:	|  |  |     |  |                       |  |     |     |  |  \-- eb b8                	jmp    435b60 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x330&gt;
  435ba8:	|  |  |     |  |                       |  |     |     |  |      0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  435baf:	|  |  |     |  |                       |  |     |     |  |      00
  435bb0:	|  |  |     |  |                       &gt;--|-----|-----|--|----&gt; 48 89 d9             	mov   &nbsp;%rbx,%rcx
  435bb3:	|  |  |     |  |                       |  |     |     |  |      49 8b 44 24 30       	mov    0x30(%r12),%rax
  435bb8:	|  |  |     |  |                       |  |     |     |  |      4c 89 ea             	mov   &nbsp;%r13,%rdx
  435bbb:	|  |  |     |  |                       |  |     |     |  |      48 89 ee             	mov   &nbsp;%rbp,%rsi
  435bbe:	|  |  |     |  |                       |  |     |     |  |      48 d1 e9             	shr   &nbsp;%rcx
  435bc1:	|  |  |     |  |                       |  |     |     |  |      83 e1 01             	and    $0x1,%ecx
  435bc4:	|  |  |     |  |                       |  |     |     |  |      48 8d 78 38          	lea    0x38(%rax),%rdi
  435bc8:	|  |  |     |  |                       |  |     |     |  |      4c 01 f1             	add   &nbsp;%r14,%rcx
  435bcb:	|  |  +-----|--|-----------------------|--|-----|-----|--|----- e8 60 fc ff ff       	callq  435830 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const&gt;
  435bd0:	|  |  |     |  |                       |  |     |     |  |      80 7c 24 1e 00       	cmpb   $0x0,0x1e(%rsp)
  435bd5:	|  |  |     |  |                       |  |     |     |  \----- 0f 84 c1 fe ff ff    	je     435a9c &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x26c&gt;
  435bdb:	|  |  |     |  |                       |  |     |     \-------- eb 9b                	jmp    435b78 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x348&gt;
  435bdd:	|  |  |     |  |                       |  |     |               0f 1f 00             	nopl   (%rax)
  435be0:	|  |  |     |  |                       |  |     \-------------&gt; 48 89 d8             	mov   &nbsp;%rbx,%rax
  435be3:	|  |  |     |  |                       |  |                     4c 89 f1             	mov   &nbsp;%r14,%rcx
  435be6:	|  |  |     |  |                       |  |                     4c 89 ea             	mov   &nbsp;%r13,%rdx
  435be9:	|  |  |     |  |                       |  |                     48 89 ee             	mov   &nbsp;%rbp,%rsi
  435bec:	|  |  |     |  |                       |  |                     83 e0 03             	and    $0x3,%eax
  435bef:	|  |  |     |  |                       |  |                     48 83 f8 01          	cmp    $0x1,%rax
  435bf3:	|  |  |     |  |                       |  |                     48 83 d9 ff          	sbb    $0xffffffffffffffff,%rcx
  435bf7:	|  |  \-----|--|-----------------------|--|-------------------- e8 34 fc ff ff       	callq  435830 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const&gt;
  435bfc:	|  |        |  |                       |  |                     80 7c 24 1d 00       	cmpb   $0x0,0x1d(%rsp)
  435c01:	|  |        |  |                       |  \-------------------- 0f 84 8a fe ff ff    	je     435a91 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x261&gt;
  435c07:	|  |        |  |                       \----------------------- eb a7                	jmp    435bb0 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x380&gt;
  435c09:	|  |        |  |                                                0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  435c10:	|  |        \--|----------------------------------------------&gt; f3 44 0f 10 7c 24 08 	movss  0x8(%rsp),%xmm15
  435c17:	|  |           |                                                45 0f 28 e7          	movaps&nbsp;%xmm15,%xmm12
  435c1b:	|  |           |                                                f3 44 0f 5c e4       	subss &nbsp;%xmm4,%xmm12
  435c20:	|  |           |                                                41 0f 28 e7          	movaps&nbsp;%xmm15,%xmm4
  435c24:	|  |           |                                                f3 0f 5c e2          	subss &nbsp;%xmm2,%xmm4
  435c28:	|  |           |                                                66 41 0f 6e d3       	movd  &nbsp;%r11d,%xmm2
  435c2d:	|  |           \----------------------------------------------- e9 0a fe ff ff       	jmpq   435a3c &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x20c&gt;
  435c32:	|  |                                                            66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  435c38:	|  \----------------------------------------------------------&gt; 48 8b 07             	mov    (%rdi),%rax
  435c3b:	|                                                               48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
  435c40:	|                                                               48 8b 00             	mov    (%rax),%rax
  435c43:	|                                                               48 8b 10             	mov    (%rax),%rdx
  435c46:	|                                                               48 8b 48 08          	mov    0x8(%rax),%rcx
  435c4a:	|                                                               48 8b 40 18          	mov    0x18(%rax),%rax
  435c4e:	|                                                               48 8b 49 18          	mov    0x18(%rcx),%rcx
  435c52:	|                                                               48 8b 52 18          	mov    0x18(%rdx),%rdx
  435c56:	|                                                               48 8b 70 08          	mov    0x8(%rax),%rsi
  435c5a:	|                                                               8b 40 10             	mov    0x10(%rax),%eax
  435c5d:	|                                                               48 89 74 24 20       	mov   &nbsp;%rsi,0x20(%rsp)
  435c62:	|                                                               48 89 ee             	mov   &nbsp;%rbp,%rsi
  435c65:	|                                                               89 44 24 28          	mov   &nbsp;%eax,0x28(%rsp)
  435c69:	|                                                               48 8b 41 08          	mov    0x8(%rcx),%rax
  435c6d:	|                                                               48 89 44 24 2c       	mov   &nbsp;%rax,0x2c(%rsp)
  435c72:	|                                                               8b 41 10             	mov    0x10(%rcx),%eax
  435c75:	|                                                               89 44 24 34          	mov   &nbsp;%eax,0x34(%rsp)
  435c79:	|                                                               48 8b 42 08          	mov    0x8(%rdx),%rax
  435c7d:	|                                                               48 89 44 24 38       	mov   &nbsp;%rax,0x38(%rsp)
  435c82:	|                                                               8b 42 10             	mov    0x10(%rdx),%eax
  435c85:	|                                                               89 44 24 40          	mov   &nbsp;%eax,0x40(%rsp)
  435c89:	|                                                               e8 a2 77 fd ff       	callq  40d430 &lt;bool CGAL::Intersections::internal::do_intersect&lt;CGAL::Simple_cartesian&lt;float&gt; &gt;(CGAL::Simple_cartesian&lt;float&gt;::Triangle_3 const&amp;, CGAL::Simple_cartesian&lt;float&gt;::Line_3 const&amp;, CGAL::Simple_cartesian&lt;float&gt; const&amp;) [clone .isra.0]&gt;
  435c8e:	|                                                               84 c0                	test  &nbsp;%al,%al
  435c90:	+-------------------------------------------------------------- 0f 84 11 fe ff ff    	je     435aa7 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x277&gt;
  435c96:	|                                                               41 c6 45 00 01       	movb   $0x1,0x0(%r13)
  435c9b:	\-------------------------------------------------------------- e9 07 fe ff ff       	jmpq   435aa7 &lt;void CGAL::AABB_node&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt; &gt;::traversal&lt;CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;(CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; const&amp;, CGAL::internal::AABB_tree::Do_intersect_traits&lt;CGAL::AABB_traits&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::AABB_face_graph_triangle_primitive&lt;CGAL::Polyhedron_3&lt;CGAL::Simple_cartesian&lt;float&gt;, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator&lt;int&gt; &gt;, CGAL::Default, CGAL::Boolean_tag&lt;true&gt;, CGAL::Boolean_tag&lt;false&gt; &gt;, CGAL::Default&gt;, CGAL::Line_3&lt;CGAL::Simple_cartesian&lt;float&gt; &gt; &gt;&amp;, unsigned long) const+0x277&gt;

</pre><p>The issue here isn't the number of jumps though: even when the
intersection code is branchless, the compiler misses the opportunity to
unroll a loop and vectorize across the inlined functions!</p><h3><span class=mw-headline id=Benchmarking_Different_types_of_Intersections><span class=mw-headline-number>4.9.3</span> Benchmarking Different types of Intersections</span></h3><p>Pierre and I have been looking at the idea of putting a using a
bounding box (or several) around the query to speed up traversal.
This strategy could make a big difference, because CGAL's bbox-bbox
intersection doesn't require any special care to preserve exactness;
it's algorithmically simpler, and it is far more readily compatible with
SIMD techniques.
The hope is that we can get some performance advantage by not doing
intersections directly with the query until it's absolutely necessary.</p><p>We can get an idea of how big the performance advantage could be
by examining the time it takes to perform different types of
intersections.
A boxed-query approach would replace ray-bbox intersections with simpler
but broader bbox-bbox intersections.
This means we may intersect with more nodes, but each individual
intersection computation will be cheaper.
Pierre's intuition was that bbox-bbox intersections should be at least
10x faster than ray-bbox intersections, and perhaps 100x faster than
intersections with primitives.
To find real-life numbers for these, I created <a rel=nofollow class="external text" href=https://github.com/CGAL/cgal-public-dev/blob/gsoc2021-simd-campolattaro/_simd-experiments/cgal-intersections-benchmark/main.cpp>a
simple benchmark</a>
of the different intersections.
This benchmark tested intersections between 1,000 of the query type and
10,000 of the target type, repeated 100 times with interleaved runs as
usual.
The total test takes a couple of minutes to run, but I divided by the
total number of intersections to get the time for just one.</p><table class=wikitable><caption>Time required to check for intersections between different types</caption><tbody><tr><th>Intersection Type</th><th>Time per Intersection (s)</th></tr><tr><td>Bbox-Bbox</td><td>2.5e-14</td></tr><tr><td>Ray-Bbox</td><td>1.34778e-08</td></tr><tr><td>Ray-Triangle</td><td>8.25178e-08</td></tr></tbody></table><p>Rather than 10x faster than ray-bbox intersections, bbox-bbox
intersections were more than 500,000x faster!
The difference likely won't be quite as spectacular in a real context
(in the tree the more expensive part is probably chasing pointers), but
these results make me pretty optimistic that we can get a performance
improvement!</p><h3><span class=mw-headline id=Implementing_a_simple_Boxed_Query_technique><span class=mw-headline-number>4.9.4</span> Implementing a simple Boxed Query technique</span></h3><p>My solution for simple boxing of queries has the following features:</p><ul><li>A <code>Boxed_query&lt;Q></code> class, which contains a reference to the query object and a
bounding box that encloses it.</li><li>A constructor for the Boxed query which takes a query type and an
Iso_cuboid boundary. This facilitates infinite query types like rays,
cutting them at the border so that they can have a finite bounding box.
(There's also a simpler constructor for non-infinite types)</li><li>A custom <code>CGAL::do_intersect</code> function which tries to
rule out the possibility of an intersection using the bounding box, only
falling back to direct intersection with the query if it's necessary.</li></ul><p>While I was developing this, I modified the benchmarking code to save
the boolean results of the intersections to an output vector.
This let me guarantee that the results were correct, but it also
massively hurt performance.</p><table class=wikitable><caption>Time required to check for intersections between different types</caption><tbody><tr><th>Intersection Type</th><th>Time per Intersection (s)</th></tr><tr><td>Bbox-Bbox</td><td>3.54384e-09</td></tr><tr><td>Ray-Bbox</td><td>2.71308e-08</td></tr><tr><td>Boxed-Ray-Bbox</td><td>2.08792e-08</td></tr></tbody></table><p>This is promising!
The boxed method is nearly 10x slower than plain box-box intersection,
which makes sense because its time is likely dominated by the cases
where it needs to fall back to ray intersection.
Nevertheless, it still beats plain ray-box intersection, while providing
equivalent functionality.
This test includes the overhead of constructing the boxed query for
every ray being intersected; this is actually rather expensive (it uses a
boolean operation with an Iso_cuboid);
a more effective method of cutting the infinite query type could result
in a further performance advantage.</p><p>Removing the validation step makes the advantages a little bit more clear,
with this change the boxed-ray beats the conventional method by more than 25%!</p><table class=wikitable><caption>Time required to check for intersections between different types</caption><tbody><tr><th>Intersection Type</th><th>Time per Intersection (s)</th></tr><tr><td>Bbox-Bbox</td><td>3.6e-14</td></tr><tr><td>Ray-Bbox</td><td>2.24505e-08</td></tr><tr><td>Boxed-Ray-Bbox</td><td>1.80355e-08</td></tr></tbody></table><p>Notice how bbox-bbox intersection was impacted the most by
validation.
This is likely in part because it's a small function that can be
vectorized well by the compiler;
adding the result to a vector after each invocation of the function
almost certainly interferes with vectorization between function calls.
Even without that factor, its time was dominated by the overhead of
saving the result.</p><h2><span class=mw-headline id=July_25_-_August_2><span class=mw-headline-number>4.10</span> July 25 - August 2</span></h2><h3><span class=mw-headline id=Using_Boxed_Queries_to_Traverse_the_Tree><span class=mw-headline-number>4.10.1</span> Using Boxed Queries to Traverse the Tree</span></h3><p>With the performance potential confirmed, it made sense to try to take advantage of boxed queries
when traversing the tree.</p><h4><span class=mw-headline id=Specialized_Traversal_Function><span class=mw-headline-number>4.10.1.1</span> Specialized Traversal Function</span></h4><p>The core of this strategy is a new template specialization for the
traversal function, so that we can treat boxed queries specially.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> Tr<span class=sy1>&gt;</span>
<span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>class</span> Traversal_traits, <span class=kw2>class</span> Query<span class=sy1>&gt;</span>
<span class=kw4>void</span>
AABB_node<span class=sy1>&lt;</span>Tr<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>traversal</span><span class=br0>(</span><span class=kw4>const</span> Boxed_query<span class=sy1>&lt;</span>Query<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>boxed_query,
                         Traversal_traits <span class=sy3>&amp;</span>traits,
                         <span class=kw4>const</span> std<span class=sy4>::</span><span class=kw4>size_t</span> nb_primitives<span class=br0>)</span> <span class=kw4>const</span><span class=sy4>;</span></pre></div></div><p>For our first prototype, we wanted to traverse with a single bbox
surrounding the query.
This bbox is reconstructed for each sub-node, because it only needs to
surround the region of the query that falls within that node's own box.
If we tried to use the same node for the entire depth of the traversal,
it would quickly become much larger than the boxes it's being tested
against.</p><p>Our specialization of the traversal function builds the new box for each child before it recursively
traverses them,
it also performs an intersection directly using the contained query directly once it reaches a
primitive.</p><h4><span class=mw-headline id=Invalidating_Traversal_Traits_Assumptions><span class=mw-headline-number>4.10.1.2</span> Invalidating Traversal Traits Assumptions</span></h4><p>When I tried to directly intersect the query and the primitive in the base case of the traversal, I
ran into a small snag.</p><p>The AABB_traversal_traits classes each provide two functions:
<code>bool do_intersect(const Query& query, const Node& node)</code> for intersections with
each child when determining whether to traverse recursively,
and <code>void intersection(const Query& query, const Primitive& primitive)</code> for
direct intersections with primitives (the traits class is responsible for collecting the results).
The <code>Query</code> type is a template of the traits class, and that
comes with the implicit assumption that the type will be the same for
both types of intersections provided.
Since we want to intersect directly using <code>Boxed_query</code>'s underlying query type when we
reach a primitive, this assumption no longer holds.
As a temporary solution, these two functions are independently templated, with names <code>DoIntersectQuery</code>
and <code>IntersectionQuery</code>, respectively.
This shouldn't have any performance penalty, but it does cut against the grain of the Traits
system's original design;
eventually I think it's important to find a cleaner solution.</p><h3><span class=mw-headline id=Issues_with_Traversal_Correctness><span class=mw-headline-number>4.10.2</span> Issues with Traversal Correctness</span></h3><p>Even with careful checking of the algorithm, the boxed query
traversal was producing different results than the original "naive"
solution.
It consistently detected fewer intersections (6,114 vs 6,708, for
example).
I was unable to eliminate this issue without also taking away any
performance advantage of the approach.
One solution was to use a pessimized version of the algorithm:
rather than assuming if the box doesn't intersect than its contained
primitive must not,
we can assume that if the box does intersect, so must its contained
query (and if the box doesn't, try the query directly just in case).
This is obviously wasteful, resulting in examining many more nodes than
should be necessary,
but it does guarantee that all intersections are found, producing the
correct result.</p><p>Tracking these errors revealed that the missed intersections
stemmed from "false negatives" when using the bbox as a filter for
intersections between queries and bboxes.
Examining the problematic scenarios showed that malformed boxes were not
properly surrounding the underlying queries.
This points to an issue in the <code>Boxed_query</code> constructor.</p><p>Pierre and I had a discussion, and our conclusion was that the <a rel=nofollow class="external text" href=https://doc.cgal.org/latest/Kernel_23/group__intersection__linear__grp.html>Intersection</a>
system (doing the boolean operation between query and bbox)
wasn't producing a conservative result because the kernel was inexact.
For near-tangential intersections (where the ray query barely skims the
surface of the bbox) the errors produced can become very pronounced.
As a temporary solution, I'm testing whether using an exact construction
kernel (Epec) will prevent these issues.
If I get correct results with the Epec kernel, that means that this
problem can be solved by creating a more conservative approach for
putting a bbox around the query.</p><h4><span class=mw-headline id=Compatibility_with_Epeck><span class=mw-headline-number>4.10.2.1</span> Compatibility with Epeck</span></h4><p>Getting the boxed query system working with Epeck was more challenging than expected.
Introducing it as another test case to the <code>any_all_benchmark</code> caused a wave of template
errors;
which surprised me because I had expected it to have an identical interface to the other kernels.
Fixing the issues helped me discover and eliminate an unnecessary special case leftover from the old
code,
and it ensured that all treatments of the boxed_query are done where I expect (before I had relied
on a custom cast operator).</p><p>Once Epeck was working, I was able to confirm that it always produced correct results.
This means that our issue must stem from the query boxing approach not being conservative, as we
thought.</p><h3><span class=mw-headline id=Interval-based_Boxing><span class=mw-headline-number>4.10.3</span> Interval-based Boxing</span></h3><p>After some experimentation with template specializations for lines and rays,
I found that the simplest approach for adapting the existing boxing system was to use CGAL's kernel
converter type.
This let me make very few changes to the existing code, and preserve compatibility with the same
range of Query types.</p><p>I eventually found that using <code>Interval_nt&lt;false></code> instead of <code>Interval_nt&lt;true></code>
made a massive performance difference.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>typedef</span> Simple_cartesian<span class=sy1>&lt;</span>Interval_nt<span class=sy1>&lt;</span><span class=kw2>false</span><span class=sy1>&gt;&gt;</span> Interval_kernel<span class=sy4>;</span>
<span class=kw4>typedef</span> <span class=kw2>typename</span> Kernel_traits<span class=sy1>&lt;</span>Query<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>Kernel</span> Query_kernel<span class=sy4>;</span>
<span class=kw4>typedef</span> <span class=kw2>typename</span> Type_mapper<span class=sy1>&lt;</span>Query, Query_kernel, Interval_kernel<span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>type</span> Interval_query<span class=sy4>;</span>
<span class=kw4>typedef</span> Cartesian_converter<span class=sy1>&lt;</span>Query_kernel, Interval_kernel<span class=sy1>&gt;</span> Converter_K_to_Interval<span class=sy4>;</span>
&nbsp;
...
&nbsp;
&nbsp;
<span class=me1>Converter_K_to_Interval</span> K_to_Interval<span class=sy4>;</span>
interval_query <span class=sy1>=</span> K_to_Interval<span class=br0>(</span>query<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
...
&nbsp;
<span class=kw4>static</span> Bbox_3 bbox_for_enclosed_segment<span class=br0>(</span><span class=kw4>const</span> Interval_query <span class=sy3>&amp;</span>query, <span class=kw4>const</span> Bbox_3 <span class=sy3>&amp;</span>boundary<span class=br0>)</span> <span class=br0>{</span>
      Interval_nt<span class=sy1>&lt;</span><span class=kw2>false</span><span class=sy1>&gt;</span><span class=sy4>::</span><span class=me2>Protector</span> p<span class=sy4>;</span>
&nbsp;
      <span class=kw4>auto</span> b <span class=sy1>=</span> Iso_cuboid_3<span class=sy1>&lt;</span>Interval_kernel<span class=sy1>&gt;</span><span class=br0>(</span>boundary<span class=br0>)</span><span class=sy4>;</span>
      <span class=kw4>auto</span> overlap <span class=sy1>=</span> CGAL<span class=sy4>::</span><span class=me2>intersection</span><span class=br0>(</span>query, b<span class=br0>)</span><span class=sy4>;</span>
&nbsp;
      <span class=co1>// If there wasn't any overlap, return an empty bounding box</span>
      <span class=kw1>if</span> <span class=br0>(</span><span class=sy3>!</span>overlap<span class=br0>)</span>
        <span class=kw1>return</span> Bbox_3<span class=br0>{</span><span class=br0>}</span><span class=sy4>;</span>
&nbsp;
      <span class=co1>// Otherwise, get the bounding box of the result</span>
      <span class=kw1>return</span> boost<span class=sy4>::</span><span class=me2>apply_visitor</span><span class=br0>(</span><span class=br0>[</span><span class=br0>]</span><span class=br0>(</span><span class=kw4>auto</span> <span class=sy3>&amp;&amp;</span>boolean_intersection_result<span class=br0>)</span> <span class=sy2>-</span><span class=sy1>&gt;</span> Bbox_3 <span class=br0>{</span>
        <span class=kw1>return</span> boolean_intersection_result.<span class=me1>bbox</span><span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
      <span class=br0>}</span>, <span class=sy2>*</span>overlap<span class=br0>)</span><span class=sy4>;</span>
    <span class=br0>}</span></pre></div></div><p>This allowed for full correctness, but came with a massive performance penalty.
Creating a conservative bbox is a very expensive process, and it eliminated the advantage that the
boxing strategy had.</p><h4><span class=mw-headline id=Performance_Results><span class=mw-headline-number>4.10.3.1</span> Performance Results</span></h4><p>As usual, benchmarking is done with the <code>aabb_any_all_benchmark</code>.
This program builds a tree from a triangle mesh that it loads from a file,
and then generates a large number of segment, ray, and line queries which it casts into the tree.</p><p>Results were disappointing, with a decrease in performance for all kernels.</p><table class=wikitable><caption>Performance of a Simple Query-boxing Strategy, using Interval-math to Ensure Correctness</caption><tbody><tr><th>Kernel</th><th>Naive</th><th>Boxed</th></tr><tr><td>Simple cartesian float kernel</td><td>0.571318</td><td>1.39495</td></tr><tr><td>Cartesian float kernel</td><td>0.896336</td><td>1.51499</td></tr><tr><td>Simple cartesian double kernel</td><td>0.497932</td><td>1.32457</td></tr><tr><td>Cartesian double kernel</td><td>0.834149</td><td>1.45415</td></tr><tr><td>Epic kernel</td><td>1.1171</td><td>1.47604</td></tr><tr><td>Epec kernel</td><td>1.44885</td><td>1.74818</td></tr></tbody></table><p>Clearly it's expensive to create these bounding boxes with full
correctness, so we'll need to employ a more elaborate strategy to reduce
the time we spend on that problem.
I think we have two sides to approach that problem from:</p><ul><li>Reduce how expensive it is to create these bounding boxes (e.g. a
simpler function to create conservative boxes using interval arithmetic)</li><li>Reduce how often we need to compute them (e.g. only put a new box
around the query when the current box stops being useful for filtering,
instead of every time we descend the tree)</li></ul><p>Of these options, I believe that the second has more promise.
Ultimately, creating a conservative bounding box can only be optimized
by a certain amount, especially while retaining our genericity.</p><table><tbody><tr><td><i><b>For future sections, statements on performance will focus on the Epic kernel
results.</b></i><br><p><i>The Epic kernel is the most likely to see a useful improvement, because it has the
most expensive ray-bbox intersections.</i></p></td></tr></tbody></table><h3><span class=mw-headline id=Tunable_Parameters><span class=mw-headline-number>4.10.4</span> Tunable Parameters</span></h3><p>During a pair programming session, Andreas and I explored several avenues for improving our
performance.
We identified a collection of parameters that could be tuned to improve our results.</p><p>In the following table, all variations not listed in (parentheses) have been built and benchmarked.
Each is discussed in more detail below.</p><table class=wikitable><caption>Tunable Parameters</caption><tbody><tr><th scope=row style=width:10%>Conditional Shrinking</th><td><ul><li>Never shrink</li><li>Always shrink</li><li>Shrink only when box intersects with all children's boxes</li><li>(Shrink only when box is larger than children's boxes)</li></ul></td></tr><tr><th scope=row>BBox Count</th><td>1, 2, 4, (N)</td></tr><tr><th scope=row>Children per Tree-node</th><td>1, 2, 4, 8, (N)</td></tr><tr><th scope=row>Trust in the Filter</th><td><ul><li>Fall-back to direct query-bbox intersections if the box intersects</li><li>Never fall back to query-bbox intersections</li></ul></td></tr></tbody></table><p>Including the naive approach, we have a total of 73 different combinations of optimizations.</p><p>We didn't do a grid-search of the parameters, but as we
implemented the different optimizations we tested a variety of
combinations.
Some of the parameters have independent affects on performance, but
others depend strongly on what other optimization are active.</p><h4><span class=mw-headline id=Conditional_Shrinking><span class=mw-headline-number>4.10.4.1</span> Conditional Shrinking</span></h4><p>This parameter determines when we create a new bounding box for our boxed query.
This is important because it effects two opposing aspects of our performance:</p><ul><li>It can increase or decrease how often the <code>bbox_for_enclosed_segment</code> function is
invoked, an operation we've determined to be very expensive.</li><li>It can decrease or increase how tightly the bbox encloses the
underlying query, which affects how many nodes we end up visiting.</li></ul><p>We applied three different approaches, but also discussed the possibility of others.</p><p><b>Never Shrink</b></p><p>Here, we build the Boxed_query at the start of the traversal and then never update it again.
This has the advantage of rarely requiring building a new bbox,
but it means that the bbox will dwarf the node's boxes as we get deeper in the tree.
The result was that the enclosing box quickly becomes useless, and overall it detracted from
performance.</p><p><b>Always Shrink</b></p><p>This is on the opposite end of the spectrum.
For this strategy, we create a new (smaller) bbox each time we descend the tree into a child.
This ensures that the box always fits the query as tightly as possible, but it means that <code>bbox_for_enclosed_segment</code>
is used constantly.
It does better than never shrinking, but not particularly well.</p><p><b>Shrink when all Children Intersect</b></p><p>This strategy falls between the other two.
It uses a heuristic to determine whether the box needs to be made smaller.
We discussed several heuristics, but the only one implemented depends on intersections with child
nodes.
If the current box intersected with all the child nodes, then it might be too big (it's large enough
to touch them all).
When this happens, we shrink the box and continue traversing the tree.</p><h4><span class=mw-headline id=Multi-BBox><span class=mw-headline-number>4.10.4.2</span> Multi-BBox</span></h4><p>By using more than one box to wrap the primitive, we may be able to get an unintuitively large
performance advantage.
This is because of some nonlinearities in the way that costs and benefits scale as the number of
bboxes scale:</p><ul><li>Using two boxes to surround a segment instead of one reduces the
total combined volume, since the boxes can be smaller. Importantly, the
new boxes aren't just 1/2 the total volume -- they're 1/4 the size.</li><li>Creating two boxes instead of one is less than twice as expensive.
Getting the start and end points requires the expensive boolean
intersection operation, but to create two boxes we only need one more
point in between, which can be found using a relatively inexpensive <code>midpoint()</code>
operation.</li></ul><p><b>1 Box</b></p><p>If we use only one BBox but shrink it for each child, it's already relatively effective at wrapping
the query.
Using CGAL's profiling utility we were able to determine that it eliminated around 25% of direct
query-bbox intersection.
This represents a sizeable reduction in the number of expensive intersections we need to do.</p><p><b>4 Boxes</b></p><p>Increasing the number of boxes began to run into diminishing returns.
For four boxes, we saw a reduction of around 35%.
This is good, but we were hoping that the theoretical 16x reduction in query box volume would make a
bigger difference.</p><p>We're still interested in trying larger numbers of boxes.
As the number gets higher, it may make a non-shrinking approach more viable.</p><h4><span class=mw-headline id=Children_per_node><span class=mw-headline-number>4.10.4.3</span> Children per node</span></h4><p>Increasing the number of children per node makes sense when there's
an "economy of scale" for query-bbox intersections.
We found that this wasn't the case for naive linear queries, and
increasing the width of the tree generally decreased performance.
It makes sense for Embree to use wider trees because their ray-bbox
intersection code can be vectorized, allowing them to do the extra
intersections simultaneously.
This optimization may also be applicable to our situation, but for
different reasons.</p><p><b>2 Children</b></p><p>This is the standard case, and it tended to perform the best for most configurations.</p><p><b>8 Children</b></p><p>When we use singly-boxed queries and always shrink them it tends
to be worthwhile to use wider trees.
In certain configurations, we even saw improvements in performance up to
a 12-way tree.
This makes sense, because there's a cost to shrink the bbox which is
amortized over the number of times it's used for intersections.
Just as important, a wider tree can be much shallower, which reduces the
number of times we need to shrink the box.</p><h4><span class=mw-headline id=Trust_in_the_Filter><span class=mw-headline-number>4.10.4.4</span> Trust in the Filter</span></h4><p>There is more than one way to use our boxed query's bounding box.
We have two options, with their own benefits and drawbacks.</p><p><b>Fall back to direct intersections when uncertain</b></p><p>Our original solution was to use the box as a negative filter.
This means that if the two boxes don't intersect, then it's safe to
assume that the query and the node's box don't intersect, since boxes
are drawn conservatively.
If the two boxes do intersect, we would then do (expensive) query-bbox
intersection.
The code makes use of short-circuiting logic, and looks like this:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> Query, <span class=kw2>typename</span> Other<span class=sy1>&gt;</span>
<span class=kw2>inline</span>
<span class=kw4>bool</span>
might_intersect<span class=br0>(</span><span class=kw4>const</span> Boxed_query<span class=sy1>&lt;</span>Query<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>q,
                <span class=kw4>const</span> Other <span class=sy3>&amp;</span>other<span class=br0>)</span> <span class=br0>{</span>
  <span class=kw1>return</span> CGAL<span class=sy4>::</span><span class=me2>do_intersect</span><span class=br0>(</span>q.<span class=me1>bbox</span>, other<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span>
&nbsp;
<span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> Query, <span class=kw2>typename</span> Other<span class=sy1>&gt;</span>
<span class=kw2>inline</span>
<span class=kw4>bool</span>
do_intersect<span class=br0>(</span><span class=kw4>const</span> Boxed_query<span class=sy1>&lt;</span>Query<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>q,
             <span class=kw4>const</span> Other <span class=sy3>&amp;</span>other<span class=br0>)</span> <span class=br0>{</span>
  <span class=kw1>return</span> might_intersect<span class=br0>(</span>q, other<span class=br0>)</span> <span class=sy3>&amp;&amp;</span> do_intersect<span class=br0>(</span>q.<span class=me1>query</span>, other<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div><p>This has the advantage that the boxed query's <code>do_intersect</code>
function is always guaranteed to produce the same result as directly
intersecting with the query.
This means that the traversal will visit identical nodes to the naive
solution, which is useful for testing correctness.
Not visiting additional nodes also has a theoretical performance
advantage, though it's outweighed by the cost of falling back to a
direct query-bbox intersection.</p><p><b>Always trust that bbox-bbox intersections are representative</b></p><p>I found it was better to assume all intersections between boxes correspond to real intersections with
the query.
Implementing this was done by making <code>might_intersect</code> and <code>do_intersect</code>
equivalent.</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> Query, <span class=kw2>typename</span> Other<span class=sy1>&gt;</span>
<span class=kw2>inline</span>
<span class=kw4>bool</span>
might_intersect<span class=br0>(</span><span class=kw4>const</span> Boxed_query<span class=sy1>&lt;</span>Query<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>q,
                <span class=kw4>const</span> Other <span class=sy3>&amp;</span>other<span class=br0>)</span> <span class=br0>{</span>
  <span class=kw1>return</span> CGAL<span class=sy4>::</span><span class=me2>do_intersect</span><span class=br0>(</span>q.<span class=me1>bbox</span>, other<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span>
&nbsp;
<span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> Query, <span class=kw2>typename</span> Other<span class=sy1>&gt;</span>
<span class=kw2>inline</span>
<span class=kw4>bool</span>
do_intersect<span class=br0>(</span><span class=kw4>const</span> Boxed_query<span class=sy1>&lt;</span>Query<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>q,
             <span class=kw4>const</span> Other <span class=sy3>&amp;</span>other<span class=br0>)</span> <span class=br0>{</span>
  <span class=kw1>return</span> might_intersect<span class=br0>(</span>q, other<span class=br0>)</span><span class=sy4>;</span>
<span class=br0>}</span></pre></div></div><p>Using CGAL's profiling tools, we could determine that this is because
bbox intersections are a very good predictor of real intersections.
Over 95% of the time, when the boxed query's bbox intersects with the
other node, so does the query itself!</p><p>When we approach the problem this way, we slightly increase the number of query-primitive
intersections,
that difference is vanishingly small in comparison to the number of query-bbox intersections we
save.</p><h4><span class=mw-headline id=Optimal_Results><span class=mw-headline-number>4.10.4.5</span> Optimal Results</span></h4><p>My first attempt had the following parameters:</p><ul><li>Always shrink (every time we descend the tree)</li><li>1 box wrapping the query</li><li>2-way tree</li><li>Fall back to direct query-bbox intersections when uncertain</li></ul><p>We tested a wide variety of combinations, and the best we found included the following parameters:</p><ul><li>Heuristic shrinking (only when all children intersect)</li><li>1 box wrapping the query</li><li>2-way tree</li><li>Never fall back to direct query-bbox intersections</li></ul><p>Choosing the right approaches made a significant difference to performance:</p><table class=wikitable><caption>Performance of Query-boxing strategies</caption><tbody><tr><th>Kernel</th><th>Naive</th><th>Original Boxed</th><th>Optimized Boxed</th></tr><tr><td>Simple cartesian float kernel</td><td>0.571318</td><td>1.39495</td><td>0.935523</td></tr><tr><td>Cartesian float kernel</td><td>0.896336</td><td>1.51499</td><td>1.0592</td></tr><tr><td>Simple cartesian double kernel</td><td>0.497932</td><td>1.32457</td><td>0.833513</td></tr><tr><td>Cartesian double kernel</td><td>0.834149</td><td>1.45415</td><td>1.054</td></tr><tr><td>Epic kernel</td><td>1.1171</td><td>1.47604</td><td>1.0115</td></tr><tr><td>Epec kernel</td><td>1.44885</td><td>1.74818</td><td>1.28246</td></tr></tbody></table><p>Even so, this result isn't without caveats.
The optimized box approach only beats the naive approach for
particularly heavy kernels.
This is because its value is in its reduction of heavy numerical
calculations done by the kernel.
Bbox-Bbox intersections are very cheap compared to most Epic kernel
operations, but this advantage shrinks for something like the Simple
cartesian float kernel.</p><h3><span class=mw-headline id=Only_Lines_Benefit_from_this_Optimization><span class=mw-headline-number>4.10.5</span> Only Lines Benefit from this Optimization</span></h3><p>On Andreas' suggestion, I substituted Ray queries for Lines in the benchmark,
this had a rather unfortunate effect on our performance results.</p><table class=wikitable><caption>Performance of Query-boxing strategies when Line Queries are disabled</caption><tbody><tr><th>Kernel</th><th>Naive</th><th>Optimized Boxed</th></tr><tr><td>Simple cartesian float kernel</td><td>0.613851</td><td>0.857605</td></tr><tr><td>Cartesian float kernel</td><td>0.684138</td><td>0.927448</td></tr><tr><td>Simple cartesian double kernel</td><td>0.530906</td><td>0.784656</td></tr><tr><td>Cartesian double kernel</td><td>0.626222</td><td>0.921197</td></tr><tr><td>Epic kernel</td><td>0.811094</td><td>0.897078</td></tr><tr><td>Epec kernel</td><td>1.14218</td><td>1.13796</td></tr></tbody></table><p>The boxing strategy's performance advantages evaporate, even for the complex kernels that it excelled
on!</p><p>This is likely happening because the Ray and Segment types have
cursory checks to see if their origin is inside the bbox.
This is nearly as cheap as bbox-bbox intersection, and tests showed that
it's enough to catch intersections a lot of the time (removing this
check comes with a sizeable performance penalty)
The Line type, on the other hand, is infinite and defined by a line
equation.
It has no such pre-check, and so it's more expensive on average.
Boxing helps us add an equivalent to the pre-check for infinite types
like the line, so this is where its performance benefit comes from.</p><p>This presents a problem, because the AABB is generally used for Ray and Segment queries, not lines.
This makes perfect sense, since line queries are slower without a strategy like boxing.
Our work here has identified an optimization path that helps only a small subset of use-cases.</p><h2><span class=mw-headline id=August_3_-_August_10><span class=mw-headline-number>4.11</span> August 3 - August 10</span></h2><h3><span class=mw-headline id=Feasibility_of_a_Compact_Tree_Structure><span class=mw-headline-number>4.11.1</span> Feasibility of a Compact Tree Structure</span></h3><p>Andreas and I have been discussing the possibility of accessing child nodes using pointer or index
math instead of references.
This would rely on the fact that the arrangement of the nodes in memory should be deterministic.
It comes with several advantages:</p><ul><li>More compact node type, which wouldn't have to store any pointers or references to its
children.</li><li>Easy access to both parents and children of nodes, something that
would previously have required storing an additional reference.</li><li>Better cache performance (in part because of the more compact representation, in part due to
better locality)</li></ul><p>I did some research into this type of method, and a relevant concept here is "<a rel=nofollow class="external text" href=https://en.wikipedia.org/wiki/Succinct_data_structure>succinct
data structure</a>".
An even more relevant term for what we're trying to do is <a rel=nofollow class="external text" href=https://en.wikipedia.org/wiki/Implicit_data_structure>implicit
data structure</a>.
This field of research has been around perhaps even longer than
computers have, and the topic of compact trees has been very thoroughly
explored.
The best implementation guide I found is <a rel=nofollow class="external text" href=https://hbfs.wordpress.com/2009/04/07/compact-tree-storage/>this</a>,
and it cites a paper from 1964.
Wikipedia also has <a rel=nofollow class="external text" href=https://en.wikipedia.org/wiki/Binary_tree#Arrays>its own short
description</a> of the technique.
One of the key requirements that the article lists for this type of structure is that the tree be
complete,
but the wikipedia page acknowledges that this isn't actually a strict requirement:
if we're okay with having empty nodes (gaps in our underlying vector), we can actually have any
structure we want!
Luckily, even with no changes to implementation our current construction strategy already produces
nearly-complete trees.</p><p>Of course, the advantages and simplicity of implementation lead to one question:</p><h4><span class=mw-headline id=Why_isn.27t_Embree_doing_this.3F><span class=mw-headline-number>4.11.1.1</span> Why isn't Embree doing this?</span></h4><p>Using an implicit structure has some drawbacks, most of which don't apply to CGAL at the moment,
but would if we wanted to incorporate some of Embree's techniques.</p><ul><li>Embree has a tree-building technique that's intended to produce an
optimal structure, by criteria such as total bbox surface area. This is
naturally more computationally expensive than normal construction, but
the built tree can provide faster traversal on average. The tree that's
built has no guarantees of being anywhere near complete, and if put into
an index-based implementation it may result in very large blocks of
empty memory.</li><li>Embree has strong support for dynamic trees, which can be
efficiently rebuilt as the stored primitives move around. This is useful
for Embree's main purpose, raytracing, because it makes it easy to
perform efficient traversals of a scene with moving parts. An
array-based tree is more complicated to rebuild, and may not support the
type of partial-restructuring that embree uses here.</li></ul><p>Using an index-based structure doesn't necessarily close the door to
optimizations and features like these in the future, but it would make
their implementation more challenging if CGAL wanted to incorporate them
someday.</p><h3><span class=mw-headline id=Potential_API_for_an_Implicit_Tree><span class=mw-headline-number>4.11.2</span> Potential API for an Implicit Tree</span></h3><p>There exists one major difference that means conversion to a compact representation isn't
straightforward:
<i>nodes don't know about their children without additional context about the rest of the tree.</i>
In the current tree, a node has a reference to its children which can be
followed regardless of whether this node is the root or deep inside the
tree.
For an index-based tree, the offset used to find the children's index
depends on the specific index of that node.
The root is directly adjacent to its children, but nodes deeper in the
tree will be much further from their children.
As a result, to find the location of the next child we need to know both
the location of the current child and that of the start of the tree.</p><p>My proposal to avoid making traversal much more complex is the addition of a
<code>AABB_node_handle</code> type, which would encapsulate this information.
You could use this type to produce handles for its parent and children,
and it could provide access to the underlying bbox or primitive.
It could be treated just as we do a node right now, almost as a drop-in replacement.</p><h3><span class=mw-headline id=Preparing_to_implement_Implicit_Tree_construction><span class=mw-headline-number>4.11.3</span> Preparing to implement Implicit Tree construction</span></h3><p>Development will be done on the new <a rel=nofollow class="external text" href=https://github.com/JacksonCampolattaro/cgal/tree/implicit-tree-structure>implicit-tree-structure</a>
branch.</p><h4><span class=mw-headline id=Planning_2><span class=mw-headline-number>4.11.3.1</span> Planning</span></h4><p>Conversion of the current tree to an implicit structure can be broken into steps, just as conversion
to an N-way tree was.</p><ul><li>Add reference to the tree's root as a member of the Node class; use the node's root to
determine the index of the node <code>index = this - root</code>.</li><li>Add a new child accessor which takes the node's current index as an argument <code>std::array&lt;Node,
N> &children()</code> → <code>std::array&lt;Node, N> &children(std::size_t
index)</code>. Use this accessor where the original was used, and confirm their results match
<i>for shallow nodes</i>.</li><li>Update tree's underlying vector to be large enough to hold the tree
if it isn't stored compactly (round up the size as though the tree were
perfect). Pre-allocate vector with empty nodes (nodes with empty
bboxes).</li><li>Update tree constructor to use the new index-based accessor when
determining where to allocate child nodes. (The two accessors should now
produce identical results for all nodes, since the new one is
determining the references stored for the old system).</li><li>Use <code>boost::variant</code> to allow the node type to hold
either a bbox or a reference to a primitive. The old child pointer
should now be used for exclusively that purpose.</li><li>Remove the old child pointer (along with correctness check). Node
type should now only contain a bbox and a reference to the root.</li><li>Construct-on-access of child nodes: whenever we retrieve the child
of a node, use its constructor to re-build it in place from its bbox and
the root before returning it (this won't do anything from now).</li><li>Construct-on-access of root node: similar to previous change, but affects the
<code>AABB_tree</code> type.</li><li>Replace vector of nodes with vector of bboxes/primitive references <code>std::vector&lt;AABB_node></code>
→ <code>std::vector&lt;boost::variant&lt;Bbox, Primitive *>></code>.
Node type should now contain a reference to the root, and a reference
to the bbox/primitive *. Update all accessors to follow this reference.</li><li>Rename <code>Node</code> to <code>Node_handle</code>, because it no longer directly contains
the node's data.</li><li>Substitute <code>union</code> where <code>boost::variant</code> was used; once the system is
confirmed to be working the variant's type checking adds a lot of unnecessary overhead.</li></ul><h4><span class=mw-headline id=.22Fat_nodes.22_intermediate_solution><span class=mw-headline-number>4.11.3.2</span> "Fat nodes" intermediate solution</span></h4><p>The first few steps in my plan produce a system where nodes are
arranged as an implicit tree, and use pointer math to find their
children.
In order to make this work while keeping the logic inside the node,
however, it was necessary to give it extra information.
When each node is constructed, it is given a reference to the root node
(this includes the root node, which has a reference to itself).
With this information, each node has the following knowledge:</p><ul><li>Its own bounding box</li><li>The location of the root node, at the start of the vector</li><li>The location of itself (through the <code>this</code> pointer)</li><li>The a pointer to a primitive (if it has one), or to the child nodes (this is redundant, but
lets me check my work).</li></ul><p>As a result, the node type is slightly larger than the original implementation.
Despite this, it still performs almost exactly as well.
This suggests that this benchmark is not particularly cache-limited, which makes sense given what we
already know.</p><h4><span class=mw-headline id=Making_the_nodes_more_compact><span class=mw-headline-number>4.11.3.3</span> Making the nodes more compact</span></h4><p>The children pointer is now strictly unnecessary, but that space is
shared with the pointer to the primitive.
We could stop saving a reference to the children, but that would leave
us with a primitive pointer that's left null for non-leaf nodes.
My solution was to combine the primitive pointer and the bbox, using a
variant type: <code>boost::variant&lt;Bbox, Primitive *></code>.
Unfortunately, this changes the topology of the tree in a way that
reduces performance; this will be discussed in a later section.</p><h4><span class=mw-headline id=Moving_traversal_logic_to_the_tree><span class=mw-headline-number>4.11.3.4</span> Moving traversal logic to the tree</span></h4><p>The node type still contains one redundant value: the root pointer.
Nodes need this point of reference to calculate their children's locations, but every node holds the
same value!</p><p>There are several ways I could go about eliminating this value,
but after a discussion with Andreas we decided that the simplest
approach would be to move the traversal code to the tree.
Since the tree naturally knows where the root node is, we don't need to
do anything special to hold onto it once the function is moved.
<code>node.children()</code> is replaced by <code>tree.children(node)</code>. Of course, since this
function is primarily called from within the tree, it often looks like <code>children(node)</code>.</p><p>Despite some initial confusion, I eventually determined that this
change had no meaningful effect on performance, one way or another.</p><h3><span class=mw-headline id=The_source_of_N-Way_Tree.27s_performance_advantage><span class=mw-headline-number>4.11.4</span> The source of N-Way Tree's performance advantage</span></h3><p>Andreas and I had a conversation with Sebastien about the performance
advantages we were seeing in the N-way tree.
For traversals with rays and segments this was as much as a 10%
advantage, so we wanted to determine the source.
Evaluating some other tree implementations showed that the performance
increase was likely the result of a particular difference in the tree's
topology.
The original AABB had nodes which could hold either two children, two
primitives, or a mix.
The N-way tree has nodes that can contain either a pair of children or a
single primitive.
What this means in practice is that each primitive is wrapped by its own
bounding box, during traversal this bbox acts as a geometric filter.
We previously believed that this filtering was done by the intersection
function already, which would have made the bbox redundant; but that
didn't turn out to be the case.</p><p>In order to confirm that this was the source of the performance
gain, we added a geometric filter directly inside the traversal function
of a version of the tree which didn't have this topology.</p><table class=wikitable><caption>Effects of geometric filter on any_all benchmark</caption><tbody><tr><th>Tree Implementation</th><th>Epick Kernel Time (s)</th></tr><tr><td>Original</td><td>0.97</td></tr><tr><td>N-way (1-node per primitive)</td><td>0.88</td></tr><tr><td>Implicit Structure (same topology as original)</td><td>0.97</td></tr><tr><td>Implicit Structure with Filtering</td><td>0.91</td></tr></tbody></table><p>Doing this filter inside the traversal function meant that for the last time, the boxes are
calculated on the spot.
This may seem wasteful, but it performs nearly as well as the N-way tree, while only taking up as
much space as the original!</p><p>The tree class actually allows the use to provide a utility for mapping primitives to their bounding
boxes.
By default this simply invokes <code>primitive.bbox()</code>, but it
could be substituted for a solution which caches the boxes.
This could provide the best of both worlds: it doesn't require building
boxes for primitives more than once, and it doesn't take up as much
space as all those extra nodes in the tree.</p><h3><span class=mw-headline id=Building_a_tree_using_a_sort_along_the_Hilbert_curve><span class=mw-headline-number>4.11.5</span> Building a tree using a sort along the Hilbert curve</span></h3><p>One technique used by Embree to great effect is "Spatial Sorting".
This is an alternative method of construction that produces a lower
quality tree, but does so very quickly.
It's useful for Embree when rendering dynamic scenes; when the
primitives contained by a tree move, the tree needs to be rebuilt every
frame.
This may be useful for CGAL as well, wherever trees are built frequently
(or only used a few times).
Building a high quality tree is expensive, and only worthwhile if that
cost is amortized over many traversals.</p><p>To build the tree quickly, Embree starts by sorting the primitives along a <a rel=nofollow class="external text" href=https://en.wikipedia.org/wiki/Z-order_curve>space
filling curve</a>.
This can be done very efficiently because it's possible to give each
location on the curve a unique code,
and these codes can be used in a Radix sort.
When primitives are sorted along a space filling curve, nearby objects
will be placed closer together in the list.
This is true on multiple scales, as well: the first half of the list and
the second half of the list should contain groups of primitives with
little spatial overlap.
This means that after the list has been sorted once, we can produce a
tree of acceptable quality by recursively splitting the list up, and
putting boxes around its sections.</p><p>If we want to replicate this, we need to do something similar.
We can use CGAL's existing <code>hilbert_sort</code> method, which arranges primitives along a <a rel=nofollow class="external text" href=https://en.wikipedia.org/wiki/Hilbert_curve>hilbert
curve</a>.
Luckily, the AABB tree's solution for dividing primitives between nodes
is cleanly separated from the rest of its construction logic.
It is provided as a functor withing CGAL's AABB_traits class.
The relevant part of that functor looks like this:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> PrimitiveIterator<span class=sy1>&gt;</span>
<span class=kw4>void</span> operator<span class=br0>(</span><span class=br0>)</span><span class=br0>(</span>PrimitiveIterator first,
                PrimitiveIterator beyond,
                <span class=kw4>const</span> <span class=kw2>typename</span> AT<span class=sy4>::</span><span class=me2>Bounding_box</span> <span class=sy3>&amp;</span>bbox<span class=br0>)</span> <span class=kw4>const</span> <span class=br0>{</span>
  PrimitiveIterator middle <span class=sy1>=</span> first <span class=sy2>+</span> <span class=br0>(</span>beyond <span class=sy2>-</span> first<span class=br0>)</span> <span class=sy2>/</span> <span class=nu0>2</span><span class=sy4>;</span>
  <span class=kw1>switch</span> <span class=br0>(</span>Traits<span class=sy4>::</span><span class=me2>longest_axis</span><span class=br0>(</span>bbox<span class=br0>)</span><span class=br0>)</span> <span class=br0>{</span>
    <span class=kw1>case</span> AT<span class=sy4>::</span><span class=me2>CGAL_AXIS_X</span><span class=sy4>:</span> <span class=co1>// sort along x</span>
      std<span class=sy4>::</span><span class=me2>nth_element</span><span class=br0>(</span>first, middle, beyond, boost<span class=sy4>::</span><span class=me2>bind</span><span class=br0>(</span>Traits<span class=sy4>::</span><span class=me2>less_x</span>, _1, _2, m_traits<span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
      <span class=kw1>break</span><span class=sy4>;</span>
    <span class=kw1>case</span> AT<span class=sy4>::</span><span class=me2>CGAL_AXIS_Y</span><span class=sy4>:</span> <span class=co1>// sort along y</span>
      std<span class=sy4>::</span><span class=me2>nth_element</span><span class=br0>(</span>first, middle, beyond, boost<span class=sy4>::</span><span class=me2>bind</span><span class=br0>(</span>Traits<span class=sy4>::</span><span class=me2>less_y</span>, _1, _2, m_traits<span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
      <span class=kw1>break</span><span class=sy4>;</span>
    <span class=kw1>case</span> AT<span class=sy4>::</span><span class=me2>CGAL_AXIS_Z</span><span class=sy4>:</span> <span class=co1>// sort along z</span>
      std<span class=sy4>::</span><span class=me2>nth_element</span><span class=br0>(</span>first, middle, beyond, boost<span class=sy4>::</span><span class=me2>bind</span><span class=br0>(</span>Traits<span class=sy4>::</span><span class=me2>less_z</span>, _1, _2, m_traits<span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
      <span class=kw1>break</span><span class=sy4>;</span>
    <span class=kw1>default</span><span class=sy4>:</span>
      CGAL_error<span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
  <span class=br0>}</span>
<span class=br0>}</span></pre></div></div><p>This takes the existing list of primitives and partitions it along whichever axis of the Bbox
surrounding them is longest.
Because this is called from within a recursive function, it's also applied to sub-lists.
One critical difference of the hilbert sort approach is that the list only needs to be sorted once,
to sort sub-lists would be redundant.
In order to prevent that, we need to include a boolean flag that makes sure the sorting isn't done
multiple times.
Because this is a functor and not a function, it's easy to add that flag as another member variable.
It took a lot of debugging to get the solution to this point, but the end result is shockingly
simple:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw2>template</span><span class=sy1>&lt;</span><span class=kw2>typename</span> PrimitiveIterator<span class=sy1>&gt;</span>
<span class=kw4>void</span> operator<span class=br0>(</span><span class=br0>)</span><span class=br0>(</span>PrimitiveIterator first,
                PrimitiveIterator beyond,
                <span class=kw4>const</span> <span class=kw2>typename</span> AT<span class=sy4>::</span><span class=me2>Bounding_box</span> <span class=sy3>&amp;</span>bbox<span class=br0>)</span> <span class=kw4>const</span> <span class=br0>{</span>
&nbsp;
  <span class=co1>// If this is our first time splitting the primitives, sort them along the hilbert curve</span>
  <span class=co1>// This should generally put nearby primitives close together in the list</span>
  <span class=kw1>if</span> <span class=br0>(</span><span class=sy3>!</span>has_been_sorted<span class=br0>)</span> <span class=br0>{</span>
&nbsp;
    <span class=co1>// Create a property map using our Get_reference_point functor</span>
    <span class=kw4>auto</span> property_map <span class=sy1>=</span> boost<span class=sy4>::</span><span class=me2>make_function_property_map</span><span class=sy1>&lt;</span>Primitive, Traits<span class=sy4>::</span><span class=me2>Point_3</span>, Get_reference_point<span class=sy1>&gt;</span><span class=br0>(</span>
            Get_reference_point<span class=br0>(</span>m_traits<span class=br0>)</span>
    <span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// Our search traits will use that property map</span>
    <span class=kw4>typedef</span> CGAL<span class=sy4>::</span><span class=me2>Spatial_sort_traits_adapter_3</span><span class=sy1>&lt;</span>Geom_traits, decltype<span class=br0>(</span>property_map<span class=br0>)</span><span class=sy1>&gt;</span> Search_traits_3<span class=sy4>;</span>
&nbsp;
    <span class=co1>// Perform our hilbert sort using the search traits type with our custom property map</span>
    CGAL<span class=sy4>::</span><span class=me2>hilbert_sort</span><span class=br0>(</span>first, beyond, Search_traits_3<span class=br0>(</span>property_map<span class=br0>)</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// In the future, it's not necessary to re-sort the primitives (we can blindly partition them in the middle)</span>
    has_been_sorted <span class=sy1>=</span> <span class=kw2>true</span><span class=sy4>;</span>
  <span class=br0>}</span>
<span class=br0>}</span></pre></div></div><p>The most complicated part of this was the <code>Get_reference_point</code>
object.
The underlying Primitive type might not be a point type.
In fact, it might be nothing but a reference to a shared object, or it
might have its properties generated on the spot by an outside mechanism.
To account for this, we need to have a system that maps each primitive
to a representative <code>Point_3</code> so it can be used in the spatial sort.
That's done using the property map type, which requires a unary function:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1><span class=kw4>struct</span> Get_reference_point <span class=sy4>:</span> <span class=kw2>public</span> std<span class=sy4>::</span><span class=me2>unary_function</span><span class=sy1>&lt;</span><span class=kw4>const</span> Primitive <span class=sy3>&amp;</span>, <span class=kw2>typename</span> Traits<span class=sy4>::</span><span class=me2>Point_3</span><span class=sy1>&gt;</span> <span class=br0>{</span>
  <span class=kw4>const</span> Traits <span class=sy3>&amp;</span>m_traits<span class=sy4>;</span>
  <span class=kw4>typedef</span> internal<span class=sy4>::</span><span class=me2>Primitive_helper</span><span class=sy1>&lt;</span>Traits<span class=sy1>&gt;</span> Helper<span class=sy4>;</span>
&nbsp;
  Get_reference_point<span class=br0>(</span><span class=kw4>const</span> AABB_traits<span class=sy1>&lt;</span>GeomTraits, AABBPrimitive, BboxMap<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>traits<span class=br0>)</span>
          <span class=sy4>:</span> m_traits<span class=br0>(</span>traits<span class=br0>)</span> <span class=br0>{</span><span class=br0>}</span>
&nbsp;
  <span class=kw2>typename</span> Traits<span class=sy4>::</span><span class=me2>Point_3</span> operator<span class=br0>(</span><span class=br0>)</span><span class=br0>(</span><span class=kw4>const</span> Primitive <span class=sy3>&amp;</span>p<span class=br0>)</span> <span class=kw4>const</span> <span class=br0>{</span>
    <span class=kw1>return</span> Helper<span class=sy4>::</span><span class=me2>get_reference_point</span><span class=br0>(</span>p, m_traits<span class=br0>)</span><span class=sy4>;</span>
  <span class=br0>}</span>
<span class=br0>}</span><span class=sy4>;</span></pre></div></div><p>Despite some ugliness, this solution fits very nicely into the AABB tree's existing abstractions.</p><h4><span class=mw-headline id=Performance><span class=mw-headline-number>4.11.5.1</span> Performance</span></h4><p>Based on my understanding of the tradeoffs of a spatial sorting tree construction,
I would expect tree construction to become much faster but traversal to become slower.
The new construction times look like the following (averaged over 100 constructions of a tree from
the larger <code>bunny00.off</code> dataset).</p><table class=wikitable><caption>Average Time to Construct a Tree from 37,706 Triangles</caption><tbody><tr><th>Kernel</th><th>Recursive Splitting</th><th>Hilbert Sort</th></tr><tr><td>Simple cartesian float</td><td>0.0581281</td><td>0.0644998</td></tr><tr><td>Cartesian float</td><td>0.0999417</td><td>0.101805</td></tr><tr><td>Simple cartesian double</td><td>0.0425205</td><td>0.0429074</td></tr><tr><td>Cartesian double</td><td>0.0828917</td><td>0.0933127</td></tr><tr><td>Epic</td><td>0.0391275</td><td>0.0417023</td></tr></tbody></table><p>These results are a little bit surprising!
The hilbert sort approach takes marginally more time to build a tree,
and I was able to confirm that this affect is consistent across multiple
runs.
My suspicion is that because CGAL's hilbert sort doesn't use a radix
sort internally, we lose out on a lot of its advantage.</p><p>It should be acknowledged that these times are all very small -- dwarfed by the time spent traversing
in this benchmark.
The results for traversal are even more surprising:</p><table class=wikitable><caption>Average Time to Traverse a Tree with 500,000 queries</caption><tbody><tr><th>Kernel</th><th>Recursive Splitting</th><th>Hilbert Sort</th></tr><tr><td>Simple cartesian float</td><td>0.713711</td><td>0.47457</td></tr><tr><td>Cartesian float</td><td>1.24824</td><td>0.840549</td></tr><tr><td>Simple cartesian double</td><td>0.630177</td><td>0.446037</td></tr><tr><td>Cartesian double</td><td>1.16526</td><td>0.81038</td></tr><tr><td>Epic</td><td>1.2477</td><td>0.909729</td></tr></tbody></table><p>Here, the hilbert sort approach handily outperforms the existing solution!
What is going on?</p><h3><span class=mw-headline id=Building_a_Complete_tree_with_repeated_subdivision><span class=mw-headline-number>4.11.6</span> Building a Complete tree with repeated subdivision</span></h3><p>In several cases, we've encountered scenarios where it would be
beneficial if we could guarantee that our tree was complete.
Unfortunately, the current solution for construction the tree doesn't
have an obvious mechanism to make this happen.
It distributes primitives "shortsightedly", choosing how many go in the
left and right subtrees of the current node without any knowledge of the
rest of the tree's structure.
It's trivial to build a complete tree heuristically, but to do it with
only information about the current node is more challenging.</p><p>The heuristic it currently uses is to spread the leaves as evenly
as possible (for example: 15 primitives --> 8 left, 7 right).
Unfortunately, that will often produce non-complete trees.
For example, a tree of 6 nodes will look like this:</p><pre>      N
     / \
    N   N
   /|   |\
  N P   N P
 / \   / \
P   P P   P
</pre><p>But the complete version which contains the same number of leaf nodes would look like this:</p><pre>      N
     / \
    N   N
   / \  |\
  N   N P P
 /|   |\
P P   P P
</pre><p>Notice that in order to produce a complete tree, we need to make the
seemingly-unbalanced choice to distribute 4 of our 6 primitives to the
left, rather than 3.
What we need is a distribution function that can serve as a drop-in
replacement for this function, but produce complete trees.</p><p>After thinking through the problem with the help of a whiteboard, we assembled the following formula:</p><p>Given a number of primitives to distribute <img class="mwe-math-fallback-png-inline tex" alt=N src=wiki_files/8d9c307cb7f3c4a32822a51922d1ceaa.png>,
our goal is to find the number of primitives that should be distributed to the current node's
subtrees
in order to produce a <i>complete</i> tree with <img class="mwe-math-fallback-png-inline tex" alt=N src=wiki_files/8d9c307cb7f3c4a32822a51922d1ceaa.png>
leaves (one for each primitive).
The solution should give us <img class="mwe-math-fallback-png-inline tex" alt=N_{{L}} src=wiki_files/c960ade0fae1b1a56999afe18d354c80.png> and <img class="mwe-math-fallback-png-inline tex" alt=N_{{R}} src=wiki_files/12fc52f1b1e78347ca016aab31eb6cb0.png>,
the number of primitives that should be distributed to the left and right subtrees, respectively.</p><p><img class="mwe-math-fallback-png-inline tex" alt="s=2^{{d}},{\text{where }}s\leq N" src=wiki_files/06addd306ac9c5d3792bf8e76e3bc5e1.png></p><p>Where <img class="mwe-math-fallback-png-inline tex" alt=s src=wiki_files/03c7c0ace395d80182db07ae2c30f034.png> is equivalent to the number of
nodes at depth <img class="mwe-math-fallback-png-inline tex" alt=d src=wiki_files/8277e0910d750195b448797616e091ad.png>,
and <img class="mwe-math-fallback-png-inline tex" alt=d src=wiki_files/8277e0910d750195b448797616e091ad.png> is the depth of the tree's deepest
full layer.</p><p><img class="mwe-math-fallback-png-inline tex" alt="r=N-s" src=wiki_files/9f5207385770531d2766490fb00232ca.png></p><p>Here, <img class="mwe-math-fallback-png-inline tex" alt=r src=wiki_files/4b43b0aee35624cd95b910189b3dc231.png> is the number of remaining nodes if
you were to build a tree with <img class="mwe-math-fallback-png-inline tex" alt=s src=wiki_files/03c7c0ace395d80182db07ae2c30f034.png> leaves.</p><p><img class="mwe-math-fallback-png-inline tex" alt="N_{{L}}={\frac  {s}{2}}+min({\frac  {s}{2}},r)" src=wiki_files/c1d203d8b8839c471577c295455bf8df.png></p><p>The first term of this equation is the base number of leaves that would be in the left subtree of our
tree of size <img class="mwe-math-fallback-png-inline tex" alt=s src=wiki_files/03c7c0ace395d80182db07ae2c30f034.png>.
The second term finds how many need to be added, with <img class="mwe-math-fallback-png-inline tex" alt=min() src=wiki_files/dc6df86c8ee42ad05c6dde23e9f1e644.png>
providing the guarantee that we won't more than double the number of leaves,
as that would require going more than one level deeper.</p><p><img class="mwe-math-fallback-png-inline tex" alt="N_{{R}}=N-N_{{L}}" src=wiki_files/6d67041897654e7574787a66374afbd7.png></p><p>For a 2-way tree, finding <img class="mwe-math-fallback-png-inline tex" alt=N_{{R}} src=wiki_files/12fc52f1b1e78347ca016aab31eb6cb0.png> is simple,
because the right subtree should contain all the primitives that the left subtree couldn't fit.</p><p>Put together, the complete formula looks like the following:</p><p><img class="mwe-math-fallback-png-inline tex" alt="{\begin{aligned}&{\text{Given some }}N\\s&=2^{{d}},\ {\text{where }}s\leq N\\r&=N-s\\N_{{L}}&={\frac  {s}{2}}+min({\frac  {s}{2}},r)\\N_{{R}}&=N-N_{{L}}\\\end{aligned}}" src=wiki_files/5c5d7c3f13d94c9bfaf6546479d0c286.png></p><h4><span class=mw-headline id=Generalizing_to_higher-order_trees><span class=mw-headline-number>4.11.6.1</span> Generalizing to higher-order trees</span></h4><p>This math works well for a standard 2-way tree, but completeness is
just as important for higher order trees, where each node can have more
than 2 children.
Luckily, the math was relatively simple to generalize.</p><p>We're now finding <img class="mwe-math-fallback-png-inline tex" alt=N_{{i}} src=wiki_files/fdddfb449333f2f69953de63c0075048.png>, the number of
primitives in node <img class="mwe-math-fallback-png-inline tex" alt=i src=wiki_files/865c0c0b4ab0e063e5caa3387c1a8741.png>, for any <img class="mwe-math-fallback-png-inline tex" alt=i src=wiki_files/865c0c0b4ab0e063e5caa3387c1a8741.png> in the set of <img class="mwe-math-fallback-png-inline tex" alt=K src=wiki_files/a5f3c6a11b03839d46af9fb43c97c188.png> children.</p><p><img class="mwe-math-fallback-png-inline tex" alt="{\begin{aligned}&{\text{Given some }}N,K,i,{\text{where }}0\leq i<K\\s&=K^{{d}},\ {\text{where }}s\leq N\\r&=N-s\\r_{{i}}&=max(0,r-(i*{\frac  {s}{k}}))\\N_{{i}}&={\frac  {s}{K}}+min({\frac  {s}{K}},r_{{i}})\\\end{aligned}}" src=wiki_files/1ba508508b0b9bbf44d4dd4601536da2.png></p><p>Here, <img class="mwe-math-fallback-png-inline tex" alt=r_{{i}} src=wiki_files/8030c75196c4ac23828f48f7278c5c21.png> is the number of remaining
primitives left over after extra primitives have already been distributed to nodes <img class="mwe-math-fallback-png-inline tex" alt=0...i-1 src=wiki_files/add4dcc926d6b9a2a955bec17b359fc3.png>.
Besides that, this formula functions in much the same way as the 2-way function.</p><h3><span class=mw-headline id=Better_benchmarks_for_Hilbert-sort_construction><span class=mw-headline-number>4.11.7</span> Better benchmarks for Hilbert-sort construction</span></h3><p>Our earlier benchmarks for the Hilbert sort tree construction approach produced some unintuitive
results.
Conventional wisdom is that building a tree this way should be faster than recursive splitting,
but that the tree produced will be of lower quality.
In benchmarks, this would show as a large improvement in construction speed, coupled with a small
penalty to traversal speed.
Our tests showed the exact opposite: construction speed was slightly slower, and traversal was
faster!</p><p>Development of the hilbert sort traits class is now part of <a rel=nofollow class="external text" href=https://github.com/CGAL/cgal/pull/5893>a
new pull request</a>.
As part of this pull request, it's worthwhile to clarify how and where
the new technique outperforms the recursive splitting approach.
To this end, I created a suite of benchmarks which show the relevant
comparisons.
The benchmarking code is heavily templated, so it's simple to measure a
large cross-section of potential parameters.</p><p>(trees are constructed from <code>handle.off</code>, and queries are randomly generated line
segments).</p><table class=wikitable><tbody><tr><th>CGAL::Simple_cartesian&lt;float></th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.000724111 s</td><td>0.000778169 s</td></tr><tr><td>traversal</td><td>4.4037e-07 s</td><td>3.9547e-07 s</td></tr></tbody></table><table class=wikitable><tbody><tr><th>CGAL::Cartesian&lt;float></th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.00129678 s</td><td>0.00168347 s</td></tr><tr><td>traversal</td><td>5.5959e-07 s</td><td>4.988e-07 s</td></tr></tbody></table><table class=wikitable><tbody><tr><th>CGAL::Simple_cartesian&lt;double></th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.000457487 s</td><td>0.000572949 s</td></tr><tr><td>traversal</td><td>4.2589e-07 s</td><td>3.7067e-07 s</td></tr></tbody></table><table class=wikitable><tbody><tr><th>CGAL::Cartesian&lt;double></th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.00112452 s</td><td>0.0015394 s</td></tr><tr><td>traversal</td><td>5.3615e-07 s</td><td>4.7219e-07 s</td></tr></tbody></table><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.000462438 s</td><td>0.000580323 s</td></tr><tr><td>traversal</td><td>5.5827e-07 s</td><td>4.845e-07 s</td></tr></tbody></table><p>This is a lot of data, so in the future, we'll focus primarily on the last test (the one that uses
the Epic kernel).
Epick is the heaviest kernel, and its results tend to be consistent with the others.</p><p><br></p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.000462438 s</td><td>0.000580323 s</td></tr><tr><td>traversal</td><td>5.5827e-07 s</td><td>4.845e-07 s</td></tr></tbody></table><p>Here, construction is a little bit over 20% slower.
This is significant, and raises questions considering we actually
expected a significant increase in speed.
Traversal, on the other hand, is over 15% faster.
This is very interesting since we should expect the hilbert-constructed
tree to be slower.
Both trees produce the same results, which suggests that something might
be wrong with the partitioned tree which is preventing it from getting
the performance it could.</p><p>In any case, if the hilbert sort tree can consistently perform this well, that makes it useful in its
own right.
There's always the possibility that this performance is the result of a quirk of our input data,
so in order to show that that's not the case, we need to test in a variety of different scenarios.
For example, using Rays instead of Line segments should result in more intersections, how does that
affect performance?</p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.000458197 s</td><td>0.00057073 s</td></tr><tr><td>traversal</td><td>5.8002e-07 s</td><td>5.0278e-07 s</td></tr></tbody></table><p>Naturally, construction is almost identical because the tree's data
hasn't been changed.
The increase in intersections has hurt traversal performance, but this
is a flat effect -- this data doesn't change the conclusions we can
make.</p><p>How about if we were to build a tree from a larger dataset?
Before we loaded data from <code>handle.off</code>, containing 1,165 vertices,
now we'll use <code>bunny00.off</code>, which contains a massive 37,706 vertices -- over 30x larger!
Unlike the previous test, we should expect this to produce the different results for construction
times.</p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.0357437 s</td><td>0.0420231 s</td></tr><tr><td>traversal</td><td>8.12154e-07 s</td><td>9.40858e-07 s</td></tr></tbody></table><p>Here, we see no change to the relationship between construction
times, but our traversal performance has reversed!
Traversing the Hilbert sort tree now takes 15% _slower_ on average,
rather than faster.
My first guess was now that the test is longer, hilbert sort had a
disadvantage from running second (once the CPU is already hot).
Swapping the order of the tests hardly affected results, showing that
this wasn't the case.
Perhaps for deeper trees, the optimality of their structure becomes more
important to performance.</p><h3><span class=mw-headline id=Improving_Hilbert_sort_construction_performance><span class=mw-headline-number>4.11.8</span> Improving Hilbert sort construction performance</span></h3><h4><span class=mw-headline id=Bottom-up_boxing><span class=mw-headline-number>4.11.8.1</span> Bottom-up boxing</span></h4><p>Hilbert sort isn't constructing as fast as it could, because the bbox
is still being produced on the way down.
The hilbert sort process involves recursive splitting, so its only
advantage comes from the fact that the sorting process doesn't require
knowledge of bounding boxes.
Because of this, the boxes can be produced from the bottom up more
cheaply (because each box only depends on child boxes, and not on the
list of primitives it contains).</p><p>We can create our boxes from the bottom up with the addition of a
template specialization that treats the hilbert traits class
differently.
Once this is added, we see a big improvement in construction speed, and
the benchmark starts to look a lot more how we expected.</p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.0297283 s</td><td>0.0230078 s</td></tr><tr><td>traversal</td><td>6.85527e-07 s</td><td>8.32478e-07 s</td></tr></tbody></table><p>Construction is now about 30% better, and traversal is around 20% worse.</p><h4><span class=mw-headline id=Multithreading><span class=mw-headline-number>4.11.8.2</span> Multithreading</span></h4><p>We can get a further speedup by enabling a multithreaded sort of the primitives,
a feature provided by CGAL's hilbert sort implementation.</p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.0289884 s</td><td>0.00990184 s</td></tr><tr><td>traversal</td><td>6.75906e-07 s</td><td>7.76014e-07 s</td></tr></tbody></table><p>This gives the hilbert sort an even larger advantage, though it's not entirely fair
-- the recursive partition method doesn't incorporate even limited multithreading.
Hilbert traits can be used to construct a tree nearly 3 times as fast as the typical method,
which can make its tradeoffs very appealing.</p><h3><span class=mw-headline id=More_challenging_benchmarks><span class=mw-headline-number>4.11.9</span> More challenging benchmarks</span></h3><p>The tweaks we made to the new traits class have given it demonstrable advantages over the traditional
method,
but in order to reason about when it's appropriate we need to see how it performs in extreme use
cases.
To that end, we created some more difficult benchmarks.</p><h4><span class=mw-headline id=Larger_dataset><span class=mw-headline-number>4.11.9.1</span> Larger dataset</span></h4><p>Andreas provided a .PLY file with a high resolution scan of a gargoyle.
Its mesh is made up of over 7,000,000 vertices, so building a tree for it is an expensive operation.</p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.705003 s</td><td>0.441753 s</td></tr><tr><td>traversal</td><td>6.02128e-06 s</td><td>7.83255e-06 s</td></tr></tbody></table><p>The new parallel traits class maintains a lot of its advantage,
remaining around 40% the traditional method.
The size of the tree also had little effect on the relative cost of traversals,
with the lower quality tree still requiring under 20% more time to traverse.</p><h4><span class=mw-headline id=Real-life_use_case><span class=mw-headline-number>4.11.9.2</span> Real-life use case</span></h4><p>The fact that the new construction can be used simply by swapping the
traits type opens up a lot of opportunities for interesting real-life
tests.
This makes it easy to look at how the tradeoffs we've been measuring
affect actual use-cases.
Surface mesh segmentation is a perfect worst-case benchmark for this
optimization, for a few reasons:</p><ul><li>Because the underlying primitives aren't changed, the tree only needs to be constructed a
single time.</li><li>That one tree is used for a large number of queries (one for each vertex in the output mesh).</li><li>Each query is guaranteed to fully descend the tree. This is because
the queries are rays shot from the inside of a watertight mesh, so
they're guaranteed to hit a face of that mesh. As a result of this, ever
traversal is very expensive.</li></ul><p>We benchmarked segmentation by timing <code>segmentation_from_sdf_values_SM_example</code>.
The package subclasses <code>AABB_traits</code>, so we could swap strategies easily by replacing
what it subclassed.</p><table class=wikitable><tbody><tr><th>Segmentation</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>time</td><td>11.0 s</td><td>12.7 s</td></tr></tbody></table><p>Here, we see that for this use case, the new technique isn't worth its tradeoffs.</p><h2><span class=mw-headline id=August_11_-_August_17><span class=mw-headline-number>4.12</span> August 11 - August 17</span></h2><h3><span class=mw-headline id=Quantifying_tradeoffs><span class=mw-headline-number>4.12.1</span> Quantifying tradeoffs</span></h3><p>So when is it actually worth it to use the new traits class?
We can actually determine this from the performance data we've already collected,
we'll look at the largest test for this:</p><table class=wikitable><tbody><tr><th>CGAL::Epick</th><th>Recursive Partition</th><th>Hilbert Sort</th></tr><tr><td>construction</td><td>0.705003 s</td><td>0.441753 s</td></tr><tr><td>traversal</td><td>6.02128e-06 s</td><td>7.83255e-06 s</td></tr></tbody></table><p>The new traits class reduced the time to construct a tree by 0.263 s
and increased the time to perform one traversal by 0.00000181 s.
Taken together, this tells us that the new traits class loses its
advantage only once you've performed 145,201 traversals.
If you do more than that, then it becomes worthwhile to spend more time
to build a higher quality tree, so your traversals can be faster.
I expect this number varies quite a bit depending on the exact nature of
the data,
but the order of magnitude difference should be indicative.</p><p>Of course, this result is specific to the size of the tree we
built!
Construction time and traversal time both vary non-linearly with the
number of primitives in the tree,
in order to get a better idea of how tree size affects our tradeoffs, we
need to perform benchmarks at different scales.
I created a new benchmarking approach which progressively shrinks the
dataset, and measured the effect that had on construction and traversal
times.</p><table class=wikitable><caption>CGAL::Epick</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>1637530</td><td></td><td>0.690989 s</td><td>0.437864 s</td><td></td><td>5.82817e-06 s</td><td>7.5607e-06 s</td></tr><tr><td>1000000</td><td></td><td>0.481111 s</td><td>0.258386 s</td><td></td><td>6.25142e-06 s</td><td>7.0905e-06 s</td></tr><tr><td>100000</td><td></td><td>0.0604657 s</td><td>0.0258631 s</td><td></td><td>6.44138e-06 s</td><td>6.54842e-06 s</td></tr><tr><td>10000</td><td></td><td>0.00545731 s</td><td>0.0029774 s</td><td></td><td>5.30458e-06 s</td><td>5.58388e-06 s</td></tr><tr><td>1000</td><td></td><td>0.00149441 s</td><td>0.00137508 s</td><td></td><td>3.64947e-06 s</td><td>3.67336e-06 s</td></tr></tbody></table><p>From here it's easy to calculate breakeven points for each order of magnitude:</p><table class=wikitable><caption>CGAL::Epick</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>1637530</td><td>146,000</td></tr><tr><td>1000000</td><td>265,000</td></tr><tr><td>100000</td><td>323,000</td></tr><tr><td>10000</td><td>8,880</td></tr><tr><td>1000</td><td>4,990</td></tr></tbody></table><p>The relationship isn't actually monotonically increasing or decreasing.
It looks as though fast-construction is most effective at somewhere around 100,000 primitives.
As the tree gets larger, the utility of the new construction strategy declines gradually,
and when the tree is smaller it loses its advantage rapidly.
For a small 1000-primitive tree, you only need to do over 5,000 traversals before fast-construction
is no longer worthwhile!</p><h3><span class=mw-headline id=More_diverse_test_data><span class=mw-headline-number>4.12.2</span> More diverse test data</span></h3><p>To evaluate how the nature of the data affects the new construction strategy's advantages,
I standardized the testing procedure and created synthetic datasets with Andreas' help.</p><h4><span class=mw-headline id=Gargoyle><span class=mw-headline-number>4.12.2.1</span> Gargoyle</span></h4><p>I converted the gargoyle dataset to <code>.off</code>, and rather than simplifying the mesh I
randomly removed a subset of its faces.
This change to how the number of primitives is reduced is actually significant,
because it makes the mesh more sparse in addition to reducing the size of the tree.
This will generally result in decreasing hit rates as the dataset is reduced,
but because the change is being applied uniformly across our tests this should be acceptable.</p><table class=wikitable><caption>CGAL::Epick, gargoyle_1637530.off</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>1637530</td><td></td><td>0.68504 s</td><td>0.434351 s</td><td></td><td>6.0408e-06 s</td><td>7.48615e-06 s</td></tr><tr><td>1000000</td><td></td><td>0.411266 s</td><td>0.207592 s</td><td></td><td>5.13054e-06 s</td><td>5.81011e-06 s</td></tr><tr><td>100000</td><td></td><td>0.0292015 s</td><td>0.0108758 s</td><td></td><td>1.10307e-06 s</td><td>1.4085e-06 s</td></tr><tr><td>10000</td><td></td><td>0.0024164 s</td><td>0.00109091 s</td><td></td><td>4.99561e-07 s</td><td>6.05938e-07 s</td></tr><tr><td>1000</td><td></td><td>0.00018549 s</td><td>0.000163817 s</td><td></td><td>3.6545e-07 s</td><td>2.94521e-07 s</td></tr></tbody></table><p>These results mostly look similar to the previous measurements,
but things begin to diverge as the number of primitives gets very low.
Because the mesh is much more sparse, fewer of the primitives descend the tree as far.
This makes the effect of a higher quality tree less visible,
and the Hilbert-constructed tree even beats the conventional one when there are only 1,000 elements.
Luckily, we still get good data for larger trees, and the results mirror the previous test as
expected.</p><table class=wikitable><caption>CGAL::Epick, gargoyle_1637530.off</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>1637530</td><td>173,445</td></tr><tr><td>1000000</td><td>299,710</td></tr><tr><td>100000</td><td>60,000</td></tr><tr><td>10000</td><td>12,460</td></tr><tr><td>1000</td><td>(inf)</td></tr></tbody></table><p>When we use the same formula to find our breakeven points, we get mostly reasonable results.
The numbers tend to fall within the same orders of magnitude as in the previous test.</p><h4><span class=mw-headline id=Rotated_Sphere-grid><span class=mw-headline-number>4.12.2.2</span> Rotated Sphere-grid</span></h4><p>The dataset for the next test was synthesized using the Polyhedron demo.
It consists of an 8x8x8 cubic grid of sphere meshes with an affine transform applied so that they
aren't perfectly on axis.
The gargoyle mesh formed a "shell" which the rays were cast outwards from,
this mesh is very different from that, and that may have consequences for our performance.</p><ul><li>The rays are shot from outside the spheres, which means that they aren't guaranteed to hit any
faces.</li><li>The spheres are densely distributed around the source, rays are more likely to hit many faces,
rather than just one.</li></ul><table class=wikitable><caption>CGAL::Epick, sphere_grid_842400.off</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>842400</td><td></td><td>0.425959 s</td><td>0.186575 s</td><td></td><td>1.04627e-05 s</td><td>1.15029e-05 s</td></tr><tr><td>100000</td><td></td><td>0.0369721 s</td><td>0.0111089 s</td><td></td><td>3.20296e-06 s</td><td>3.64699e-06 s</td></tr><tr><td>10000</td><td></td><td>0.00260251 s</td><td>0.00106912 s</td><td></td><td>3.8749e-07 s</td><td>4.28021e-07 s</td></tr><tr><td>1000</td><td></td><td>0.000217795 s</td><td>0.000175691 s</td><td></td><td>5.56993e-08 s</td><td>5.78713e-08 s</td></tr></tbody></table><p>At a glance, these results seem to show a larger advantage for the Hilbert sort,
after all, the construction is more than twice as fast and traversal is only slightly slower.
This may not have as big an affect on the breakeven point as it seems at first:
for tests on this dataset, construction was especially fast and traversal was especially slow for
<i>either</i> traits class.
Practically speaking, this means that the value of a relatively faster construction is lower,
because times are more likely to be driven by the number of traversals.</p><table class=wikitable><caption>CGAL::Epick, sphere_grid_842400.off</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>842400</td><td>230,133</td></tr><tr><td>100000</td><td>58,247</td></tr><tr><td>10000</td><td>37,833</td></tr><tr><td>1000</td><td>19,385</td></tr></tbody></table><p>It seems as though the two opposing effects mostly cancel out.
The breakeven point tends to be within the same orders of magnitude as in previous tests.</p><h4><span class=mw-headline id=Mixed_Sphere-grid><span class=mw-headline-number>4.12.2.3</span> Mixed Sphere-grid</span></h4><p>Next, we produced another dataset by merging the affine-transformed sphere grid
with the axis-aligned pre-transformation version.
Besides increasing primitive count, this also has the effect of increasing overall density
and reducing the likelihood that a ray will hit nothing.</p><table class=wikitable><caption>CGAL::Epick, sphere_grid_combined_1684800.off</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>1684800</td><td></td><td>0.924095 s</td><td>0.488123 s</td><td></td><td>2.49734e-05 s</td><td>2.78055e-05 s</td></tr><tr><td>1000000</td><td></td><td>0.508275 s</td><td>0.217452 s</td><td></td><td>2.00373e-05 s</td><td>2.10856e-05 s</td></tr><tr><td>100000</td><td></td><td>0.0351812 s</td><td>0.0113362 s</td><td></td><td>8.32743e-06 s</td><td>9.66192e-06 s</td></tr><tr><td>10000</td><td></td><td>0.00257242 s</td><td>0.00102682 s</td><td></td><td>4.33653e-06 s</td><td>4.68058e-06 s</td></tr><tr><td>1000</td><td></td><td>0.000201988 s</td><td>0.000168705 s</td><td></td><td>1.48951e-06 s</td><td>1.46143e-06 s</td></tr></tbody></table><p>This test exhibits the same issue as the first, where for small dataset sizes
the traversal data is potentially unreliable, and the Hilbert constructed tree beats the
conventional method.</p><table class=wikitable><caption>CGAL::Epick, sphere_grid_combined_1684800.off</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>1684800</td><td>153939</td></tr><tr><td>1000000</td><td>277423</td></tr><tr><td>100000</td><td>17868</td></tr><tr><td>10000</td><td>4492</td></tr><tr><td>1000</td><td>(inf)</td></tr></tbody></table><p>Once again, we see results with the same magnitude as the other tests.</p><h3><span class=mw-headline id=Switching_from_Median_to_Middle_Hilbert_Policy><span class=mw-headline-number>4.12.3</span> Switching from Median to Middle Hilbert Policy</span></h3><p>The Hilbert sorting package provides two different strategies,
the one we've been using so far splits based on the median of the points,
but we might be able to get better results by switching to the "middle" policy.</p><h4><span class=mw-headline id=Gargoyle_2><span class=mw-headline-number>4.12.3.1</span> Gargoyle</span></h4><table class=wikitable><caption>CGAL::Epick, gargoyle_1637530.off</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>1637530</td><td></td><td>0.694047 s</td><td>0.438711 s</td><td></td><td>5.88445e-06 s</td><td>7.44739e-06 s</td></tr><tr><td>1000000</td><td></td><td>0.406627 s</td><td>0.204171 s</td><td></td><td>5.05238e-06 s</td><td>5.77835e-06 s</td></tr><tr><td>100000</td><td></td><td>0.0294115 s</td><td>0.01054 s</td><td></td><td>1.0871e-06 s</td><td>1.45127e-06 s</td></tr><tr><td>10000</td><td></td><td>0.00239611 s</td><td>0.00103612 s</td><td></td><td>5.37958e-07 s</td><td>6.09279e-07 s</td></tr><tr><td>1000</td><td></td><td>0.0001899 s</td><td>0.0001647 s</td><td></td><td>3.39e-07 s</td><td>2.95038e-07 s</td></tr></tbody></table><table class=wikitable><caption>CGAL::Epick, gargoyle_1637530.off</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>1637530</td><td>163,369</td></tr><tr><td>1000000</td><td>278,877</td></tr><tr><td>100000</td><td>51,821</td></tr><tr><td>10000</td><td>19,069</td></tr><tr><td>1000</td><td>(inf)</td></tr></tbody></table><p>For this data, performance is consistently slightly worse, meaning that the breakeven point is lower.</p><h4><span class=mw-headline id=Rotated_Sphere-grid_2><span class=mw-headline-number>4.12.3.2</span> Rotated Sphere-grid</span></h4><table class=wikitable><caption>CGAL::Epick, sphere_grid_842400.off</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>842400</td><td></td><td>0.419961 s</td><td>0.187204 s</td><td></td><td>1.03394e-05 s</td><td>1.13945e-05 s</td></tr><tr><td>100000</td><td></td><td>0.0360399 s</td><td>0.0110656 s</td><td></td><td>3.34002e-06 s</td><td>3.62142e-06 s</td></tr><tr><td>10000</td><td></td><td>0.00264938 s</td><td>0.00108409 s</td><td></td><td>3.97501e-07 s</td><td>4.16641e-07 s</td></tr><tr><td>1000</td><td></td><td>0.000221205 s</td><td>0.000191903 s</td><td></td><td>5.85699e-08 s</td><td>6.01912e-08 s</td></tr></tbody></table><table class=wikitable><caption>CGAL::Epick, sphere_grid_842400.off</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>842400</td><td>220,602</td></tr><tr><td>100000</td><td>88,750</td></tr><tr><td>10000</td><td>81,781</td></tr><tr><td>1000</td><td>18,073</td></tr></tbody></table><p>Here, things are a little bit more interesting.
The new strategy is slightly better when the number of primitives is small,
but performs worse for the largest set.</p><h4><span class=mw-headline id=Mixed_Sphere-grid_2><span class=mw-headline-number>4.12.3.3</span> Mixed Sphere-grid</span></h4><table class=wikitable><caption>CGAL::Epick, sphere_grid_combined_1684800.off</caption><tbody><tr><th># Primitives</th><th></th><th>Recursive Partition Construction</th><th>Hilbert Sort Construction</th><th></th><th>Recursive Partition Traversal</th><th>Hilbert Sort Traversal</th></tr><tr><td>1684800</td><td></td><td>0.920223 s</td><td>0.486563 s</td><td></td><td>2.50497e-05 s</td><td>2.79779e-05 s</td></tr><tr><td>1000000</td><td></td><td>0.505539 s</td><td>0.215818 s</td><td></td><td>2.01638e-05 s</td><td>2.11468e-05 s</td></tr><tr><td>100000</td><td></td><td>0.035145 s</td><td>0.0111322 s</td><td></td><td>8.34144e-06 s</td><td>9.48135e-06 s</td></tr><tr><td>10000</td><td></td><td>0.00264618 s</td><td>0.0010278 s</td><td></td><td>4.33139e-06 s</td><td>4.66359e-06 s</td></tr><tr><td>1000</td><td></td><td>0.000208092 s</td><td>0.000167298 s</td><td></td><td>1.52239e-06 s</td><td>1.53896e-06 s</td></tr></tbody></table><table class=wikitable><caption>CGAL::Epick, sphere_grid_combined_1684800.off</caption><tbody><tr><th># Primitives</th><th>Traversals-per-construction</th></tr><tr><td>1684800</td><td>148,098</td></tr><tr><td>1000000</td><td>294,731</td></tr><tr><td>100000</td><td>21,066</td></tr><tr><td>10000</td><td>4,872</td></tr><tr><td>1000</td><td>2,462</td></tr></tbody></table><p>Here, the difference is less consistent, with the new strategy winning some and losing others.
These results aren't reliable enough in my eyes to justify switching to the middle-strategy as a
default.</p><h3><span class=mw-headline id=More_exploration_of_Implicit_Tree_Structures><span class=mw-headline-number>4.12.4</span> More exploration of Implicit Tree Structures</span></h3><p>The implicit tree structure I previously created was based on my earlier n-way-tree work,
but in order to have an atomic PR, I need to build the same functionality on top of master.
An important luxury I have when working on this is that the AABB tree's node class is fully
internal,
and it isn't mentioned in the documentation.
This means that I have few restrictions on changing its API,
and I can make some relatively drastic changes to how it works without breaking compatibility with
users' code.</p><p>Unlike last time, I decided to base this implementation on the concept of a "Node handle".
The node type won't contain any direct information about the state of the node it represents,
instead, it acts like an elaborate iterator type.
To do this, it needs to contain three things:</p><ul><li><code>std::vector&lt;Bounding_box> &m_boxes</code> a reference to a collection of boxes</li><li><code>std::vector&lt;Primitive> &m_primitives</code> a reference to a collection of
primitives</li><li><code>std::size_t m_index</code> the index of the relevant node</li></ul><p>The node's public API provides a superset of the functionality of the original node.
Here's a summarized version of its public methods:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1>  <span class=kw2>class</span> AABB_node <span class=br0>{</span>
  <span class=kw2>public</span><span class=sy4>:</span>
&nbsp;
    AABB_node<span class=br0>(</span>std<span class=sy4>::</span><span class=me2>vector</span><span class=sy1>&lt;</span>Bounding_box<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>boxes, std<span class=sy4>::</span><span class=me2>vector</span><span class=sy1>&lt;</span>Primitive<span class=sy1>&gt;</span> <span class=sy3>&amp;</span>primitives, std<span class=sy4>::</span><span class=kw4>size_t</span> index <span class=sy1>=</span> <span class=nu0>0</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=kw4>void</span> expand<span class=br0>(</span>ConstPrimitiveIterator first,
                ConstPrimitiveIterator beyond,
                <span class=kw4>const</span> ComputeBbox <span class=sy3>&amp;</span>compute_bbox,
                <span class=kw4>const</span> SplitPrimitives <span class=sy3>&amp;</span>split_primitives,
                <span class=kw4>const</span> AABBTraits <span class=sy3>&amp;</span><span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=kw4>void</span> traversal<span class=br0>(</span><span class=kw4>const</span> Query <span class=sy3>&amp;</span>query, Traversal_traits <span class=sy3>&amp;</span>traits<span class=br0>)</span> <span class=kw4>const</span><span class=sy4>;</span>
&nbsp;
  <span class=kw2>public</span><span class=sy4>:</span>
&nbsp;
    <span class=co1>// Existing functionality</span>
    <span class=kw2>inline</span> <span class=kw4>const</span> Bounding_box <span class=sy3>&amp;</span>bbox<span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw2>inline</span> Bounding_box <span class=sy3>&amp;</span>bbox<span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw2>inline</span> <span class=kw4>const</span> Primitive <span class=sy3>&amp;</span>primitive<span class=br0>(</span><span class=br0>)</span> <span class=kw4>const</span><span class=sy4>;</span>
    <span class=kw2>inline</span> Primitive <span class=sy3>&amp;</span>primitive<span class=br0>(</span><span class=br0>)</span><span class=sy4>;</span>
    <span class=kw2>inline</span> Node left_child<span class=br0>(</span><span class=br0>)</span> <span class=kw4>const</span><span class=sy4>;</span>
    <span class=kw2>inline</span> Node right_child<span class=br0>(</span><span class=br0>)</span> <span class=kw4>const</span><span class=sy4>;</span>
&nbsp;
    <span class=co1>// New functionality</span>
    <span class=kw2>inline</span> <span class=kw4>bool</span> is_leaf<span class=br0>(</span><span class=br0>)</span> <span class=kw4>const</span><span class=sy4>;</span>
  <span class=br0>}</span></pre></div></div><p>A lot of the functionality of the original node has been renamed, and the way it's implemented has
changed completely:</p><ul><li><code>bbox()</code> provides access to the node's associated bbox, using the node's index and
its reference to the bbox collection.</li><li><code>primitive()</code> is similar, though some math is necesary to determine the index of the
primitive in <code>m_primitives</code>.</li><li><code>left_child()</code> and <code>right_child()</code> provide access to children by
constructing them on-the-spot, since the node handles don't actually exist in an array</li><li><code>expand()</code> uses a similar recursive algorithm to the
original, and it was actually simplified by the fact that the
connections between nodes already exist implicitly</li><li><code>traversal()</code> was also simplified, because it's now easier to determine if a node is
a leaf node</li></ul><p>The additional context that the node handle has also makes it easy to
add new functionality, which the original tree couldn't provide.
For example <code>is_leaf()</code> as mentioned earlier, was as simple as comparing the node's index
to the number of non-leaf nodes.
There's also an opportunity to add additional functionality in the future, like the following:</p><ul><li><code>parent()</code> can find the parent using a simple equation of the index</li><li><code>children()</code> can be found as a list, because they are always adjacent</li><li><code>siblings()</code> can be done similarly</li></ul><p>Changes to the tree itself are much smaller, and don't affect its API.
Importantly, the tree's node array is replaced with a bbox vector.
The tree also holds an instance of the root node (index 0).
This is only necessary so that the root accessor can still return a pointer,
otherwise it would have made more sense to construct this node on request, like all other nodes.</p><h4><span class=mw-headline id=Use_of_Assertions><span class=mw-headline-number>4.12.4.1</span> Use of Assertions</span></h4><p>One feature that was central to my development process was the way
the node handle class uses assertion statements.
I applied assertions liberally, the implicit nature of the tree would
have made it hard to catch certain types of errors otherwise.
Often, I used assertions to validate assumptions rather than as
preconditions.
For example, here's one way assertions are used during the construction
of a tree:</p><div dir=ltr class="mw-geshi mw-code mw-content-ltr"><div class="cpp source-cpp"><pre class=de1>    ...
&nbsp;
    <span class=co1>// Stop when we've reached a leaf node</span>
    <span class=kw1>if</span> <span class=br0>(</span>is_leaf<span class=br0>(</span><span class=br0>)</span><span class=br0>)</span> <span class=br0>{</span>
&nbsp;
      <span class=co1>// Make sure we're only trying to assign a single primitive to this node</span>
      CGAL_assertion_msg<span class=br0>(</span>
              beyond <span class=sy2>-</span> first <span class=sy1>==</span> <span class=nu0>1</span>,
              <span class=st0>"Constructor attempted to assign more than one primitive to a leaf node"</span>
      <span class=br0>)</span><span class=sy4>;</span>
&nbsp;
      <span class=co1>// Make sure the primitives table is aligned with the bbox table</span>
      CGAL_assertion_msg<span class=br0>(</span>
              first <span class=sy2>-</span> m_primitives.<span class=me1>get</span><span class=br0>(</span><span class=br0>)</span>.<span class=me1>begin</span><span class=br0>(</span><span class=br0>)</span> <span class=sy1>==</span> primitive_index<span class=br0>(</span><span class=br0>)</span>,
              <span class=st0>"Primitive misalignment! "</span>
              <span class=st0>"The tree's topology should guarantee that primitives are aligned with their boxes."</span>
      <span class=br0>)</span><span class=sy4>;</span>
&nbsp;
    <span class=br0>}</span> <span class=kw1>else</span> <span class=br0>{</span>
&nbsp;
      ...</pre></div></div><p>Because of the way our implicit construction works, the recursive
method has an empty base case.
When we reach a leaf node, it should already have all of its
connections, and it should be associated with its primitive based on its
index.
Instead of eliminating this space entirely, I used it to check that the
node was imbued with the right properties.
I check that the leaf node is being associated with exactly one
primitive,
as well as that the leaf node can correctly locate the primitive it's
associated with.</p><h3><span class=mw-headline id=.22Fully_boxed.22_vs_.22Leafless.22_trees><span class=mw-headline-number>4.12.5</span> "Fully boxed" vs "Leafless" trees</span></h3><p>A topic that's already come up several times is whether each primitive should have its own bounding
box.
Here, I'll refer to the options as "Leafless" and "Fully boxed".</p><ul><li>A Leafless tree does not put boxes around each primitive; instead, the deepest boxes in the
tree surround <i>pairs</i>
of primitives. I'm referring to this as "leafless" because it doesn't
involve any nodes that don't hold more than one child. This is how
CGAL's existing AABB tree works, and it comes with a couple of
implications:<ul><li>The tree needs fewer nodes to hold the same number of primitives.</li><li>A node can hold either two primitives, two child nodes, or a primitive and a node.</li><li>Traversal and construction are more complicated, to account for the different states a
node can have.</li></ul></li><li>A Fully-boxed tree gives every primitive its own node. This is how
the current version of the N-way tree works as well as the implicit
tree, it has its own implications.<ul><li>Nearly twice as many nodes are necessary to hold the same number of primitives.</li><li>A node can hold either a primitive or a pair of leaves, with no in-between.</li><li>Child nodes can be held in contiguous arrays, since they aren't mixed in with
primitives.</li><li>Recursive traversal and construction are trivial and intuitive,
because nodes can only be in two different states, with leaf nodes being
the base-case.</li><li>Performance tends to be better by default, because the last bbox
acts as a geometric filter for primitives that don't already have a bbox
pre-check for intersections.</li></ul></li></ul><p>The AABB tree supports a Bbox-map which saves the result of finding the bbox for a primitive.
This might be able to provide the same performance of the fully-boxed tree without needing the same
amount of additional space.
In order to look at the tradeoffs holistically, it's necessary to create a leafless version of our
implicit tree.</p><h4><span class=mw-headline id=Leafless_Implicit_Tree><span class=mw-headline-number>4.12.5.1</span> Leafless Implicit Tree</span></h4><p>The implicit tree was relatively easy to convert to a leafless structure, using the following
changes:</p><ul><li>The box vector was reduced in size, to only include the ones necessary for this configuration.</li><li>The constructor was changed to only set the bbox of non-leaf nodes
(attempts to set it would otherwise cause out-of-bounds errors.</li><li>The math used to find the primitive for a node was changed to account for the new number of
boxes.</li><li>Traversal needed additional logic to prevent attempting to intersect with the boxes of
leaf-nodes.</li></ul><p>Conceptually, the change to our "table" converts it from this:</p><pre>   B B B B B B B B B B B B B
               P P P P P P P
</pre><p>to this:</p><pre>   B B B B B B
               P P P P P P P
</pre><p>The way we use indices in our node handles remains the same, the only
difference being that certain indices don't have boxes associated with
them.</p><h3><span class=mw-headline id=Benchmarking_tree_configurations><span class=mw-headline-number>4.12.6</span> Benchmarking tree configurations</span></h3><p>(Testing here is done with the Epic Kernel and <code>gargoyle_1637530.off</code> dataset)</p><p>First, we want to see if taking the same tree topology and making it implicit hurts performance,
to do this we can look at how the leafless versions of both trees compare.</p><table class=wikitable><tbody><tr><th>Performance</th><th>Master (leafless)</th><th>Implicit (leafless)</th></tr><tr><td>Construction Time</td><td>0.941639 s</td><td>0.97235 s</td></tr><tr><td>Traversal Time</td><td>5.76427e-06 s</td><td>6.60947e-06 s</td></tr><tr><td>Memory Usage</td><td>404.0MiB</td><td>352.8 MiB</td></tr></tbody></table><p>Here, the conversion to implicit comes with a small but measurable performance penalty for both
construction and traversal.
The slowdown to traversal is not surprising, as I haven't made any optimizations to retrieving
properties of nodes
(many redundant array accesses happen during traversal).
The construction slowdown is, on the other hand, surprising.
A lot of logic was removed from the construction code, so I'm uncertain where this penalty comes
from.</p><p>Memory usage goes down, but not by very much.
The primitives themselves are likely responsible for a much larger portion of the memory used than
the tree's structure,
since bounding boxes and pointers are relatively small compared to high-precision coordinate types.
Moreover, even for the massive dataset used here, memory is far from the limiting factor.</p><p>We also want to see whether using a bbox-map can help us get
better performance out of a leafless tree.
For this we can compare the fully-boxed implicit tree to both leafless
implementations with the addition of the bbox map.
The N-way tree is also included in this benchmark as an example of a
fully-boxed architecture that uses explicit connections between nodes.</p><table class=wikitable><tbody><tr><th>Performance</th><th>Master (leafless + bbox-map)</th><th>Implicit (leafless + bbox-map)</th><th>Implicit (fully-boxed)</th><th>N-way (fully-boxed)</th></tr><tr><td>Construction Time</td><td>0.758121 s</td><td>0.840891 s</td><td>0.960223 s</td><td>0.672876 s</td></tr><tr><td>Traversal Time</td><td>5.78328e-06 s</td><td>6.59443e-06 s</td><td>5.64262e-06 s</td><td>5.40254e-06 s</td></tr><tr><td>Memory Usage</td><td>452.7 MiB</td><td>427.7 MiB</td><td>446.0 MiB</td><td>479.0 MiB</td></tr></tbody></table><h1><span class=mw-headline id=Proposed_Optimizations><span class=mw-headline-number>5</span> Proposed Optimizations</span></h1><table class=wikitable><caption>Potential Approaches for Improving AABB-tree performance (using SIMD)</caption><tbody><tr><th>Approach</th><th>Predicted Yield</th><th>Intrusiveness</th><th>Description</th></tr><tr><td>N-Way Splitting</td><td>High</td><td>High</td><td>Wide BVH like Embree uses, each node holds N >= 2 children, where N is the # of SIMD
lanes.</td></tr><tr><td>Parents hold child bounds</td><td>Medium</td><td>Low</td><td>Rather than each node containing its own boundary, nodes can hold
the bounding boxes of each of their children. This improves the
arrangement in memory, potentially allowing easier vectorization.</td></tr><tr><td>Child-skipping</td><td>&nbsp;?</td><td>Medium</td><td>If a node contains a complete tree to depth N, gather all
(great)grandchildren at depth N and perform intersections with them
(SIMD allows us to perform intersections on multiple nodes without much
additional cost).</td></tr><tr><td>SIMD Intersection Func</td><td>Low</td><td>Low</td><td>Fine grained vectorization of the intersection algorithm, no
changes outside the function itself. This is likely already being done
by the compiler.</td></tr><tr><td>Data Alignment</td><td>Low</td><td>Medium</td><td>Make sure that the AABB-tree's data is stored in memory-aligned data structures, for faster
loading into SIMD registers.</td></tr><tr><td>Stream Traversal</td><td>Medium</td><td>High</td><td>Queries composed of multiple similar rays, improving cache performance and making use of
SIMD for simultaneous intersections.</td></tr><tr><td>Query Boxing</td><td>&nbsp;?</td><td>Medium</td><td>Place the query in a BBox or set of BBoxes, to avoid the need to
use high-precision intersection approaches until intersecting with
primitives.</td></tr><tr><td>Subtree Collapsing*</td><td>Medium</td><td>Medium</td><td>Leaf nodes have a "bucket size", can hold more than 2 primitives.</td></tr><tr><td>Pointer-less nodes*</td><td>High</td><td>High</td><td>Use index or pointer math to access children, so that each node doesn't need to store a
reference</td></tr><tr><td>Spatial Sort Construction*</td><td>High</td><td>Low</td><td>Build the tree quickly by sorting the primitives along the Hilbert curve.</td></tr></tbody></table><p><i>* Certain optimizations may not result in increased use of SIMD instructions.</i></p><h1><span class=mw-headline id=Queue><span class=mw-headline-number>6</span> Queue</span></h1><p>Upcoming work:</p><ul><li><s>Add description column to tree comparison table</s></li><li><s>Sign INRIA copyright transfer</s></li><li><s>Examine Ray-BBox intersection implementation</s><ul><li><s>Determine how SIMD may be applied.</s></li><li><s>Extract real examples of ray-bbox intersections from tetrahedral remeshing examples,
for use in benchmarking.</s></li><li><s>Create benchmark from real examples</s></li><li><s>Add a ray-bbox intersection implementation using xsimd</s><ul><li><s>Cache broadcasted ray type, in case repeated broadcast scalar operations are
hurting performance.</s></li></ul></li></ul></li><li><s>Move experimental work to a branch on cgal-public-dev</s></li><li><s>Consider appropriate SIMD libraries</s></li><li><s>Create a batched-bbox memory arrangement to compare with array-of-structs and
struct-of-arrays arrangements.</s></li><li><s>Assemble slides to explain the current progress and central challenge of the project.</s></li><li><s>Convert CGAL's existing intersection function to branchless, to see how that interacts with
the child-skipping optimization</s></li><li><s>Determine the reason CGAL's (unaltered) Mesh code examples fail on my device</s></li><li><s>Profile provided benchmarks</s><ul><li><s>Goal is to discover whether most time is spent traversing the
tree (bbox intersections), or directly testing for intersections with
primitives</s></li></ul></li><li><s>Examine BBox-BBox intersection implementation</s><ul><li><s>Create a simd-friendly version</s></li></ul></li><li><s>Benchmark BBox-BBox vs Ray-BBox vs Ray-Primitive [triangle] intersection.</s></li><li><s>Benchmark Ray-BBox vs Boxed-ray-BBox intersection</s></li><li><s>Create an N-way branch on cgal-public-dev</s></li><li><s>Document the advantages of 1-node-per-primitive</s></li><li><s>Determine a breakeven point for hilbert sort construction</s><ul><li>Produce plots which demonstrate the breakeven point</li></ul></li><li><s>Add concurrency parameter to new traits class</s></li><li><s>Move <code>expand</code>'s template specialization so it's not inline</s></li><li>Add doxygen documentation for new traits class<ul><li>API</li><li>Examples</li><li>Information about tradeoffs</li></ul></li><li>Benchmark different types of implicit trees</li></ul></div></div></div></div></div></body></html></div></article></div></div><footer><p>Powered by <a href=https://gohugo.io/>Hugo</a>,
see the source code <a href=https://github.com/JacksonCampolattaro/jacksoncampolattaro.github.io>here</a>.</p></footer></body></html>