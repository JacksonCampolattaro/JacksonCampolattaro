<!doctype html><html><head><title>SIMD</title><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link rel=stylesheet href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans|Montserrat"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://jacksoncampolattaro.github.io/css/style.min.c625e454a81350b3b43e9943b99b1cfe3e91cb1b73acb449e14021c8d3fceb10.css></head><body><header id=header><h1><a href=https://jacksoncampolattaro.github.io/>Jackson <b>Campolattaro</b></a></h1><p>Computer Engineering student at TU Delft with an enthusiasm for Open Source software</p><img id=logo src=/img/portrait-square.jpeg width=100px></header><div id=page><div id=sidebar><nav><ul><li><a href=/about><span>About</span></a></li><li><a href=/contact><span>Contact</span></a></li></ul></nav><div id=contacts><a href=https://github.com/JacksonCampolattaro><i class="fa fa-github"></i></a>
<a href=mailto:jackson.campolattaro@gmail.com><i class="fa fa-envelope"></i></a>
<a href=https://www.linkedin.com/in/jacksoncampolattaro><i class="fa fa-linkedin"></i></a></div></div><div id=content><article class=post><h1><a href=https://jacksoncampolattaro.github.io/employment/inria-simd/>SIMD</a></h1><div class=post-content><figure><img src=/img/employment/inria-logo.png></figure><p>I enjoyed my time <a href=https://jacksoncampolattaro.github.io/employment/cgal-orthtree/>building an Octree for CGAL</a>,
and I was interested in continuing the same type of work.
After the end of the summer I kept in touch with my mentor,
and he put me in contact with his colleagues at <a href=https://www.inria.fr/en>Inria</a>.
Once I knew I would be attending graduate school in Europe we made arrangements for in-person work at
<a href=https://www.inria.fr/en/inria-centre-universite-cote-azur>Inria&rsquo;s research campus</a> in Sophia Antipolis, France.</p><p>At Inria, I reported to <a href=https://team.inria.fr/titane/team/pierre-alliez/>Pierre Alliez</a>.
My goal for the summer was to look at ways SIMD instructions could be incorporated into the CGAL library.
Specifically, I examined Intel&rsquo;s <a href=https://github.com/embree/embree>Embree</a> library,
and how it used SIMD in its Bounding Volume Hierarchy to accelerate intersection searches.
The intention was to find some optimizations which could be carried over to CGAL&rsquo;s
AABB (Axis-Aligned Bounding-Box) Tree package.
Embree was a useful project to study because it was the product of hardware-software-compiler codesign:
the software engineers writing Embree worked directly with those developing the Intel Compiler,
ensuring that their code would produce optimal SIMD assembly.</p><p>This was more exploratory than previous projects, with the main work product being a regular report on my findings.
For more information, you can find a copy those notes <a href=https://jacksoncampolattaro.github.io/employment/inria-simd-blog/>here</a>.
During my time at Inria, I identified and tested the following avenues for optimization:</p><ul><li><em>N-Way Tree</em>:
Produces a shallower hierarchy than a (conventional) 2-way tree,
but this would normally be cancelled out by more expensive comparisons at each node.
With SIMD instructions, those comparisons can be done in parallel.</li><li><em>Vectorized Bounds Checking</em>:
With SIMD, we can compare the X, Y, and Z bounds of a pair of boxes in parallel,
making box-box intersections faster.
This is useful even for 2-way trees.</li><li><em>Parallel Tree Construction</em>:
Subtrees can be constructed simultaneously after higher level nodes are finished,
using conventional parallelism concepts.</li><li><em>Implicit Tree Structure</em>:
Child nodes can be placed at specific memory addresses,
so that parents don&rsquo;t need to maintain references to their children.
The splitting algorithm can distribute children so that a <em>complete</em> tree is produced,
resulting in a data structure which requires much less memory.</li><li><em>Rapid Tree Constructor</em>:
Sorting the points along a space-filling curve can be done efficiently using radix sort,
This is a way to build a low-quality tree very rapidly,
especially because it allows bounding boxes to be created from the bottom-up.</li><li><em>Modified AABB-Tree Implementations with Different Topologies</em>:
The objects sorted by CGAL&rsquo;s AABB-Tree can pre-compute their own bounding boxes.
By changing how we place child nodes in the tree structure,
we can avoid giving leaf nodes bounding boxes, reducing overall memory requirements.</li></ul><p>Over the course of the project, I also produced useful tools and tests:</p><ul><li>A script which analyzes the prevalence of SIMD instructions in a specific function of a given binary.</li><li>A script for visualizing the branches within a specific function using objdump.</li><li>Test implementations and benchmarks of simple algorithms with a variety of C++ SIMD libraries.</li><li>A number of standardized benchmark datasets for evaluating tree construction performance in different scenarios.</li></ul></div></article></div></div><footer><p>Powered by <a href=https://gohugo.io/>Hugo</a>,
see the source code <a href=https://github.com/JacksonCampolattaro/jacksoncampolattaro.github.io>here</a>.</p></footer></body></html>